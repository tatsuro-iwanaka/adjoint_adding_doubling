#ifndef __MULTIVARIATE_SPLINE_H__
#define __MULTIVARIATE_SPLINE_H__

#include<iostream>
#include<cmath>
#include<vector>
#include<string>
#include<iomanip>
#include<algorithm>
#include<sstream>
#include<filesystem>
#include<fstream>
#include<netcdf>
#include<omp.h>

namespace multivariate_spline
{
class Spline;
class BiCubicInterpolator;
class TriCubicInterpolator;
class TetraCubicInterpolator;
class PentaCubicInterpolator;

int invertMatrix(std::vector<std::vector<double>>&, std::vector<double>&);
int invertMatrix(std::vector<std::vector<double>>&);
std::vector<std::string> spritString(std::string, char);

std::string Double2Hex(double);
double Hex2Double(std::string);

enum class SPLINE_TYPE
{
	NATURAL,
	CLAMPED,
	NATURAL_CLAMPED,
	CLAMPED_NATURAL
};


class Spline
{
	private:
		void TDMA(std::vector<std::vector<double>>&, std::vector<double>&);

	public:
		std::vector<double> h = std::vector<double>(3);

		std::vector<double> a = std::vector<double>(3);
		std::vector<double> b = std::vector<double>(3);
		std::vector<double> c = std::vector<double>(3);
		std::vector<double> d = std::vector<double>(3);

		std::vector<double> x;
		std::vector<double> f;

		double interpolation(double);
		double derivative(double);
		void makeNaturalSpline(void);
		void makeClampedSpline(void);
		void makeNaturalClampedSpline(void);
		void makeClampedNaturalSpline(void);
};

/*
class Spline
{
	private:
		// Scaling parameters
		double m_x0 = 0.0;   // x offset (min)
		double m_dx = 1.0;   // x range (max-min)
		double m_fx = 1.0;   // f abs-max

		// Normalized data
		std::vector<double> xs;          // normalized x
		std::vector<double> fs;          // normalized f

		// Spline coefficients on normalized domain
		//std::vector<double> h, a, b, c, d;

		// Thomas algorithm
		void TDMA(std::vector<std::vector<double>>& A, std::vector<double>& rhs)
		{
			// Forward elimination
			A[0][1] = A[0][1] / A[0][0];
			rhs[0] = rhs[0] / A[0][0];

			int n = rhs.size();
			for(int i = 1; i < n; ++ i)
			{
				double denom = A[i][i] - A[i-1][i] * A[i][i-1];

				if (i < n-1)
				{
					A[i][i+1] /= denom;
				}

				rhs[i] = (rhs[i] - rhs[i-1] * A[i][i-1]) / denom;
			}

			// Back substitution
			for(int i = n - 2; i >= 0; -- i)
			{
				rhs[i] -= rhs[i + 1] * A[i][i + 1];
			}
		}

		// Raw interpolation on normalized data
		double interpolationRaw(double xnorm)
		{
			// Clamp to ends
			if (xnorm < xs.front())
			{
				return fs.front();
			}

			if (xnorm >= xs.back())
			{
				return fs.back();
			}

			// Locate interval
			int nx = 0;
			int N  = xs.size();
			for(int i = 0; i < N-1; ++i)
			{
				if (xs[i] <= xnorm && xnorm < xs[i + 1])
				{
					nx = i;
					break;
				}
			}

			double dx = xnorm - xs[nx];
			return a[nx] * dx * dx * dx + b[nx] * dx * dx + c[nx] * dx + d[nx];
		}

		// Raw derivative on normalized data
		double derivativeRaw(double xnorm)
		{
			// Outside domain
			// if (xnorm < xs.front() || xnorm >= xs.back())
			// 	return 0.0;

			// Locate interval
			int nx = 0;
			int N  = xs.size();

			if (xnorm < xs.front())
			{
				return c.front();
			}
			// After last knot, use slope of last segment at x=xs.back()
			if (xnorm >= xs.back())
			{
				double dx_end = xs.back() - xs[N-2];
				return 3.0 * a[N - 2] * dx_end * dx_end + 2.0 * b[N - 2] * dx_end + c[N - 2];
			}

			for(int i = 0; i < N - 1; ++i)
			{
				if (xs[i] <= xnorm && xnorm < xs[i+1])
				{
					nx = i;
					break;
				}
			}

			double dx = xnorm - xs[nx];
			return 3.0 * a[nx] * dx * dx + 2.0 * b[nx] * dx + c[nx];
		}

		// Normalize x and f into xs, fs
		void normalizeInput()
		{
			// x normalization to [0,1]
			double xmin = *std::min_element(x.begin(), x.end());
			double xmax = *std::max_element(x.begin(), x.end());
			m_x0 = xmin;
			m_dx = (xmax > xmin ? xmax - xmin : 1.0);

			// f normalization to [-1,1]
			m_fx = 0.0;
			for(double v : f)
			{
				m_fx = std::max(m_fx, std::abs(v));
			}

			if (m_fx == 0.0)
			{
				m_fx = 1.0;
			}

			// fill normalized arrays
			int N = x.size();
			xs.resize(N);
			fs.resize(N);

			for(int i = 0; i < N; ++i)
			{
				xs[i] = (x[i] - m_x0) / m_dx;
				fs[i] =  f[i] / m_fx;
			}
		}

	public:
		// Public data
		std::vector<double> x, f;          // original data on user side

		// Coefficients exposed if needed
		std::vector<double> h, a, b, c, d;

		// Natural spline
		void makeNaturalSpline(void)
		{
			if (x.size() < 2)
			{
				return;
			}

			normalizeInput();

			int N = xs.size();
			h.resize(N - 1);
			a.resize(N - 1);
			b.resize(N - 1);
			c.resize(N - 1);
			d.resize(N - 1);

			std::vector<double> ypp(N, 0.0);
			std::vector<double> s(N - 1, 0.0);

			// compute h and first differences
			for(int i = 0; i < N - 1; ++i)
			{
				h[i]    = xs[i+1] - xs[i];
				s[i]    = (fs[i + 1] - fs[i]) / h[i];
			}

			// construct matrix A and RHS ypp
			std::vector<std::vector<double>> A(N, std::vector<double>(N, 0.0));
			A[0][0] = 1.0;
			A[N - 1][N - 1] = 1.0;
			for(int i = 1; i < N - 1; ++i)
			{
				A[i][i - 1] = h[i - 1];
				A[i][i]   = 2.0 * (h[i - 1] + h[i]);
				A[i][i + 1] = h[i];
				ypp[i]    = 6.0 * (s[i] - s[i - 1]);
			}
			// solve for ypp via TDMA
			TDMA(A, ypp);

			// compute coefficients
			for(int i = 0; i < N - 1; ++i)
			{
				a[i] = (ypp[i + 1] - ypp[i]) / (6.0 * h[i]);
				b[i] = 0.5 * ypp[i];
				c[i] = s[i] - (h[i] / 6.0) * (2.0 * ypp[i] + ypp[i + 1]);
				d[i] = fs[i];
			}
		}

		// Clamped spline (specified end slopes from data)
		void makeClampedSpline(void)
		{
			if (x.size() < 2)
			{
				return;
			}

			normalizeInput();

			int N = xs.size();
			h.resize(N - 1);
			a.resize(N - 1);
			b.resize(N - 1);
			c.resize(N - 1);
			d.resize(N - 1);

			std::vector<double> ypp(N, 0.0);
			std::vector<double> s(N - 1, 0.0);

			for(int i = 0; i < N-1; ++i)
			{
				h[i] = xs[i + 1] - xs[i];
				s[i] = (fs[i + 1] - fs[i]) / h[i];
			}

			std::vector<std::vector<double>> A(N, std::vector<double>(N, 0.0));
			// clamped: second derivative conditions
			A[0][0] = 2.0 * h[0];
			A[0][1] = h[0];
			ypp[0] = 6.0 * s[0];

			A[N -1][N - 2] = h[N - 2];
			A[N -1][N - 1] = 2.0 * h[N - 2];
			ypp[N - 1] = -6.0 * s[N - 2];

			for(int i = 1; i < N - 1; ++i)
			{
				A[i][i - 1] = h[i - 1];
				A[i][i] = 2.0 * (h[i - 1] + h[i]);
				A[i][i + 1] = h[i];
				ypp[i] = 6.0 * (s[i] - s[i - 1]);
			}

			TDMA(A, ypp);

			for(int i = 0; i < N - 1; ++i)
			{
				a[i] = (ypp[i + 1] - ypp[i]) / (6.0 * h[i]);
				b[i] = 0.5 * ypp[i];
				c[i] = s[i] - (h[i] / 6.0) * (2.0 * ypp[i] + ypp[i + 1]);
				d[i] = fs[i];
			}
		}

		// Natural at start, clamped at end
		void makeNaturalClampedSpline(void)
		{
			if (x.size() < 2)
			{
				return;
			}

			normalizeInput();

			int N = xs.size();
			h.resize(N - 1);
			a.resize(N - 1);
			b.resize(N - 1);
			c.resize(N - 1);
			d.resize(N - 1);

			std::vector<double> ypp(N, 0.0);
			std::vector<double> s(N - 1, 0.0);

			for(int i = 0; i < N - 1; ++i)
			{
				h[i] = xs[i + 1] - xs[i];
				s[i] = (fs[i + 1] - fs[i]) / h[i];
			}

			std::vector<std::vector<double>> A(N, std::vector<double>(N, 0.0));
			// natural at i=0
			A[0][0] = 1.0;
			ypp[0] = 0.0;
			// clamped at end
			A[N - 1][N - 2] = h[N - 2];
			A[N - 1][N - 1] = 2.0 * h[N - 2];
			ypp[N - 1] = -6.0 * s[N - 2];

			for(int i = 1; i < N - 1; ++i)
			{
				A[i][i - 1] = h[i - 1];
				A[i][i] = 2.0 * (h[i - 1] + h[i]);
				A[i][i + 1] = h[i];
				ypp[i] = 6.0 * (s[i] - s[i - 1]);
			}
			TDMA(A, ypp);

			for(int i = 0; i < N - 1; ++i)
			{
				a[i] = (ypp[i + 1] - ypp[i]) / (6.0 * h[i]);
				b[i] = 0.5 * ypp[i];
				c[i] = s[i] - (h[i] / 6.0) * (2.0 * ypp[i] + ypp[i + 1]);
				d[i] = fs[i];
			}
		}

		// Clamped at start, natural at end
		void makeClampedNaturalSpline(void)
		{
			if (x.size() < 2)
			{
				return;
			}

			normalizeInput();

			int N = xs.size();
			h.resize(N - 1); 
			a.resize(N - 1);
			b.resize(N - 1); 
			c.resize(N - 1);
			d.resize(N - 1);

			std::vector<double> ypp(N, 0.0);
			std::vector<double> s(N - 1, 0.0);

			for(int i = 0; i < N - 1; ++ i)
			{
				h[i] = xs[i + 1] - xs[i];
				s[i] = (fs[i + 1] - fs[i]) / h[i];
			}

			std::vector<std::vector<double>> A(N, std::vector<double>(N, 0.0));
			// clamped at start
			A[0][0] = 2.0 * h[0];
			A[0][1] = h[0];
			ypp[0] = 6.0 * s[0];
			// natural at end
			A[N - 1][N - 1] = 1.0;
			ypp[N - 1] = 0.0;

			for(int i = 1; i < N - 1; ++ i)
			{
				A[i][i - 1] = h[i - 1];
				A[i][i] = 2.0 * (h[i - 1] + h[i]);
				A[i][i + 1] = h[i];
				ypp[i] = 6.0 * (s[i] - s[i - 1]);
			}

			TDMA(A, ypp);

			for(int i = 0; i < N - 1; ++ i)
			{
				a[i] = (ypp[i + 1] - ypp[i]) / (6.0 * h[i]);
				b[i] = 0.5 * ypp[i];
				c[i] = s[i] - (h[i] / 6.0) * (2.0 * ypp[i] + ypp[i + 1]);
				d[i] = fs[i];
			}
		}

	public:
		// Evaluate and unscale
		double interpolation(double x_data)
		{
			double xnorm = (x_data - m_x0) / m_dx;
			double y_norm = interpolationRaw(xnorm);
			return y_norm * m_fx;
		}

		double derivative(double x_data)
		{
			double xnorm = (x_data - m_x0) / m_dx;
			double dy_dxnorm = derivativeRaw(xnorm);
			return dy_dxnorm * (m_fx / m_dx);
		}
};
*/

class BiCubicInterpolator
{
	private:
		std::vector<std::vector<double>> A;
		//int invertMatrix(std::vector<std::vector<double>>&);

	public:
		bool regular_grid = false;

		std::vector<double> x0, x1;

		std::vector<std::vector<double>> f;	//f(x0,x1,x2)

		std::vector<std::vector<double>> fx0;	//df/dx0(x0,x1,x2)
		std::vector<std::vector<double>> fx1;	//df/dx1(x0,x1,x2)

		std::vector<std::vector<double>> fx0x1;	//d2f/dx0dx1(x0,x1,x2)

		class BiCubicSpline
		{
			private:
				//int invertMatrix(std::vector<std::vector<double>>&, std::vector<double>&);

			public:
				std::vector<std::vector<double>> a;	//a[0-3][0-3][0-3]

				std::vector<std::vector<std::vector<double>>> p;	//p[0,1][0,1][0,1][x0,x1,x2]

				std::vector<std::vector<double>> f;	//f(x0,x1,x2)

				std::vector<std::vector<double>> fx0;	//df/dx0[0,1][0,1][0,1]
				std::vector<std::vector<double>> fx1;	//df/dx1[0,1][0,1][0,1]

				std::vector<std::vector<double>> fx0x1;	//d2f/dx0dx1[0,1][0,1][0,1]

				double Dx0, Dx1;	//x1-x0

				double interpolation(double, double);
				void makeInterpolator(void);
				void makeInterpolator(std::vector<std::vector<double>>&);

				void clearData(void);
		};

		std::vector<std::vector<BiCubicSpline>> interval;
		std::vector<SPLINE_TYPE> spline_type = {SPLINE_TYPE::NATURAL, SPLINE_TYPE::NATURAL};
		
		void makeInterpolator(void);
		double interpolation(double, double);
		double interpolation(std::vector<double>);

		void initialization(void);

		void exportInterpolator(std::string);
		void exportInterpolatorNetCDF(std::string);
		void importInterpolator(std::string);
		void clear(void);
		void clearData(void);
};

class TriCubicInterpolator
{
	private:
		std::vector<std::vector<double>> A;
		//int invertMatrix(std::vector<std::vector<double>>&);

	public:
		bool regular_grid = false;

		std::vector<double> x0, x1, x2;

		std::vector<std::vector<std::vector<double>>> f;	//f(x0,x1,x2)

		std::vector<std::vector<std::vector<double>>> fx0;	//df/dx0(x0,x1,x2)
		std::vector<std::vector<std::vector<double>>> fx1;	//df/dx1(x0,x1,x2)
		std::vector<std::vector<std::vector<double>>> fx2;	//df/dx2(x0,x1,x2)

		std::vector<std::vector<std::vector<double>>> fx0x1;	//d2f/dx0dx1(x0,x1,x2)
		std::vector<std::vector<std::vector<double>>> fx0x2;	//d2f/dx0dx2(x0,x1,x2)
		std::vector<std::vector<std::vector<double>>> fx1x2;	//d2f/dx1dx2(x0,x1,x2)

		std::vector<std::vector<std::vector<double>>> fx0x1x2;	//d3f/dx0dx1dx2(x0,x1,x2)

		class TriCubicSpline
		{
			private:
				//int invertMatrix(std::vector<std::vector<double>>&, std::vector<double>&);

			public:
				std::vector<std::vector<std::vector<double>>> a;	//a[0-3][0-3][0-3]

				std::vector<std::vector<std::vector<std::vector<double>>>> p;	//p[0,1][0,1][0,1][x0,x1,x2]

				std::vector<std::vector<std::vector<double>>> f;	//f(x0,x1,x2)

				std::vector<std::vector<std::vector<double>>> fx0;	//df/dx0[0,1][0,1][0,1]
				std::vector<std::vector<std::vector<double>>> fx1;	//df/dx1[0,1][0,1][0,1]
				std::vector<std::vector<std::vector<double>>> fx2;	//df/dx2[0,1][0,1][0,1]

				std::vector<std::vector<std::vector<double>>> fx0x1;	//d2f/dx0dx1[0,1][0,1][0,1]
				std::vector<std::vector<std::vector<double>>> fx0x2;	//d2f/dx0dx2[0,1][0,1][0,1]
				std::vector<std::vector<std::vector<double>>> fx1x2;	//d2f/dx1dx2[0,1][0,1][0,1]

				std::vector<std::vector<std::vector<double>>> fx0x1x2;	//d3f/dx0dx1dx2[0,1][0,1][0,1]

				double Dx0, Dx1, Dx2;	//x1-x0

				double interpolation(double, double, double);
				void makeInterpolator(void);
				void makeInterpolator(std::vector<std::vector<double>>&);

				void clearData(void);
		};

		std::vector<std::vector<std::vector<TriCubicSpline>>> interval;
		std::vector<SPLINE_TYPE> spline_type = {SPLINE_TYPE::NATURAL, SPLINE_TYPE::NATURAL, SPLINE_TYPE::NATURAL};
		
		void makeInterpolator(void);
		double interpolation(double, double, double);
		double interpolation(std::vector<double>);

		void initialization(void);

		void exportInterpolator(std::string);
		void importInterpolator(std::string);
		void clear(void);
		void clearData(void);
};

class TetraCubicInterpolator
{
	private:
		std::vector<std::vector<double>> A;
		//int invertMatrix(std::vector<std::vector<double>>&);

	public:
		bool regular_grid = false;

		std::vector<double> x0, x1, x2, x3;

		std::vector<std::vector<std::vector<std::vector<double>>>> f;	//f(x0,x1,x2,x3)

		std::vector<std::vector<std::vector<std::vector<double>>>> fx0;	//df/dx0(x0,x1,x2,x3)
		std::vector<std::vector<std::vector<std::vector<double>>>> fx1;	//df/dx1(x0,x1,x2,x3)
		std::vector<std::vector<std::vector<std::vector<double>>>> fx2;	//df/dx2(x0,x1,x2,x3)
		std::vector<std::vector<std::vector<std::vector<double>>>> fx3;	//df/dx3(x0,x1,x2,x3)

		std::vector<std::vector<std::vector<std::vector<double>>>> fx0x1;	//d2f/dx0dx1(x0,x1,x2,x3)
		std::vector<std::vector<std::vector<std::vector<double>>>> fx0x2;	//d2f/dx0dx2(x0,x1,x2,x3)
		std::vector<std::vector<std::vector<std::vector<double>>>> fx0x3;	//d2f/dx0dx3(x0,x1,x2,x3)
		std::vector<std::vector<std::vector<std::vector<double>>>> fx1x2;	//d2f/dx1dx2(x0,x1,x2,x3)
		std::vector<std::vector<std::vector<std::vector<double>>>> fx1x3;	//d2f/dx1dx3(x0,x1,x2,x3)
		std::vector<std::vector<std::vector<std::vector<double>>>> fx2x3;	//d2f/dx2dx3(x0,x1,x2,x3)

		std::vector<std::vector<std::vector<std::vector<double>>>> fx0x1x2;	//d3f/dx0dx1dx2(x0,x1,x2,x3)
		std::vector<std::vector<std::vector<std::vector<double>>>> fx0x1x3;	//d3f/dx0dx1dx3(x0,x1,x2,x3)
		std::vector<std::vector<std::vector<std::vector<double>>>> fx0x2x3;	//d3f/dx0dx2dx3(x0,x1,x2,x3)
		std::vector<std::vector<std::vector<std::vector<double>>>> fx1x2x3;	//d3f/dx1dx2dx3(x0,x1,x2,x3)

		std::vector<std::vector<std::vector<std::vector<double>>>> fx0x1x2x3;	//d4f/dx0x1dx2dx3(x0,x1,x2,x3)

		class TetraCubicSpline
		{
			private:
				//int invertMatrix(std::vector<std::vector<double>>&, std::vector<double>&);

			public:
				std::vector<std::vector<std::vector<std::vector<double>>>> a;	//a[0-3][0-3][0-3][0-3]

				std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> p;	//p[0,1][0,1][0,1][0,1][x0,x1,x2,x3]

				std::vector<std::vector<std::vector<std::vector<double>>>> f;	//f(x0,x1,x2,x3,x4)

				std::vector<std::vector<std::vector<std::vector<double>>>> fx0;	//df/dx0[0,1][0,1][0,1][0,1]
				std::vector<std::vector<std::vector<std::vector<double>>>> fx1;	//df/dx1[0,1][0,1][0,1][0,1]
				std::vector<std::vector<std::vector<std::vector<double>>>> fx2;	//df/dx2[0,1][0,1][0,1][0,1]
				std::vector<std::vector<std::vector<std::vector<double>>>> fx3;	//df/dx3[0,1][0,1][0,1][0,1]

				std::vector<std::vector<std::vector<std::vector<double>>>> fx0x1;	//d2f/dx0dx1[0,1][0,1][0,1][0,1]
				std::vector<std::vector<std::vector<std::vector<double>>>> fx0x2;	//d2f/dx0dx2[0,1][0,1][0,1][0,1]
				std::vector<std::vector<std::vector<std::vector<double>>>> fx0x3;	//d2f/dx0dx3[0,1][0,1][0,1][0,1]
				std::vector<std::vector<std::vector<std::vector<double>>>> fx1x2;	//d2f/dx1dx2[0,1][0,1][0,1][0,1]
				std::vector<std::vector<std::vector<std::vector<double>>>> fx1x3;	//d2f/dx1dx3[0,1][0,1][0,1][0,1]
				std::vector<std::vector<std::vector<std::vector<double>>>> fx2x3;	//d2f/dx2dx3[0,1][0,1][0,1][0,1]

				std::vector<std::vector<std::vector<std::vector<double>>>> fx0x1x2;	//d3f/dx0dx1dx2[0,1][0,1][0,1][0,1]
				std::vector<std::vector<std::vector<std::vector<double>>>> fx0x1x3;	//d3f/dx0dx1dx3[0,1][0,1][0,1][0,1]
				std::vector<std::vector<std::vector<std::vector<double>>>> fx0x2x3;	//d3f/dx0dx2dx3[0,1][0,1][0,1][0,1]
				std::vector<std::vector<std::vector<std::vector<double>>>> fx1x2x3;	//d3f/dx1dx2dx3[0,1][0,1][0,1][0,1]

				std::vector<std::vector<std::vector<std::vector<double>>>> fx0x1x2x3;	//d4f/dx0x1dx2dx3[0,1][0,1][0,1][0,1]

				double Dx0, Dx1, Dx2, Dx3;	//x1-x0

				double interpolation(double, double, double, double);
				void makeInterpolator(void);
				void makeInterpolator(std::vector<std::vector<double>>&);

				void clearData(void);
		};

		std::vector<std::vector<std::vector<std::vector<TetraCubicSpline>>>> interval;
		std::vector<SPLINE_TYPE> spline_type = {SPLINE_TYPE::NATURAL, SPLINE_TYPE::NATURAL, SPLINE_TYPE::NATURAL, SPLINE_TYPE::NATURAL};
		
		void makeInterpolator(void);
		double interpolation(double, double, double, double);
		double interpolation(std::vector<double>);

		void initialization(void);

		void exportInterpolator(std::string);
		void importInterpolator(std::string);
		void clear(void);
		void clearData(void);
};

class PentaCubicInterpolator
{
	private:
		std::vector<std::vector<double>> A;
		//int invertMatrix(std::vector<std::vector<double>>&);

	public:
		bool regular_grid = false;

		std::vector<double> x0, x1, x2, x3, x4;

		std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> f;	//f(x0,x1,x2,x3,x4)

		std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx0;	//df/dx0(x0,x1,x2,x3,x4)
		std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx1;	//df/dx1(x0,x1,x2,x3,x4)
		std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx2;	//df/dx2(x0,x1,x2,x3,x4)
		std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx3;	//df/dx3(x0,x1,x2,x3,x4)
		std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx4;	//df/dx4(x0,x1,x2,x3,x4)

		std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx0x1;	//d2f/dx0dx1(x0,x1,x2,x3,x4)
		std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx0x2;	//d2f/dx0dx2(x0,x1,x2,x3,x4)
		std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx0x3;	//d2f/dx0dx3(x0,x1,x2,x3,x4)
		std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx0x4;	//d2f/dx0dx4(x0,x1,x2,x3,x4)
		std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx1x2;	//d2f/dx1dx2(x0,x1,x2,x3,x4)
		std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx1x3;	//d2f/dx1dx3(x0,x1,x2,x3,x4)
		std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx1x4;	//d2f/dx1dx4(x0,x1,x2,x3,x4)
		std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx2x3;	//d2f/dx2dx3(x0,x1,x2,x3,x4)
		std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx2x4;	//d2f/dx2dx4(x0,x1,x2,x3,x4)
		std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx3x4;	//d2f/dx3dx4(x0,x1,x2,x3,x4)

		std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx0x1x2;	//d3f/dx0dx1dx2(x0,x1,x2,x3,x4)
		std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx0x1x3;	//d3f/dx0dx1dx3(x0,x1,x2,x3,x4)
		std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx0x1x4;	//d3f/dx0dx1dx4(x0,x1,x2,x3,x4)
		std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx0x2x3;	//d3f/dx0dx2dx3(x0,x1,x2,x3,x4)
		std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx0x2x4;	//d3f/dx0dx2dx4(x0,x1,x2,x3,x4)
		std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx0x3x4;	//d3f/dx0dx3dx4(x0,x1,x2,x3,x4)
		std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx1x2x3;	//d3f/dx1dx2dx3(x0,x1,x2,x3,x4)
		std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx1x2x4;	//d3f/dx1dx2dx4(x0,x1,x2,x3,x4)
		std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx1x3x4;	//d3f/dx1dx3dx4(x0,x1,x2,x3,x4)
		std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx2x3x4;	//d3f/dx2dx3dx4(x0,x1,x2,x3,x4)

		std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx0x1x2x3;	//d4f/dx0x1dx2dx3(x0,x1,x2,x3,x4)
		std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx0x1x2x4;	//d4f/dx0x1dx2dx4(x0,x1,x2,x3,x4)
		std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx0x1x3x4;	//d4f/dx0x1dx3dx4(x0,x1,x2,x3,x4)
		std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx0x2x3x4;	//d4f/dx0x2dx3dx4(x0,x1,x2,x3,x4)
		std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx1x2x3x4;	//d4f/dx1x2dx3dx4(x0,x1,x2,x3,x4)

		std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx0x1x2x3x4;	//d5f/dx0dx1x2dx3dx4(x0,x1,x2,x3,x4)

		class PentaCubicSpline
		{
			private:
				//int invertMatrix(std::vector<std::vector<double>>&, std::vector<double>&);

			public:
				std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> a;	//a[0-3][0-3][0-3][0-3][0-3]

				std::vector<std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>> p;	//p[0,1][0,1][0,1][0,1][0,1][x0,x1,x2,x3,x4]

				std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> f;	//f(x0,x1,x2,x3,x4)

				std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx0;	//df/dx0[0,1][0,1][0,1][0,1][0,1]
				std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx1;	//df/dx1[0,1][0,1][0,1][0,1][0,1]
				std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx2;	//df/dx2[0,1][0,1][0,1][0,1][0,1]
				std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx3;	//df/dx3[0,1][0,1][0,1][0,1][0,1]
				std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx4;	//df/dx4[0,1][0,1][0,1][0,1][0,1]

				std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx0x1;	//d2f/dx0dx1[0,1][0,1][0,1][0,1][0,1]
				std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx0x2;	//d2f/dx0dx2[0,1][0,1][0,1][0,1][0,1]
				std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx0x3;	//d2f/dx0dx3[0,1][0,1][0,1][0,1][0,1]
				std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx0x4;	//d2f/dx0dx4[0,1][0,1][0,1][0,1][0,1]
				std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx1x2;	//d2f/dx1dx2[0,1][0,1][0,1][0,1][0,1]
				std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx1x3;	//d2f/dx1dx3[0,1][0,1][0,1][0,1][0,1]
				std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx1x4;	//d2f/dx1dx4[0,1][0,1][0,1][0,1][0,1]
				std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx2x3;	//d2f/dx2dx3[0,1][0,1][0,1][0,1][0,1]
				std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx2x4;	//d2f/dx2dx4[0,1][0,1][0,1][0,1][0,1]
				std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx3x4;	//d2f/dx3dx4[0,1][0,1][0,1][0,1][0,1]

				std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx0x1x2;	//d3f/dx0dx1dx2[0,1][0,1][0,1][0,1][0,1]
				std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx0x1x3;	//d3f/dx0dx1dx3[0,1][0,1][0,1][0,1][0,1]
				std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx0x1x4;	//d3f/dx0dx1dx4[0,1][0,1][0,1][0,1][0,1]
				std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx0x2x3;	//d3f/dx0dx2dx3[0,1][0,1][0,1][0,1][0,1]
				std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx0x2x4;	//d3f/dx0dx2dx4[0,1][0,1][0,1][0,1][0,1]
				std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx0x3x4;	//d3f/dx0dx3dx4[0,1][0,1][0,1][0,1][0,1]
				std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx1x2x3;	//d3f/dx1dx2dx3[0,1][0,1][0,1][0,1][0,1]
				std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx1x2x4;	//d3f/dx1dx2dx4[0,1][0,1][0,1][0,1][0,1]
				std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx1x3x4;	//d3f/dx1dx3dx4[0,1][0,1][0,1][0,1][0,1]
				std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx2x3x4;	//d3f/dx2dx3dx4[0,1][0,1][0,1][0,1][0,1]

				std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx0x1x2x3;	//d4f/dx0x1dx2dx3[0,1][0,1][0,1][0,1][0,1]
				std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx0x1x2x4;	//d4f/dx0x1dx2dx4[0,1][0,1][0,1][0,1][0,1]
				std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx0x1x3x4;	//d4f/dx0x1dx3dx4[0,1][0,1][0,1][0,1][0,1]
				std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx0x2x3x4;	//d4f/dx0x2dx3dx4[0,1][0,1][0,1][0,1][0,1]
				std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx1x2x3x4;	//d4f/dx1x2dx3dx4[0,1][0,1][0,1][0,1][0,1]

				std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>> fx0x1x2x3x4;	//d5f/dx0dx1x2dx3dx4[0,1][0,1][0,1][0,1][0,1]

				double Dx0, Dx1, Dx2, Dx3, Dx4;	//x1-x0

				double interpolation(double, double, double, double, double);
				void makeInterpolator(void);
				void makeInterpolator(std::vector<std::vector<double>>&);
				void clearData(void);
		};

		std::vector<std::vector<std::vector<std::vector<std::vector<PentaCubicSpline>>>>> interval;
		std::vector<SPLINE_TYPE> spline_type = {SPLINE_TYPE::NATURAL, SPLINE_TYPE::NATURAL, SPLINE_TYPE::NATURAL, SPLINE_TYPE::NATURAL, SPLINE_TYPE::NATURAL};
		
		void makeInterpolator(void);
		void makeInterpolator(std::string);
		double interpolation(double, double, double, double, double);
		double interpolation(std::vector<double>);

		void initialization(void);

		void exportInterpolator(std::string);
		void importInterpolator(std::string);
		void clear(void);
		void clearData(void);
};

inline std::vector<std::string> spritString(std::string str, char del)
{
	int first = 0;
	int last = str.find_first_of(del);

	if(last != std::string::npos)
	{
		std::vector<std::string> result;

		while (first < str.size())
		{
			std::string subStr(str, first, last - first);

			result.push_back(subStr);

			first = last + 1;
			last = str.find_first_of(del, first);

			if (last == std::string::npos)
			{
				last = str.size();
			}
		}

		return result;
	}
	else
	{
		std::vector<std::string> result = {str};
		return result;
	}

}

inline int invertMatrix(std::vector<std::vector<double>> &A)
{
	int ipv, pivot_row;
	double inv_pivot;
	const int n = A.size();
	std::vector<int> row(n);

	for(int ipv = 0; ipv < n; ipv ++)
	{
		double big = 0.0;
		int pivot_row = -1;

		#pragma omp parallel
		{
			double big_private = 0.0;
			int pivot_row_private = -1;

			#pragma omp for nowait
			for(int i = ipv; i < n; i ++)
			{
				if(std::abs(A[i][ipv]) > big_private)
				{
					big_private = std::abs(A[i][ipv]);
					pivot_row_private = i;
				}
			}
			#pragma omp critical
			{
				if(big_private > big)
				{
					big = big_private;
					pivot_row = pivot_row_private;
				}
			}
		}

		if(big == 0.0)
		{
			return 0;
		}
		row[ipv] = pivot_row;

		if(ipv != pivot_row)
		{
			#pragma omp parallel for
			for(int i = 0; i < n; i ++)
			{
				double temp = A[ipv][i];
				A[ipv][i] = A[pivot_row][i];
				A[pivot_row][i] = temp;
			}
		}

		inv_pivot = 1.0 / A[ipv][ipv];

		A[ipv][ipv] = 1.0;

		#pragma omp parallel for
		for(int j = 0; j < n; j ++)
		{
			A[ipv][j] *= inv_pivot;
		}

		for(int i = 0; i < n; i ++)
		{
			if(i != ipv)
			{
				double temp = A[i][ipv];

				A[i][ipv] = 0.0;

				#pragma omp parallel for
				for(int j = 0; j < n; j ++)
				{
					A[i][j] -= temp * A[ipv][j];
				}
			}
		}
	}

	for(int j = n - 1; j >= 0; j --)
	{
		if(j != row[j])
		{
			#pragma omp parallel for
			for(int i = 0; i < n; i ++)
			{
				double temp = A[i][j];
				A[i][j] = A[i][row[j]];
				A[i][row[j]] = temp;
			}
		}
	}

	return 1;
}

inline int invertMatrix(std::vector<std::vector<double>> &A, std::vector<double> &rhs)
{
	int ipv, pivot_row;
	double inv_pivot;
	const int n = A.size();
	std::vector<int> row(n);

	for(int ipv = 0; ipv < n; ipv ++)
	{
		double big = 0.0;
		int pivot_row = -1;

		#pragma omp parallel
		{
			double big_private = 0.0;
			int pivot_row_private = -1;

			#pragma omp for nowait
			for(int i = ipv; i < n; i ++)
			{
				if(std::abs(A[i][ipv]) > big_private)
				{
					big_private = std::abs(A[i][ipv]);
					pivot_row_private = i;
				}
			}
			#pragma omp critical
			{
				if(big_private > big)
				{
					big = big_private;
					pivot_row = pivot_row_private;
				}
			}
		}

		if(big == 0.0)
		{
			return 0;
		}
		row[ipv] = pivot_row;

		if(ipv != pivot_row)
		{
			#pragma omp parallel for
			for(int i = 0; i < n; i ++)
			{
				double temp = A[ipv][i];
				A[ipv][i] = A[pivot_row][i];
				A[pivot_row][i] = temp;
			}
		}

		inv_pivot = 1.0 / A[ipv][ipv];

		A[ipv][ipv] = 1.0;

		#pragma omp parallel for
		for(int j = 0; j < n; j ++)
		{
			A[ipv][j] *= inv_pivot;
		}

		for(int i = 0; i < n; i ++)
		{
			if(i != ipv)
			{
				double temp = A[i][ipv];

				A[i][ipv] = 0.0;

				#pragma omp parallel for
				for(int j = 0; j < n; j ++)
				{
					A[i][j] -= temp * A[ipv][j];
				}
			}
		}
	}

	for(int j = n - 1; j >= 0; j --)
	{
		if(j != row[j])
		{
			#pragma omp parallel for
			for(int i = 0; i < n; i ++)
			{
				double temp = A[i][j];
				A[i][j] = A[i][row[j]];
				A[i][row[j]] = temp;
			}
		}
	}

	auto ans = rhs;

	#pragma omp parallel for
	for(int i = 0; i < rhs.size(); i ++)
	{
		rhs[i] = 0.0;
		for(int j = 0; j < rhs.size(); j ++)
		{
			rhs[i] += A[i][j] * ans[j];
		}
	}

	return 1;
}

inline std::string Double2Hex(double x)
{
	union Data
	{
		double d;
		unsigned char c[8];
	};

	Data data;
	data.d = x;
	std::vector<int> bit;

	for(int i = 7; i >= 0; i --)
	{
		unsigned char ch = data.c[i];
		for(int j = 7; j >=0; j --)
		{
			if((ch >> j) & 1)
			{
				bit.push_back(1);
			}
			else
			{
				bit.push_back(0);
			}
		}
	}

	std::string bin2hex = "0123456789abcdef";

	// auto bin2hex = [](std::vector<int> bin)
	// {
	// 	int idx = bin[0] * 8 + bin[1] * 4 + bin[2] * 2 + bin[3];
	// 	switch(idx)
	// 	{
	// 		case 0: return '0';
	// 		case 1: return '1';
	// 		case 2: return '2';
	// 		case 3: return '3';
	// 		case 4: return '4';
	// 		case 5: return '5';
	// 		case 6: return '6';
	// 		case 7: return '7';
	// 		case 8: return '8';
	// 		case 9: return '9';
	// 		case 10: return 'a';
	// 		case 11: return 'b';
	// 		case 12: return 'c';
	// 		case 13: return 'd';
	// 		case 14: return 'e';
	// 		case 15: return 'f';
	// 		default: return '0';
	// 	}
	// };

	std::string hex;
	hex.resize(16);

	#pragma omp parallel for
	for(int i = 0; i < 16; i ++)
	{
		//std::vector<int> temp(4);
		//temp = {bit[i * 4], bit[i * 4 + 1], bit[i * 4 + 2], bit[i * 4 + 3]};
		//hex[i] = bin2hex(temp);
		hex[i] = bin2hex[bit[i * 4] * 8 + bit[i * 4 + 1] * 4 + bit[i * 4 + 2] * 2 + bit[i * 4 + 3]];
	}

	return hex;
}

inline double Hex2Double(std::string hex)
{
	for(int i = 0; i < hex.size(); i ++)
	{
		if(hex[i] == ' ')
		{
			hex.erase(i, 1);
			i --;
		}
	}

	union Data
	{
		double d;
		unsigned char c[8];
	};

	std::vector<std::vector<int>> hex2bin = {{0, 0, 0, 0}, {0, 0, 0, 1}, {0, 0, 1, 0}, {0, 0, 1, 1}, {0, 1, 0, 0}, {0, 1, 0, 1}, {0, 1, 1, 0}, {0, 1, 1, 1}, {1, 0, 0, 0}, {1, 0, 0, 1}, {1, 0, 1, 0}, {1, 0, 1, 1}, {1, 1, 0, 0}, {1, 1, 0, 1}, {1, 1, 1, 0}, {1, 1, 1, 1}, {1, 0, 1, 0}, {1, 0, 1, 1}, {1, 1, 0, 0}, {1, 1, 0, 1}, {1, 1, 1, 0}, {1, 1, 1, 1}};

	// auto hex2bin = [](std::string c)
	// {
	// 	std::vector<int> result(4);
		
	// 	switch(c[0])
	// 	{
	// 		case '0': result = {0, 0, 0, 0};
	// 		case '1': result = {0, 0, 0, 1};
	// 		case '2': result = {0, 0, 1, 0};
	// 		case '3': result = {0, 0, 1, 1};
	// 		case '4': result = {0, 1, 0, 0};
	// 		case '5': result = {0, 1, 0, 1};
	// 		case '6': result = {0, 1, 1, 0};
	// 		case '7': result = {0, 1, 1, 1};
	// 		case '8': result = {1, 0, 0, 0};
	// 		case '9': result = {1, 0, 0, 1};
	// 		case 'a': result = {1, 0, 1, 0};
	// 		case 'b': result = {1, 0, 1, 1};
	// 		case 'c': result = {1, 1, 0, 0};
	// 		case 'd': result = {1, 1, 0, 1};
	// 		case 'e': result = {1, 1, 1, 0};
	// 		case 'f': result = {1, 1, 1, 1};
	// 		case 'A': result = {1, 0, 1, 0};
	// 		case 'B': result = {1, 0, 1, 1};
	// 		case 'C': result = {1, 1, 0, 0};
	// 		case 'D': result = {1, 1, 0, 1};
	// 		case 'E': result = {1, 1, 1, 0};
	// 		case 'F': result = {1, 1, 1, 1};
	// 		default:  result = {0, 0, 0, 0};
	// 	}

	// 	return result;
	// };

	Data data;
	
	std::vector<int> bit(64);

	for(int i = 7; i >= 0; i --)
	{
		//std::string cl;
		//cl.push_back(hex[2 * (7 - i) + 1]);
		int cl = hex[2 * (7 - i) + 1] - '0';
		if(cl > 9)
		{
			cl = hex[2 * (7 - i) + 1] - 'a';
		}
		auto decl = hex2bin[cl];
		//std::string cu;
		//cu.push_back(hex[2 * (7 - i)]);
		int cu = hex[2 * (7 - i)] - '0';
		if(cu > 9)
		{
			cu = hex[2 * (7 - i)] - 'a';
		}
		auto decu = hex2bin[cu];

		for(int j = 0; j < 4; j ++)
		{
			if(decu[j] == 1)
			{
				data.c[i] |= (1 << (7 - j));
			}
			else if(decu[j] == 0)
			{
				data.c[i] &= ~(1 << (7 - j));
			}

			if(decl[j] == 1)
			{
				data.c[i] |= (1 << (3 - j));
			}
			else if(decl[j] == 0)
			{
				data.c[i] &= ~(1 << (3 - j));
			}
		}
	}

	return data.d;
}

inline double Spline::interpolation(double x_data)
{
	double result = 0.0;

	int nx = 0;

	if(x_data < x[0])
	{
		return f[0];
	}
	else if(x_data >= x[x.size() - 1])
	{
		return f[x.size() - 1];
	}

	for(int i = 0; i < x.size() - 1; i ++)
	{
		if(x[i] <= x_data && x_data < x[i + 1])
		{
			nx = i;
		}
	}
	if(x[x.size() - 1] == x_data)
	{
		nx = x.size() - 1;
	}

	result += a[nx] * (x_data - x[nx]) * (x_data - x[nx]) * (x_data - x[nx]);
	result += b[nx] * (x_data - x[nx]) * (x_data - x[nx]);
	result += c[nx] * (x_data - x[nx]);
	result += d[nx];

	return result;
}

inline double Spline::derivative(double x_data)
{
	double result = 0.0;

	int nx = 0;

	if(x_data < x[0])
	{
		return f[0];
	}
	else if(x_data >= x[x.size() - 1])
	{
		return f[x.size() - 1];
	}

	for(int i = 0; i < x.size() - 1; i ++)
	{
		if(x[i] <= x_data && x_data < x[i + 1])
		{
			nx = i;
		}
	}
	if(x[x.size() - 1] == x_data)
	{
		nx = x.size() - 1;
	}

	result += 3.0 * a[nx] * (x_data - x[nx]) * (x_data - x[nx]);
	result += 2.0 * b[nx] * (x_data - x[nx]);
	result += c[nx];

	return result;
}

inline void Spline::makeNaturalSpline(void)
{
	h.resize(x.size() - 1);

	a.resize(x.size() - 1);
	b.resize(x.size() - 1);
	c.resize(x.size() - 1);
	d.resize(x.size() - 1);

	std::vector<double> ypp(x.size(), 0.0);
	std::vector<double> s(x.size() - 1, 0.0);

	#pragma omp parallel for
	for(int i = 0; i < h.size(); i ++)
	{
		h[i] = x[i + 1] - x[i];
		s[i] = (f[i + 1] - f[i]) / (x[i + 1] - x[i]);
	}

	std::vector<std::vector<double>> A = std::vector<std::vector<double>>(x.size(), std::vector<double>(x.size(), 0.0));

	A[0][0] = 1.0;
	A[A.size() - 1][A.size() - 1] = 1.0;
	ypp[0] = 0.0;
	ypp[A.size() - 1] = 0.0;

	#pragma omp parallel for
	for(int i = 1; i < A.size() - 1; i ++)
	{
		A[i][i - 1] = h[i - 1];
		A[i][i] = 2.0 * (h[i - 1] + h[i]);
		A[i][i + 1] = h[i];
	}

	#pragma omp parallel for
	for(int i = 1; i < A.size() - 1; i ++)
	{
		ypp[i] = 6.0 * (s[i] - s[i - 1]);
	}

	TDMA(A, ypp);

	for(int i = 0; i < a.size(); i ++)
	{
		a[i] = (ypp[i + 1] - ypp[i]) / (6.0 * h[i]);
		b[i] = 0.5 * ypp[i];
		c[i] = s[i] - h[i] / 6.0 * (2.0 * ypp[i] + ypp[i + 1]);
		d[i] = f[i];
	}

	return;
}

inline void Spline::makeClampedSpline(void)
{
	h.resize(x.size() - 1);

	a.resize(x.size() - 1);
	b.resize(x.size() - 1);
	c.resize(x.size() - 1);
	d.resize(x.size() - 1);

	std::vector<double> ypp(x.size(), 0.0);
	std::vector<double> s(x.size() - 1, 0.0);

	#pragma omp parallel for
	for(int i = 0; i < h.size(); i ++)
	{
		h[i] = x[i + 1] - x[i];
		s[i] = (f[i + 1] - f[i]) / (x[i + 1] - x[i]);
	}

	std::vector<std::vector<double>> A = std::vector<std::vector<double>>(x.size(), std::vector<double>(x.size(), 0.0));

	A[0][0] = 2.0 * h[0];
	A[0][1] = h[0];
	A[A.size() - 1][A.size() - 2] = h[h.size() - 1];
	A[A.size() - 1][A.size() - 1] = 2.0 * h[h.size() - 1];
	ypp[0] = 6.0 * s[0];
	ypp[A.size() - 1] = -6.0 * s[s.size() - 1];

	#pragma omp parallel for
	for(int i = 1; i < A.size() - 1; i ++)
	{
		A[i][i - 1] = h[i - 1];
		A[i][i] = 2.0 * (h[i - 1] + h[i]);
		A[i][i + 1] = h[i];
	}

	#pragma omp parallel for
	for(int i = 1; i < A.size() - 1; i ++)
	{
		ypp[i] = 6.0 * (s[i] - s[i - 1]);
	}

	TDMA(A, ypp);
	//invertMatrix(A, ypp);

	for(int i = 0; i < a.size(); i ++)
	{
		a[i] = (ypp[i + 1] - ypp[i]) / (6.0 * h[i]);
		b[i] = 0.5 * ypp[i];
		c[i] = s[i] - h[i] / 6.0 * (2.0 * ypp[i] + ypp[i + 1]);
		d[i] = f[i];
	}

	return;
}

inline void Spline::makeNaturalClampedSpline(void)
{
	h.resize(x.size() - 1);

	a.resize(x.size() - 1);
	b.resize(x.size() - 1);
	c.resize(x.size() - 1);
	d.resize(x.size() - 1);

	std::vector<double> ypp(x.size(), 0.0);
	std::vector<double> s(x.size() - 1, 0.0);

	#pragma omp parallel for
	for(int i = 0; i < h.size(); i ++)
	{
		h[i] = x[i + 1] - x[i];
		s[i] = (f[i + 1] - f[i]) / (x[i + 1] - x[i]);
	}

	std::vector<std::vector<double>> A = std::vector<std::vector<double>>(x.size(), std::vector<double>(x.size(), 0.0));

	A[0][0] = 1.0;
	A[A.size() - 1][A.size() - 2] = h[h.size() - 1];
	A[A.size() - 1][A.size() - 1] = 2.0 * h[h.size() - 1];
	ypp[0] = 0.0;
	ypp[A.size() - 1] = -6.0 * s[s.size() - 1];

	#pragma omp parallel for
	for(int i = 1; i < A.size() - 1; i ++)
	{
		A[i][i - 1] = h[i - 1];
		A[i][i] = 2.0 * (h[i - 1] + h[i]);
		A[i][i + 1] = h[i];
	}

	#pragma omp parallel for
	for(int i = 1; i < A.size() - 1; i ++)
	{
		ypp[i] = 6.0 * (s[i] - s[i - 1]);
	}

	TDMA(A, ypp);
	//invertMatrix(A, ypp);

	for(int i = 0; i < a.size(); i ++)
	{
		a[i] = (ypp[i + 1] - ypp[i]) / (6.0 * h[i]);
		b[i] = 0.5 * ypp[i];
		c[i] = s[i] - h[i] / 6.0 * (2.0 * ypp[i] + ypp[i + 1]);
		d[i] = f[i];
	}

	return;
}

inline void Spline::makeClampedNaturalSpline(void)
{
	h.resize(x.size() - 1);

	a.resize(x.size() - 1);
	b.resize(x.size() - 1);
	c.resize(x.size() - 1);
	d.resize(x.size() - 1);

	std::vector<double> ypp(x.size(), 0.0);
	std::vector<double> s(x.size() - 1, 0.0);

	#pragma omp parallel for
	for(int i = 0; i < h.size(); i ++)
	{
		h[i] = x[i + 1] - x[i];
		s[i] = (f[i + 1] - f[i]) / (x[i + 1] - x[i]);
	}

	std::vector<std::vector<double>> A = std::vector<std::vector<double>>(x.size(), std::vector<double>(x.size(), 0.0));

	A[0][0] = 2.0 * h[0];
	A[0][1] = h[0];
	A[A.size() - 1][A.size() - 1] = 1.0;
	ypp[0] = 6.0 * s[0];
	ypp[A.size() - 1] = 0.0;

	#pragma omp parallel for
	for(int i = 1; i < A.size() - 1; i ++)
	{
		A[i][i - 1] = h[i - 1];
		A[i][i] = 2.0 * (h[i - 1] + h[i]);
		A[i][i + 1] = h[i];
	}

	#pragma omp parallel for
	for(int i = 1; i < A.size() - 1; i ++)
	{
		ypp[i] = 6.0 * (s[i] - s[i - 1]);
	}

	TDMA(A, ypp);
	//invertMatrix(A, ypp);

	for(int i = 0; i < a.size(); i ++)
	{
		a[i] = (ypp[i + 1] - ypp[i]) / (6.0 * h[i]);
		b[i] = 0.5 * ypp[i];
		c[i] = s[i] - h[i] / 6.0 * (2.0 * ypp[i] + ypp[i + 1]);
		d[i] = f[i];
	}

	return;
}

inline void Spline::TDMA(std::vector<std::vector<double>>& A, std::vector<double>& rhs)
{
	A[0][1] = A[0][1] / A[0][0];
	rhs[0] = rhs[0] / A[0][0];

	for(int i = 1; i < rhs.size(); i ++)
	{
		if(i < rhs.size() - 1)
		{
			A[i][i + 1] = A[i][i + 1] / (A[i][i] - A[i - 1][i] * A[i][i - 1]);
		}
		rhs[i] = (rhs[i] - rhs[i - 1] * A[i][i - 1]) / (A[i][i] - A[i - 1][i] * A[i][i - 1]);
	}

	for(int i = rhs.size() - 2; i >= 0; i --)
	{
		rhs[i] = rhs[i] - rhs[i + 1] * A[i][i + 1];
	}

	return;
}

inline void BiCubicInterpolator::makeInterpolator(void)
{
	int Nx0 = x0.size();
	int Nx1 = x1.size();

	std::vector<Spline> spline_x0 = std::vector<Spline>(Nx1);
	std::vector<Spline> spline_x1 = std::vector<Spline>(Nx0);

	//MakeSpline spline_x0
	for(int nx1 = 0; nx1 < Nx1; nx1 ++)
	{
		for(int nx0 = 0; nx0 < Nx0; nx0 ++)
		{
			spline_x0[nx1].x.push_back(x0[nx0]);
			spline_x0[nx1].f.push_back(f[nx0][nx1]);
		}
		if(spline_type[0] == SPLINE_TYPE::NATURAL)
		{
			spline_x0[nx1].makeNaturalSpline();
		}
		else if(spline_type[0] == SPLINE_TYPE::CLAMPED)
		{
			spline_x0[nx1].makeClampedSpline();
		}
	}

	//MakeSpline spline_x1
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			spline_x1[nx0].x.push_back(x1[nx1]);
			spline_x1[nx0].f.push_back(f[nx0][nx1]);
		}
		if(spline_type[1] == SPLINE_TYPE::NATURAL)
		{
			spline_x1[nx0].makeNaturalSpline();
		}
		else if(spline_type[1] == SPLINE_TYPE::CLAMPED)
		{
			spline_x1[nx0].makeClampedSpline();
		}
	}

	//Derive fx0, fx1, fx2
	fx0 = std::vector<std::vector<double>>(Nx0, std::vector<double>(Nx1));
	fx1 = std::vector<std::vector<double>>(Nx0, std::vector<double>(Nx1));

	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			if(nx0 != Nx0 - 1)
			{
				fx0[nx0][nx1] = spline_x0[nx1].c[nx0];
			}
			else
			{
				double Dx0 = x0[Nx0 - 1] - x0[Nx0 - 2];
				fx0[nx0][nx1] = 3.0 * spline_x0[nx1].a[nx0 - 1] * Dx0 * Dx0 + 2.0 * spline_x0[nx1].b[nx0 - 1] * Dx0 + spline_x0[nx1].c[nx0 - 1];
			}

			if(nx1 != Nx1 - 1)
			{
				fx1[nx0][nx1] = spline_x1[nx0].c[nx1];
			}
			else
			{
				double Dx1 = x1[Nx1 - 1] - x1[Nx1 - 2];
				fx1[nx0][nx1] = 3.0 * spline_x1[nx0].a[nx1 - 1] * Dx1 * Dx1 + 2.0 * spline_x1[nx0].b[nx1 - 1] * Dx1 + spline_x1[nx0].c[nx1 - 1];
			}
		}
	}

	std::vector<Spline> spline_dx0_x1 = std::vector<Spline>(Nx0);	// for fx0x1

	//MakeSpline spline_dx0_x1
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			spline_dx0_x1[nx0].x.push_back(x1[nx1]);
			spline_dx0_x1[nx0].f.push_back(fx0[nx0][nx1]);
		}

		if(spline_type[1] == SPLINE_TYPE::NATURAL)
		{
			spline_dx0_x1[nx0].makeNaturalSpline();
		}
		else if(spline_type[1] == SPLINE_TYPE::CLAMPED)
		{
			spline_dx0_x1[nx0].makeClampedSpline();
		}
	}
	
	fx0x1 = std::vector<std::vector<double>>(Nx0, std::vector<double>(Nx1));
	
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			if(nx1 != Nx1 - 1)
			{
				fx0x1[nx0][nx1] = spline_dx0_x1[nx0].c[nx1];
			}
			else
			{
				double Dx1 = x1[Nx1 - 1] - x1[Nx1 - 2];
				fx0x1[nx0][nx1] = 3.0 * spline_dx0_x1[nx0].a[nx1 - 1] * Dx1 * Dx1 + 2.0 * spline_dx0_x1[nx0].b[nx1 - 1] * Dx1 + spline_dx0_x1[nx0].c[nx1 - 1];
			}
		}
	}

	interval = std::vector<std::vector<BiCubicSpline>>(Nx0 - 1, std::vector<BiCubicSpline>(Nx1 - 1));

	for(int nx0 = 0; nx0 < Nx0 - 1; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1 - 1; nx1 ++)
		{
			interval[nx0][nx1].p = std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)));
			interval[nx0][nx1].f = std::vector<std::vector<double>>(2, std::vector<double>(2));
			interval[nx0][nx1].fx0 = std::vector<std::vector<double>>(2, std::vector<double>(2));
			interval[nx0][nx1].fx1 = std::vector<std::vector<double>>(2, std::vector<double>(2));
			interval[nx0][nx1].fx0x1 = std::vector<std::vector<double>>(2, std::vector<double>(2));
			
			for(int i = 0; i < 2; i ++)
			{
				for(int j = 0; j < 2; j ++)
				{
					interval[nx0][nx1].p[i][j] = {x0[nx0 + i], x1[nx1 + j]};
					interval[nx0][nx1].f[i][j] = f[nx0 + i][nx1 + j];
					interval[nx0][nx1].fx0[i][j] = fx0[nx0 + i][nx1 + j];
					interval[nx0][nx1].fx1[i][j] = fx1[nx0 + i][nx1 + j];
					interval[nx0][nx1].fx0x1[i][j] = fx0x1[nx0 + i][nx1 + j];
				}
			}
		}
	}


	if(regular_grid == true)
	{
		A = std::vector<std::vector<double>>(16, std::vector<double>(16));
		double Dx0 = x0[1] - x0[0];
		double Dx1 = x1[1] - x1[0];

		auto pow = [](double v1, int v2)
		{
			if(v1 == 0 && v2 == 0)
			{
				return 1.0;
			}
			else if(v1 == 0)
			{
				return 0.0;
			}
			else if(v2 == 0)
			{
				return 1.0;
			}
			else
			{
				return std::pow(v1, double(v2));
			}
		};

		for(int nx1 = 0; nx1 < 2; nx1 ++)
		{
			double dx1 = Dx1 * (double(nx1));

			for(int nx0 = 0; nx0 < 2; nx0 ++)
			{
				double dx0 = Dx0 * (double(nx0));

				int row = nx1 * 2 + nx0;

				for(int j = 0; j < 4; j ++)
				{
					for(int i = 0; i < 4; i ++)
					{
						int col = j * 4 + i;

						//f
						A[row][col] = pow(dx0, i) * pow(dx1, j);

						//fx
						if(i == 0)
						{
							A[row + 4 * 1][col] = 0.0;
						}
						else
						{
							A[row + 4 * 1][col] = double(i) * pow(dx0, i - 1) * pow(dx1, j);
						}

						if(j == 0)
						{
							A[row + 4 * 2][col] = 0.0;
						}
						else
						{
							A[row + 4 * 2][col] = double(j) * pow(dx0, i) * pow(dx1, j - 1);
						}

						//fxx
						if(i == 0 || j == 0)
						{
							A[row + 4 * 3][col] = 0.0;
						}
						else
						{
							A[row + 4 * 3][col] = double(i) * double(j) * pow(dx0, i - 1) * pow(dx1, j - 1);
						}
					}
				}
			}
		}

		invertMatrix(A);
	}

	for(int nx0 = 0; nx0 < Nx0 - 1; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1 - 1; nx1 ++)
		{
			interval[nx0][nx1].p = std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)));
			interval[nx0][nx1].f = std::vector<std::vector<double>>(2, std::vector<double>(2));
			interval[nx0][nx1].fx0 = std::vector<std::vector<double>>(2, std::vector<double>(2));
			interval[nx0][nx1].fx1 = std::vector<std::vector<double>>(2, std::vector<double>(2));
			interval[nx0][nx1].fx0x1 = std::vector<std::vector<double>>(2, std::vector<double>(2));
			
			for(int i = 0; i < 2; i ++)
			{
				for(int j = 0; j < 2; j ++)
				{
					interval[nx0][nx1].p[i][j] = {x0[nx0 + i], x1[nx1 + j]};
					interval[nx0][nx1].f[i][j] = f[nx0 + i][nx1 + j];
					interval[nx0][nx1].fx0[i][j] = fx0[nx0 + i][nx1 + j];
					interval[nx0][nx1].fx1[i][j] = fx1[nx0 + i][nx1 + j];
					interval[nx0][nx1].fx0x1[i][j] = fx0x1[nx0 + i][nx1 + j];
				}
			}

			if(regular_grid == false)
			{
				interval[nx0][nx1].makeInterpolator();
			}
			else if(regular_grid == true)
			{
				interval[nx0][nx1].makeInterpolator(A);
			}

			interval[nx0][nx1].clearData();
		}
	}

	clearData();

	return;
}

inline void BiCubicInterpolator::BiCubicSpline::makeInterpolator(std::vector<std::vector<double>>& A)
{
	std::vector<double> rhs(16);
	std::vector<double> ans(16);

	int row;

	for(int nx1 = 0; nx1 < 2; nx1 ++)
	{
		for(int nx0 = 0; nx0 < 2; nx0 ++)
		{
			row = nx1 * 2 + nx0;
			rhs[row] = f[nx0][nx1];
			rhs[row + 4 * 1] = fx0[nx0][nx1];
			rhs[row + 4 * 2] = fx1[nx0][nx1];
			rhs[row + 4 * 3] = fx0x1[nx0][nx1];
		}
	}

	#pragma omp parallel for
	for(int i = 0; i < rhs.size(); i ++)
	{
		ans[i] = 0.0;
		for(int j = 0; j < rhs.size(); j ++)
		{
			ans[i] += A[i][j] * rhs[j];
		}
	}

	a = std::vector<std::vector<double>>(4, std::vector<double>(4));

	for(int nx1 = 0; nx1 < 4; nx1 ++)
	{
		for(int nx0 = 0; nx0 < 4; nx0 ++)
		{
			int idx = nx1 * 4 + nx0;
			a[nx0][nx1] = ans[idx];
		}
	}

	return;
}

inline double BiCubicInterpolator::BiCubicSpline::interpolation(double dx0, double dx1)
{
	double result = 0.0;

	//std::cout << x00 << ", " << x10 << ", " << x20 << ", " << x30 << ", " << x40 << std::flush;

	//std::cout << ", " << dx0 << ", " << dx1 << ", " << dx2 << ", " << dx3 << ", " << dx4 << std::endl << std::flush;

	auto pow = [](double v1, int v2)
	{
		if(v1 == 0 && v2 == 0)
		{
			return 1.0;
		}
		else if(v1 == 0)
		{
			return 0.0;
		}
		else if(v2 == 0)
		{
			return 1.0;
		}
		else
		{
			return std::pow(v1, double(v2));
		}
    };

	for(int i = 0; i < 4; i ++)
	{
		for(int j = 0; j < 4; j ++)
		{
			result += a[i][j] * pow(dx0, i) * pow(dx1, j);
		}
	}

	return result;
}

inline void BiCubicInterpolator::BiCubicSpline::makeInterpolator(void)
{
	std::vector<std::vector<double>> A = std::vector<std::vector<double>>(16, std::vector<double>(16));

	Dx0 = p[1][0][0] - p[0][0][0];
	Dx1 = p[0][1][1] - p[0][0][1];

	std::vector<double> rhs(16);

	auto pow = [](double v1, int v2)
	{
		if(v1 == 0 && v2 == 0)
		{
			return 1.0;
		}
		else if(v1 == 0)
		{
			return 0.0;
		}
		else if(v2 == 0)
		{
			return 1.0;
		}
		else
		{
			return std::pow(v1, double(v2));
		}
	};

	int row;

	for(int nx1 = 0; nx1 < 2; nx1 ++)
	{
		double dx1 = Dx1 * (double(nx1));

		for(int nx0 = 0; nx0 < 2; nx0 ++)
		{
			double dx0 = Dx0 * (double(nx0));

			int row = nx1 * 2 + nx0;

			for(int j = 0; j < 4; j ++)
			{
				for(int i = 0; i < 4; i ++)
				{
					int col = j * 4 + i;

					//f
					A[row][col] = pow(dx0, i) * pow(dx1, j);

					//fx
					if(i == 0)
					{
						A[row + 4 * 1][col] = 0.0;
					}
					else
					{
						A[row + 4 * 1][col] = double(i) * pow(dx0, i - 1) * pow(dx1, j);
					}

					if(j == 0)
					{
						A[row + 4 * 2][col] = 0.0;
					}
					else
					{
						A[row + 4 * 2][col] = double(j) * pow(dx0, i) * pow(dx1, j - 1);
					}

					//fxx
					if(i == 0 || j == 0)
					{
						A[row + 4 * 3][col] = 0.0;
					}
					else
					{
						A[row + 4 * 3][col] = double(i) * double(j) * pow(dx0, i - 1) * pow(dx1, j - 1);
					}
				}
			}
		
			rhs[row] = f[nx0][nx1];
			rhs[row + 4 * 1] = fx0[nx0][nx1];
			rhs[row + 4 * 2] = fx1[nx0][nx1];
			rhs[row + 4 * 3] = fx0x1[nx0][nx1];
		}
	}

	invertMatrix(A, rhs);

	a = std::vector<std::vector<double>>(4, std::vector<double>(4));

	for(int nx1 = 0; nx1 < 4; nx1 ++)
	{
		for(int nx0 = 0; nx0 < 4; nx0 ++)
		{
			int idx = nx1 * 4 + nx0;
			a[nx0][nx1] = rhs[idx];
		}
	}

	return;
}

inline double BiCubicInterpolator::interpolation(double x00, double x10)
{
	double result = 0.0;

	int nx0 = 0;
	int nx1 = 0;

	for(int i = 0; i < x0.size() - 1; i ++)
	{
		if(x0[i] <= x00 && x00 <= x0[i + 1])
		{
			nx0 = i;
			break;
		}
	}
	for(int i = 0; i < x1.size() - 1; i ++)
	{
		if(x1[i] <= x10 && x10 <= x1[i + 1])
		{
			nx1 = i;
			break;
		}
	}

	result = interval[nx0][nx1].interpolation(x00 - x0[nx0], x10 - x1[nx1]);

	return result;
}

inline double BiCubicInterpolator::interpolation(std::vector<double> x0)
{
	return interpolation(x0[0], x0[1]);
}

inline void BiCubicInterpolator::exportInterpolator(std::string filename)
{
	std::ofstream output(filename);

	//std::cout << x0.size() << ", " << x1.size() << ", " << x2.size() << ", " << x3.size() << ", " << x4.size() << std::endl;

	output << std::fixed << std::setprecision(20) << std::scientific << Double2Hex(x0[0]);
	for(int nx = 1; nx < x0.size(); nx ++)
	{
		output << std::fixed << std::setprecision(20) << std::scientific << ", " << Double2Hex(x0[nx]);
	}
	output << std::endl;
	output << std::fixed << std::setprecision(20) << std::scientific << Double2Hex(x1[0]);
	for(int nx = 1; nx < x1.size(); nx ++)
	{
		output << std::fixed << std::setprecision(20) << std::scientific << ", " << Double2Hex(x1[nx]);
	}
	output << std::endl;

	for(int nx0 = 0; nx0 < x0.size() - 1; nx0 ++)
	{
		for(int nx1 = 0; nx1 < x1.size() - 1; nx1 ++)
		{
			output << std::dec << nx0 << ", " << nx1 << std::flush;

			for(int i = 0; i < 4; i ++)
			{
				for(int j = 0; j < 4; j ++)
				{
					output << std::fixed << std::setprecision(20) << std::scientific << ", " << Double2Hex(interval[nx0][nx1].a[i][j]) << std::flush;
				}
			}

			output << std::endl << std::flush;
		}
	}

	return;
}

inline void BiCubicInterpolator::exportInterpolatorNetCDF(std::string filename)
{
	netCDF::NcFile outputFile(filename, netCDF::NcFile::replace);

	//netcdf
	//nx0, nx1, nintx0, nintx1, ncoef
	//x0(nx0), x1(nx1)
	//a(nintx0, nintx1, ncoef, ncoef)

	// 
	netCDF::NcDim dim_x0 = outputFile.addDim("x0", x0.size());
	netCDF::NcDim dim_x1 = outputFile.addDim("x1", x1.size());
	netCDF::NcDim dim_x0_int = outputFile.addDim("x0_interval", x0.size() - 1);
	netCDF::NcDim dim_x1_int = outputFile.addDim("x1_interval", x1.size() - 1);
	netCDF::NcDim dim_coef = outputFile.addDim("coefficient", 4);

	// 
	netCDF::NcVar var_x0 = outputFile.addVar("x0", netCDF::ncDouble, dim_x0);
	var_x0.setCompression(true, true, 5);
	var_x0.putAtt("long_name", "first dimension");
	var_x0.putVar(x0.data());
	netCDF::NcVar var_x1 = outputFile.addVar("x1", netCDF::ncDouble, dim_x1);
	var_x1.setCompression(true, true, 5);
	var_x1.putAtt("long_name", "second dimension");
	var_x1.putVar(x1.data());
	netCDF::NcVar var_coef = outputFile.addVar("coefficent", netCDF::ncDouble, {dim_x0_int, dim_x1_int, dim_coef, dim_coef});
	var_coef.setCompression(true, true, 5);
	var_coef.putAtt("long_name", "spline coefficient");
	var_coef.putAtt("discription", "a[i][j] * x0^i * x1^j");
	std::vector<double> flat_coef;
	for(int nx = 0; nx < x0.size() - 1; nx ++)
	{
		for(int ny = 0; ny < x1.size() - 1; ny ++)
		{
			for(int i = 0; i < 4; i ++)
			{
				for(int j = 0; j < 4; j ++)
				{
					flat_coef.push_back(interval[nx][ny].a[i][j]);
				}
			}
		}
	}
	var_coef.putVar(flat_coef.data());

	return;
}

inline void BiCubicInterpolator::importInterpolator(std::string filename)
{
	std::ifstream input(filename);

	std::string str;
	std::vector<double> x0in, x1in, x2in;
	
	{
		std::getline(input, str);
		if(str[0] != '#' && str.size() > 0)
		{
			auto data = spritString(str, ',');
			for(int i = 0; i < data.size(); i ++)
			{
				x0in.push_back(Hex2Double(data[i]));
			}
		}
		std::getline(input, str);
		if(str[0] != '#' && str.size() > 0)
		{
			auto data = spritString(str, ',');
			for(int i = 0; i < data.size(); i ++)
			{
				x1in.push_back(Hex2Double(data[i]));
			}
		}
	}

	x0 = x0in;
	x1 = x1in;

	interval = std::vector<std::vector<BiCubicSpline>>(x0.size() - 1, std::vector<BiCubicSpline>(x1.size() - 1));

	while(std::getline(input, str))
	{
		if(str[0] != '#' && str.size() > 0)
		{
			auto data = spritString(str, ',');
			
			int nx0 = std::stoi(data[0]);
			int nx1 = std::stoi(data[1]);

			interval[nx0][nx1].a = std::vector<std::vector<double>>(4, std::vector<double>(4));
			for(int i = 0; i < 4; i ++)
			{
				for(int j = 0; j < 4; j ++)
				{
					int idx = 2 + i * 4 + j;
					interval[nx0][nx1].a[i][j] = Hex2Double(data[idx]);
				}
			}
			interval[nx0][nx1].p = std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)));
			for(int i = 0; i < 2; i ++)
			{
				for(int j = 0; j < 2; j ++)
				{
					interval[nx0][nx1].p[i][j] = {x0[nx0 + i], x1[nx1 + j]};
				}
			}
		}
	}

	return;
}

inline void BiCubicInterpolator::initialization(void)
{
	f = std::vector<std::vector<double>>(x0.size(), std::vector<double>(x1.size()));

	return;
}

inline void BiCubicInterpolator::clear(void)
{
	f.clear();
	fx0.clear();
	fx1.clear();
	fx0x1.clear();

	interval.clear();
	A.clear();

	return;
}

inline void BiCubicInterpolator::clearData(void)
{
	f.clear();
	fx0.clear();
	fx1.clear();
	fx0x1.clear();

	for(int nx0 = 0; nx0 < interval.size(); nx0 ++)
	{
		for(int nx1 = 0; nx1 < interval[nx0].size(); nx1 ++)
		{
			interval[nx0][nx1].clearData();
		}
	}

	A.clear();

	return;
}

inline void BiCubicInterpolator::BiCubicSpline::clearData(void)
{
	f.clear();
	p.clear();
	fx0.clear();
	fx1.clear();
	fx0x1.clear();

	return;
}

/*
void BiCubicInterpolator::makeInterpolator(void)
{
	int Nx = x.size();
	int Ny = y.size();

	std::vector<Spline> spline_x(Ny);
	std::vector<Spline> spline_y(Nx);

	interval = std::vector<std::vector<BiCubicSpline>>(Nx - 1, std::vector<BiCubicSpline>(Ny - 1));

	//Makespline spline_x
	for(int ny = 0; ny < Ny; ny ++)
	{
		for(int nx = 0; nx < Nx; nx ++)
		{
			spline_x[ny].x.push_back(x[nx]);
			spline_x[ny].f.push_back(f[nx][ny]);
		}

		if(spline_type[0] == SPLINE_TYPE::NATURAL)
		{
			spline_x[ny].makeNaturalSpline();
		}
		else if(spline_type[0] == SPLINE_TYPE::CLAMPED)
		{
			spline_x[ny].makeClampedSpline();
		}
	}

	//Makespline spline_y
	for(int nx = 0; nx < Nx; nx ++)
	{
		for(int ny = 0; ny < Ny; ny ++)
		{
			spline_y[nx].x.push_back(y[ny]);
			spline_y[nx].f.push_back(f[nx][ny]);
		}

		if(spline_type[1] == SPLINE_TYPE::NATURAL)
		{
			spline_y[nx].makeNaturalSpline();
		}
		else if(spline_type[1] == SPLINE_TYPE::CLAMPED)
		{
			spline_y[nx].makeClampedSpline();
		}
	}

	fx = std::vector<std::vector<double>>(Nx, std::vector<double>(Ny));
	fy = std::vector<std::vector<double>>(Nx, std::vector<double>(Ny));

	for(int nx = 0; nx < Nx; nx ++)
	{
		for(int ny = 0; ny < Ny; ny ++)
		{
			if(nx != Nx - 1)
			{
				fx[nx][ny] = spline_x[ny].c[nx];
			}
			else
			{
				double Dx = x[Nx - 1] - x[Nx - 2];
				fx[nx][ny] = 3.0 * spline_x[ny].a[nx - 1] * Dx * Dx + 2.0 * spline_x[ny].b[nx - 1] * Dx + spline_x[ny].c[nx - 1];
			}

			if(ny != Ny - 1)
			{
				fy[nx][ny] = spline_y[nx].c[ny];
			}
			else
			{
				double Dy = y[Ny - 1] - y[Ny - 2];
				fy[nx][ny] = 3.0 * spline_y[nx].a[ny - 1] * Dy * Dy + 2.0 * spline_y[nx].b[ny - 1] * Dy + spline_y[nx].c[ny - 1];
			}
		}
	}
	
	std::vector<Spline> spline_dx_y(Nx);

	//MakeSpline spline_dx_y
	for(int nx = 0; nx < Nx; nx ++)
	{
		for(int ny = 0; ny < Ny; ny ++)
		{
			spline_dx_y[nx].x.push_back(y[ny]);
			spline_dx_y[nx].f.push_back(fx[nx][ny]);
		}
		
		if(spline_type[1] == SPLINE_TYPE::NATURAL)
		{
			spline_dx_y[nx].makeNaturalSpline();
		}
		else if(spline_type[1] == SPLINE_TYPE::CLAMPED)
		{
			spline_dx_y[nx].makeClampedSpline();
		}
	}

	fxy = std::vector<std::vector<double>>(Nx, std::vector<double>(Ny));

	for(int nx = 0; nx < Nx; nx ++)
	{
		for(int ny = 0; ny < Ny; ny ++)
		{
			if(ny != Ny - 1)
			{
				fxy[nx][ny] = spline_dx_y[nx].c[ny];
			}
			else
			{
				double Dy = y[Ny - 1] - y[Ny - 2];
				fxy[nx][ny] = 3.0 * spline_dx_y[nx].a[ny - 1] * Dy * Dy + 2.0 * spline_dx_y[nx].b[ny - 1] * Dy + spline_dx_y[nx].c[ny - 1];
			}
		}
	}
	
	for(int nx = 0; nx < Nx - 1; nx ++)
	{
		for(int ny = 0; ny < Ny - 1; ny ++)
		{
			interval[nx][ny].p = std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)));
			interval[nx][ny].f = std::vector<std::vector<double>>(2, std::vector<double>(2));
			interval[nx][ny].fx = std::vector<std::vector<double>>(2, std::vector<double>(2));
			interval[nx][ny].fy = std::vector<std::vector<double>>(2, std::vector<double>(2));
			interval[nx][ny].fxy = std::vector<std::vector<double>>(2, std::vector<double>(2));

			for(int i = 0; i < 2; i ++)
			{
				for(int j = 0; j < 2; j ++)
				{
					interval[nx][ny].p[i][j] = {x[nx + i], y[ny + j]};
					interval[nx][ny].f[i][j] = f[nx + i][ny + j];
					interval[nx][ny].fx[i][j] = fx[nx + i][ny + j];
					interval[nx][ny].fy[i][j] = fy[nx + i][ny + j];
					interval[nx][ny].fxy[i][j] = fxy[nx + i][ny + j];
				}
			}
		}
	}

	if(regular_grid == true)
	{
		A = std::vector<std::vector<double>>(16, std::vector<double>(16));
		double Dx = x[1] - x[0];
		double Dy = y[1] - y[0];

		auto pow = [](double v1, int v2)
		{
			if(v1 == 0 && v2 == 0)
			{
				return 1.0;
			}
			else if(v1 == 0)
			{
				return 0.0;
			}
			else if(v2 == 0)
			{
				return 1.0;
			}
			else
			{
				return std::pow(v1, double(v2));
			}
		};

		for(int m = 0; m < 2; m ++)
		{
			double dy = Dy * (double(m));

			for(int l = 0; l < 2; l ++)
			{
				double dx = Dx * (double(l));
				int row = 2 * m + l;

				for(int j = 0; j < 4; j ++)
				{
					for(int i = 0; i < 4; i ++)
					{
						int col = 4 * j + i;
						A[row][col] = pow(dx, i) * pow(dy, j);
					}
				}
			}
		}
		
		for(int m = 0; m < 2; m ++)
		{
			double dy = Dy * (double(m));

			for(int l = 0; l < 2; l ++)
			{
				double dx = Dx * (double(l));
				int row = 2 * m + l + 4;

				for(int j = 0; j < 4; j ++)
				{
					for(int i = 0; i < 4; i ++)
					{
						int col = 4 * j + i;
						A[row][col] = double(i) * pow(dx, i - 1) * pow(dy, j);
					}
				}
			}
		}
		
		for(int m = 0; m < 2; m ++)
		{
			double dy = Dy * (double(m));

			for(int l = 0; l < 2; l ++)
			{
				double dx = Dx * (double(l));
				int row = 2 * m + l + 8;

				for(int j = 0; j < 4; j ++)
				{
					for(int i = 0; i < 4; i ++)
					{
						int col = 4 * j + i;
						A[row][col] = double(j) * pow(dx, i) * pow(dy, j - 1);
					}
				}
			}
		}

		for(int m = 0; m < 2; m ++)
		{
			double dy = Dy * (double(m));

			for(int l = 0; l < 2; l ++)
			{
				double dx = Dx * (double(l));
				int row = 2 * m + l + 12;

				for(int j = 0; j < 4; j ++)
				{
					for(int i = 0; i < 4; i ++)
					{
						int col = 4 * j + i;
						A[row][col] = double(i) * double(j) * pow(dx, i - 1) * pow(dy, j - 1);
					}
				}
			}
		}

		invertMatrix(A);
	}

	for(int nx = 0; nx < Nx - 1; nx ++)
	{
		for(int ny = 0; ny < Ny - 1; ny ++)
		{
			if(regular_grid == false)
			{
				interval[nx][ny].makeInterpolator();
			}
			else if(regular_grid == true)
			{
				interval[nx][ny].makeInterpolator(A);
			}
		}
	}
	
	return;
}

double BiCubicInterpolator::interpolation(double x0, double y0)
{
	double result = 0.0;

	int nx = 0;
	int ny = 0;

	for(int i = 0; i < x.size() - 1; i ++)
	{
		if(x[i] <= x0 && x0 <= x[i + 1])
		{
			nx = i;
			break;
		}
	}

	for(int i = 0; i < y.size() - 1; i ++)
	{
		if(y[i] <= y0 && y0 <= y[i + 1])
		{
			ny = i;
			break;
		}
	}

	result = interval[nx][ny].interpolation(x0, y0);

	return result;
}

void BiCubicInterpolator::BiCubicSpline::makeInterpolator(void)
{
	std::vector<std::vector<double>> A = std::vector<std::vector<double>>(16, std::vector<double>(16));

	Dx = p[1][0][0] - p[0][0][0];
	Dy = p[0][1][1] - p[0][0][1];

	std::vector<double> rhs(16);

	auto pow = [](double v1, int v2)
	{
		if(v1 == 0 && v2 == 0)
		{
			return 1.0;
		}
		else if(v1 == 0)
		{
			return 0.0;
		}
		else if(v2 == 0)
		{
			return 1.0;
		}
		else
		{
			return std::pow(v1, double(v2));
		}
	};

	for(int m = 0; m < 2; m ++)
	{
		double dy = Dy * (double(m));

		for(int l = 0; l < 2; l ++)
		{
			double dx = Dx * (double(l));
			int row = 2 * m + l;
			rhs[row] = f[l][m];

			for(int j = 0; j < 4; j ++)
			{
				for(int i = 0; i < 4; i ++)
				{
					int col = 4 * j + i;
					A[row][col] = pow(dx, i) * pow(dy, j);
				}
			}
		}
	}
	
	for(int m = 0; m < 2; m ++)
	{
		double dy = Dy * (double(m));

		for(int l = 0; l < 2; l ++)
		{
			double dx = Dx * (double(l));
			int row = 2 * m + l + 4;
			rhs[row] = fx[l][m];

			for(int j = 0; j < 4; j ++)
			{
				for(int i = 0; i < 4; i ++)
				{
					int col = 4 * j + i;
					A[row][col] = double(i) * pow(dx, i - 1) * pow(dy, j);
				}
			}
		}
	}
	
	for(int m = 0; m < 2; m ++)
	{
		double dy = Dy * (double(m));

		for(int l = 0; l < 2; l ++)
		{
			double dx = Dx * (double(l));
			int row = 2 * m + l + 8;
			rhs[row] = fy[l][m];

			for(int j = 0; j < 4; j ++)
			{
				for(int i = 0; i < 4; i ++)
				{
					int col = 4 * j + i;
					A[row][col] = double(j) * pow(dx, i) * pow(dy, j - 1);
				}
			}
		}
	}

	for(int m = 0; m < 2; m ++)
	{
		double dy = Dy * (double(m));

		for(int l = 0; l < 2; l ++)
		{
			double dx = Dx * (double(l));
			int row = 2 * m + l + 12;
			rhs[row] = fxy[l][m];

			for(int j = 0; j < 4; j ++)
			{
				for(int i = 0; i < 4; i ++)
				{
					int col = 4 * j + i;
					A[row][col] = double(i) * double(j) * pow(dx, i - 1) * pow(dy, j - 1);
				}
			}
		}
	}

	// A[0] = {1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
	// A[1] = {1.0, Dx, Dx*Dx, Dx*Dx*Dx, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
	// A[2] = {1.0, 0.0, 0.0, 0.0, Dy, 0.0, 0.0, 0.0, Dy*Dy, 0.0, 0.0, 0.0, Dy*Dy*Dy, 0.0, 0.0, 0.0};
	// A[3] = {1.0, Dx, Dx*Dx, Dx*Dx*Dx, Dy, Dx*Dy, Dx*Dx*Dy, Dx*Dx*Dx*Dy, Dy*Dy, Dx*Dy*Dy, Dx*Dx*Dy*Dy, Dx*Dx*Dx*Dy*Dy, Dy*Dy*Dy, Dx*Dy*Dy*Dy, Dx*Dx*Dy*Dy*Dy, Dx*Dx*Dx*Dy*Dy*Dy};
	// A[4] = {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
	// A[5] = {0.0, 1.0, 2.0*Dx, 3.0*Dx*Dx, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
	// A[6] = {0.0, 1.0, 0.0, 0.0, 0.0, Dy, 0.0, 0.0, 0.0, Dy*Dy, 0.0, 0.0, 0.0, Dy*Dy*Dy, 0.0, 0.0};
	// A[7] = {0.0, 1.0, 2.0*Dx, 3.0*Dx*Dx, 0.0, Dy, 2.0*Dx*Dy, 3.0*Dx*Dx*Dy, 0.0, Dy*Dy, 2.0*Dx*Dy*Dy, 3.0*Dx*Dx*Dy*Dy, 0.0, Dy*Dy*Dy, 2.0*Dx*Dy*Dy*Dy, 3.0*Dx*Dx*Dy*Dy*Dy};
	// A[8] = {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
	// A[9] = {0.0, 0.0, 0.0, 0.0, 1.0, Dx, Dx*Dx, Dx*Dx*Dx, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
	// A[10] = {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 2.0*Dy, 0.0, 0.0, 0.0, 3.0*Dy*Dy, 0.0, 0.0, 0.0};
	// A[11] = {0.0, 0.0, 0.0, 0.0, 1.0, Dx, Dx*Dx, Dx*Dx*Dx, 2.0*Dy, 2.0*Dx*Dy, 2.0*Dx*Dx*Dy, 2.0*Dx*Dx*Dx*Dy, 3.0*Dy*Dy, 3.0*Dx*Dy*Dy, 3.0*Dx*Dx*Dy*Dy, 3.0*Dx*Dx*Dx*Dy*Dy};
	// A[12] = {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
	// A[13] = {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 2.0*Dx, 3.0*Dx*Dx, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
	// A[14] = {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 2.0*Dy, 0.0, 0.0, 0.0, 3.0*Dy*Dy, 0.0, 0.0};
	// A[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 2.0*Dx, 3.0*Dx*Dx, 0.0, 2.0*Dy, 4.0*Dx*Dy, 6.0*Dx*Dx*Dy, 0.0, 3.0*Dy*Dy, 6.0*Dx*Dy*Dy, 9.0*Dx*Dx*Dy*Dy};

	//std::vector<double> rhs = {f[0], f[1], f[3], f[2], fx[0], fx[1], fx[3], fx[2], fy[0], fy[1], fy[3], fy[2], fxy[0], fxy[1], fxy[3], fxy[2]};

	for(int i = 0; i < 16; i ++)
	{
		//std::cout << A[i][0];
		for(int j = 1; j < 16; j ++)
		{
			//std::cout << " " << A[i][j];
		}
		//std::cout << std::endl;
	}

	invertMatrix(A, rhs);

	a = std::vector<std::vector<double>>(4, std::vector<double>(4));

	for(int j = 0; j < 4; j ++)
	{
		for(int i = 0; i < 4; i ++)
		{
			int idx = i + 4 * j;
			a[i][j] = rhs[idx];
		}
	}

	// for(int i = 0; i < 4; i ++)
	// {
	// 	for(int j = 0; j < 4; j ++)
	// 	{
	// 		a[i][j] = rhs[i + j * 4];
	// 		//std::cout << i << j << ", " << i + j * 4 << std::endl;
	// 	}
	// }
	
	return;
}

void BiCubicInterpolator::BiCubicSpline::makeInterpolator(std::vector<std::vector<double>> A)
{
	std::vector<double> rhs(16);
	std::vector<double> ans(16);

	int row;

	for(int m = 0; m < 2; m ++)
	{
		for(int l = 0; l < 2; l ++)
		{
			row = 2 * m + l;
			rhs[row] = f[l][m];
			row = 2 * m + l + 4;
			rhs[row] = fx[l][m];
			row = 2 * m + l + 8;
			rhs[row] = fy[l][m];
			row = 2 * m + l + 12;
			rhs[row] = fxy[l][m];
		}
	}

	#pragma omp parallel for
	for(int i = 0; i < rhs.size(); i ++)
	{
		ans[i] = 0.0;
		for(int j = 0; j < rhs.size(); j ++)
		{
			ans[i] += A[i][j] * rhs[j];
		}
	}

	a = std::vector<std::vector<double>>(4, std::vector<double>(4));

	for(int j = 0; j < 4; j ++)
	{
		for(int i = 0; i < 4; i ++)
		{
			int idx = i + 4 * j;
			a[i][j] = ans[idx];
		}
	}
	
	return;
}

double BiCubicInterpolator::BiCubicSpline::interpolation(double x0, double y0)
{
	//f, fx, fy, fxy
	double result = 0.0;

	//double Dx = p[1][0] - p[0][0];
	//double Dy = p[3][1] - p[0][1];

	//double dx = (x - p[0][0]) / Dx;
	//double dy = (y - p[0][1]) / Dy;

	double dx = x0 - p[0][0][0];
	double dy = y0 - p[0][0][1];

	auto pow = [](double v1, int v2)
	{
		if(v1 == 0 && v2 == 0)
		{
			return 1.0;
		}
		else if(v1 == 0)
		{
			return 0.0;
		}
		else if(v2 == 0)
		{
			return 1.0;
		}
		else
		{
			return std::pow(v1, double(v2));
		}
    };

	for(int i = 0; i < 4; i ++)
	{
		for(int j = 0; j < 4; j ++)
		{
			result += a[i][j] * pow(dx, i) * pow(dy, j);
		}
	}

	return result;
}
*/

inline void TriCubicInterpolator::makeInterpolator(void)
{
	int Nx0 = x0.size();
	int Nx1 = x1.size();
	int Nx2 = x2.size();

	std::vector<std::vector<Spline>> spline_x0 = std::vector<std::vector<Spline>>(Nx1, std::vector<Spline>(Nx2));
	std::vector<std::vector<Spline>> spline_x1 = std::vector<std::vector<Spline>>(Nx0, std::vector<Spline>(Nx2));
	std::vector<std::vector<Spline>> spline_x2 = std::vector<std::vector<Spline>>(Nx0, std::vector<Spline>(Nx1));

	//std::cout << "MakeSpline spline_x0" << std::endl;
	//#pragma omp parallel for
	for(int nx1 = 0; nx1 < Nx1; nx1 ++)
	{
		for(int nx2 = 0; nx2 < Nx2; nx2 ++)
		{
			for(int nx0 = 0; nx0 < Nx0; nx0 ++)
			{
				spline_x0[nx1][nx2].x.push_back(x0[nx0]);
				spline_x0[nx1][nx2].f.push_back(f[nx0][nx1][nx2]);
			}
			if(spline_type[0] == SPLINE_TYPE::NATURAL)
			{
				spline_x0[nx1][nx2].makeNaturalSpline();
			}
			else if(spline_type[0] == SPLINE_TYPE::CLAMPED)
			{
				spline_x0[nx1][nx2].makeClampedSpline();
			}
			else if(spline_type[0] == SPLINE_TYPE::NATURAL_CLAMPED)
			{
				spline_x0[nx1][nx2].makeNaturalClampedSpline();
			}
			else if(spline_type[0] == SPLINE_TYPE::CLAMPED_NATURAL)
			{
				spline_x0[nx1][nx2].makeClampedNaturalSpline();
			}
		}
	}

	//MakeSpline spline_x1
	//std::cout << "MakeSpline spline_x1" << std::endl;
	//#pragma omp parallel for
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx2 = 0; nx2 < Nx2; nx2 ++)
		{
			for(int nx1 = 0; nx1 < Nx1; nx1 ++)
			{
				spline_x1[nx0][nx2].x.push_back(x1[nx1]);
				spline_x1[nx0][nx2].f.push_back(f[nx0][nx1][nx2]);
			}
			if(spline_type[1] == SPLINE_TYPE::NATURAL)
			{
				spline_x1[nx0][nx2].makeNaturalSpline();
			}
			else if(spline_type[1] == SPLINE_TYPE::CLAMPED)
			{
				spline_x1[nx0][nx2].makeClampedSpline();
			}
			else if(spline_type[1] == SPLINE_TYPE::NATURAL_CLAMPED)
			{
				spline_x1[nx0][nx2].makeNaturalClampedSpline();
			}
			else if(spline_type[1] == SPLINE_TYPE::CLAMPED_NATURAL)
			{
				spline_x1[nx0][nx2].makeClampedNaturalSpline();
			}
		}
	}

	//MakeSpline spline_x2
	//std::cout << "MakeSpline spline_x2" << std::endl;
	//#pragma omp parallel for
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				spline_x2[nx0][nx1].x.push_back(x2[nx2]);
				spline_x2[nx0][nx1].f.push_back(f[nx0][nx1][nx2]);
			}
			if(spline_type[2] == SPLINE_TYPE::NATURAL)
			{
				spline_x2[nx0][nx1].makeNaturalSpline();
			}
			else if(spline_type[2] == SPLINE_TYPE::CLAMPED)
			{
				spline_x2[nx0][nx1].makeClampedSpline();
			}
			else if(spline_type[2] == SPLINE_TYPE::NATURAL_CLAMPED)
			{
				spline_x2[nx0][nx1].makeNaturalClampedSpline();
			}
			else if(spline_type[2] == SPLINE_TYPE::CLAMPED_NATURAL)
			{
				spline_x2[nx0][nx1].makeClampedNaturalSpline();
			}
		}
	}

	//Derive fx0, fx1, fx2
	fx0 = std::vector<std::vector<std::vector<double>>>(Nx0, std::vector<std::vector<double>>(Nx1, std::vector<double>(Nx2)));
	fx1 = std::vector<std::vector<std::vector<double>>>(Nx0, std::vector<std::vector<double>>(Nx1, std::vector<double>(Nx2)));
	fx2 = std::vector<std::vector<std::vector<double>>>(Nx0, std::vector<std::vector<double>>(Nx1, std::vector<double>(Nx2)));

	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				if(nx0 != Nx0 - 1)
				{
					fx0[nx0][nx1][nx2] = spline_x0[nx1][nx2].c[nx0];
				}
				else
				{
					double Dx0 = x0[Nx0 - 1] - x0[Nx0 - 2];
					fx0[nx0][nx1][nx2] = 3.0 * spline_x0[nx1][nx2].a[nx0 - 1] * Dx0 * Dx0 + 2.0 * spline_x0[nx1][nx2].b[nx0 - 1] * Dx0 + spline_x0[nx1][nx2].c[nx0 - 1];
				}

				if(nx1 != Nx1 - 1)
				{
					fx1[nx0][nx1][nx2] = spline_x1[nx0][nx2].c[nx1];
				}
				else
				{
					double Dx1 = x1[Nx1 - 1] - x1[Nx1 - 2];
					fx1[nx0][nx1][nx2] = 3.0 * spline_x1[nx0][nx2].a[nx1 - 1] * Dx1 * Dx1 + 2.0 * spline_x1[nx0][nx2].b[nx1 - 1] * Dx1 + spline_x1[nx0][nx2].c[nx1 - 1];
				}

				if(nx2 != Nx2 - 1)
				{
					fx2[nx0][nx1][nx2] = spline_x2[nx0][nx1].c[nx2];
				}
				else
				{
					double Dx2 = x2[Nx2 - 1] - x2[Nx2 - 2];
					fx2[nx0][nx1][nx2] = 3.0 * spline_x2[nx0][nx1].a[nx2 - 1] * Dx2 * Dx2 + 2.0 * spline_x2[nx0][nx1].b[nx2 - 1] * Dx2 + spline_x2[nx0][nx1].c[nx2 - 1];
				}
			}
		}
	}

	std::vector<std::vector<Spline>> spline_dx0_x1 = std::vector<std::vector<Spline>>(Nx0, std::vector<Spline>(Nx2));	// for fx0x1
	std::vector<std::vector<Spline>> spline_dx0_x2 = std::vector<std::vector<Spline>>(Nx0, std::vector<Spline>(Nx1));	// for fx0x2
	std::vector<std::vector<Spline>> spline_dx1_x2 = std::vector<std::vector<Spline>>(Nx0, std::vector<Spline>(Nx1));	// for fx1x2

	//MakeSpline spline_dx0_x1
	//std::cout << "MakeSpline spline_dx0_x1" << std::endl;
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx2 = 0; nx2 < Nx2; nx2 ++)
		{
			for(int nx1 = 0; nx1 < Nx1; nx1 ++)
			{
				spline_dx0_x1[nx0][nx2].x.push_back(x1[nx1]);
				spline_dx0_x1[nx0][nx2].f.push_back(fx0[nx0][nx1][nx2]);
			}

			if(spline_type[1] == SPLINE_TYPE::NATURAL)
			{
				spline_dx0_x1[nx0][nx2].makeNaturalSpline();
			}
			else if(spline_type[1] == SPLINE_TYPE::CLAMPED)
			{
				spline_dx0_x1[nx0][nx2].makeClampedSpline();
			}
			else if(spline_type[1] == SPLINE_TYPE::NATURAL_CLAMPED)
			{
				spline_dx0_x1[nx0][nx2].makeNaturalClampedSpline();
			}
			else if(spline_type[1] == SPLINE_TYPE::CLAMPED_NATURAL)
			{
				spline_dx0_x1[nx0][nx2].makeClampedNaturalSpline();
			}
		}
	}
	
	//MakeSpline spline_dx0_x2
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				spline_dx0_x2[nx0][nx1].x.push_back(x2[nx2]);
				spline_dx0_x2[nx0][nx1].f.push_back(fx0[nx0][nx1][nx2]);
			}

			if(spline_type[2] == SPLINE_TYPE::NATURAL)
			{
				spline_dx0_x2[nx0][nx1].makeNaturalSpline();
			}
			else if(spline_type[2] == SPLINE_TYPE::CLAMPED)
			{
				spline_dx0_x2[nx0][nx1].makeClampedSpline();
			}
			else if(spline_type[2] == SPLINE_TYPE::NATURAL_CLAMPED)
			{
				spline_dx0_x2[nx0][nx1].makeNaturalClampedSpline();
			}
			else if(spline_type[2] == SPLINE_TYPE::CLAMPED_NATURAL)
			{
				spline_dx0_x2[nx0][nx1].makeClampedNaturalSpline();
			}
		}
	}

	//MakeSpline spline_dx1_x2
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				spline_dx1_x2[nx0][nx1].x.push_back(x2[nx2]);
				spline_dx1_x2[nx0][nx1].f.push_back(fx1[nx0][nx1][nx2]);
			}

			if(spline_type[2] == SPLINE_TYPE::NATURAL)
			{
				spline_dx1_x2[nx0][nx1].makeNaturalSpline();
			}
			else if(spline_type[2] == SPLINE_TYPE::CLAMPED)
			{
				spline_dx1_x2[nx0][nx1].makeClampedSpline();
			}
			else if(spline_type[2] == SPLINE_TYPE::NATURAL_CLAMPED)
			{
				spline_dx1_x2[nx0][nx1].makeNaturalClampedSpline();
			}
			else if(spline_type[2] == SPLINE_TYPE::CLAMPED_NATURAL)
			{
				spline_dx1_x2[nx0][nx1].makeClampedNaturalSpline();
			}
		}
	}

	fx0x1 = std::vector<std::vector<std::vector<double>>>(Nx0, std::vector<std::vector<double>>(Nx1, std::vector<double>(Nx2)));
	fx0x2 = std::vector<std::vector<std::vector<double>>>(Nx0, std::vector<std::vector<double>>(Nx1, std::vector<double>(Nx2)));
	fx1x2 = std::vector<std::vector<std::vector<double>>>(Nx0, std::vector<std::vector<double>>(Nx1, std::vector<double>(Nx2)));
	
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				if(nx1 != Nx1 - 1)
				{
					fx0x1[nx0][nx1][nx2] = spline_dx0_x1[nx0][nx2].c[nx1];
				}
				else
				{
					double Dx1 = x1[Nx1 - 1] - x1[Nx1 - 2];
					fx0x1[nx0][nx1][nx2] = 3.0 * spline_dx0_x1[nx0][nx2].a[nx1 - 1] * Dx1 * Dx1 + 2.0 * spline_dx0_x1[nx0][nx2].b[nx1 - 1] * Dx1 + spline_dx0_x1[nx0][nx2].c[nx1 - 1];
				}

				if(nx2 != Nx2 - 1)
				{
					fx0x2[nx0][nx1][nx2] = spline_dx0_x2[nx0][nx1].c[nx2];
				}
				else
				{
					double Dx2 = x2[Nx2 - 1] - x2[Nx2 - 2];
					fx0x2[nx0][nx1][nx2] = 3.0 * spline_dx0_x2[nx0][nx1].a[nx2 - 1] * Dx2 * Dx2 + 2.0 * spline_dx0_x2[nx0][nx1].b[nx2 - 1] * Dx2 + spline_dx0_x2[nx0][nx1].c[nx2 - 1];
				}

				if(nx2 != Nx2 - 1)
				{
					fx1x2[nx0][nx1][nx2] = spline_dx1_x2[nx0][nx1].c[nx2];
				}
				else
				{
					double Dx2 = x2[Nx2 - 1] - x2[Nx2 - 2];
					fx1x2[nx0][nx1][nx2] = 3.0 * spline_dx1_x2[nx0][nx1].a[nx2 - 1] * Dx2 * Dx2 + 2.0 * spline_dx1_x2[nx0][nx1].b[nx2 - 1] * Dx2 + spline_dx1_x2[nx0][nx1].c[nx2 - 1];
				}
			}
		}
	}

	std::vector<std::vector<Spline>> spline_dx0dx1_x2 = std::vector<std::vector<Spline>>(Nx0, std::vector<Spline>(Nx1));	// for fx0x1x2

	//MakeSpline spline_dx0dx1_x2
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				spline_dx0dx1_x2[nx0][nx1].x.push_back(x2[nx2]);
				spline_dx0dx1_x2[nx0][nx1].f.push_back(fx0x1[nx0][nx1][nx2]);
			}

			if(spline_type[2] == SPLINE_TYPE::NATURAL)
			{
				spline_dx0dx1_x2[nx0][nx1].makeNaturalSpline();
			}
			else if(spline_type[2] == SPLINE_TYPE::CLAMPED)
			{
				spline_dx0dx1_x2[nx0][nx1].makeClampedSpline();
			}
			else if(spline_type[2] == SPLINE_TYPE::NATURAL_CLAMPED)
			{
				spline_dx0dx1_x2[nx0][nx1].makeNaturalClampedSpline();
			}
			else if(spline_type[2] == SPLINE_TYPE::CLAMPED_NATURAL)
			{
				spline_dx0dx1_x2[nx0][nx1].makeClampedNaturalSpline();
			}
		}
	}

	fx0x1x2 = std::vector<std::vector<std::vector<double>>>(Nx0, std::vector<std::vector<double>>(Nx1, std::vector<double>(Nx2)));

	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				if(nx2 != Nx2 - 1)
				{
					fx0x1x2[nx0][nx1][nx2] = spline_dx0dx1_x2[nx0][nx1].c[nx2];
				}
				else
				{
					double Dx2 = x2[Nx2 - 1] - x2[Nx2 - 2];
					fx0x1x2[nx0][nx1][nx2] = 3.0 * spline_dx0dx1_x2[nx0][nx1].a[nx2 - 1] * Dx2 * Dx2 + 2.0 * spline_dx0dx1_x2[nx0][nx1].b[nx2 - 1] * Dx2 + spline_dx0dx1_x2[nx0][nx1].c[nx2 - 1];
				}
			}
		}
	}

	interval = std::vector<std::vector<std::vector<TriCubicSpline>>>(Nx0 - 1, std::vector<std::vector<TriCubicSpline>>(Nx1 - 1, std::vector<TriCubicSpline>(Nx2 - 1)));

	if(regular_grid == true)
	{
		A = std::vector<std::vector<double>>(64, std::vector<double>(64));
		double Dx0 = x0[1] - x0[0];
		double Dx1 = x1[1] - x1[0];
		double Dx2 = x2[1] - x2[0];

		auto pow = [](double v1, int v2)
		{
			if(v1 == 0 && v2 == 0)
			{
				return 1.0;
			}
			else if(v1 == 0)
			{
				return 0.0;
			}
			else if(v2 == 0)
			{
				return 1.0;
			}
			else
			{
				return std::pow(v1, double(v2));
			}
		};

		//std::cout << "inverting" << std::endl << std::flush;
		//#pragma omp parallel for
		for(int nx2 = 0; nx2 < 2; nx2 ++)
		{
			double dx2 = Dx2 * (double(nx2));
			
			for(int nx1 = 0; nx1 < 2; nx1 ++)
			{
				double dx1 = Dx1 * (double(nx1));

				for(int nx0 = 0; nx0 < 2; nx0 ++)
				{
					double dx0 = Dx0 * (double(nx0));

					int row = nx2 * 4 + nx1 * 2 + nx0;

					for(int k = 0; k < 4; k ++)
					{
						for(int j = 0; j < 4; j ++)
						{
							for(int i = 0; i < 4; i ++)
							{
								int col = k * 16 + j * 4 + i;

								//f
								A[row][col] = pow(dx0, i) * pow(dx1, j) * pow(dx2, k);

								//fx
								if(i == 0)
								{
									A[row + 8 * 1][col] = 0.0;
								}
								else
								{
									A[row + 8 * 1][col] = double(i) * pow(dx0, i - 1) * pow(dx1, j) * pow(dx2, k);
								}

								if(j == 0)
								{
									A[row + 8 * 2][col] = 0.0;
								}
								else
								{
									A[row + 8 * 2][col] = double(j) * pow(dx0, i) * pow(dx1, j - 1) * pow(dx2, k);
								}

								if(k == 0)
								{
									A[row + 8 * 3][col] = 0.0;
								}
								else
								{
									A[row + 8 * 3][col] = double(k) * pow(dx0, i) * pow(dx1, j) * pow(dx2, k - 1);
								}

								//fxx
								if(i == 0 || j == 0)
								{
									A[row + 8 * 4][col] = 0.0;
								}
								else
								{
									A[row + 8 * 4][col] = double(i) * double(j) * pow(dx0, i - 1) * pow(dx1, j - 1) * pow(dx2, k);
								}

								if(i == 0 || k == 0)
								{
									A[row + 8 * 5][col] = 0.0;
								}
								else
								{
									A[row + 8 * 5][col] = double(i) * double(k) * pow(dx0, i - 1) * pow(dx1, j) * pow(dx2, k - 1);
								}

								if(j == 0 || k == 0)
								{
									A[row + 8 * 6][col] = 0.0;
								}
								else
								{
									A[row + 8 * 6][col] = double(j) * double(k) * pow(dx0, i) * pow(dx1, j - 1) * pow(dx2, k - 1);
								}

								//fxxx
								if(i == 0 || j == 0 || k == 0)
								{
									A[row + 8 * 7][col] = 0.0;
								}
								else
								{
									A[row + 8 * 7][col] = double(i) * double(j) * double(k) * pow(dx0, i - 1) * pow(dx1, j - 1) * pow(dx2, k - 1);
								}
							}
						}
					}
				}
			}
		}

		invertMatrix(A);
	}

	for(int nx0 = 0; nx0 < Nx0 - 1; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1 - 1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2 - 1; nx2 ++)
			{
				//std::cout << nx0 << ", " << nx1 << ", " << nx2 << std::endl << std::flush;

				interval[nx0][nx1][nx2].p = std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(3))));
				interval[nx0][nx1][nx2].f = std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)));
				interval[nx0][nx1][nx2].fx0 = std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)));
				interval[nx0][nx1][nx2].fx1 = std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)));
				interval[nx0][nx1][nx2].fx2 = std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)));
				interval[nx0][nx1][nx2].fx0x1 = std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)));
				interval[nx0][nx1][nx2].fx0x2 = std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)));
				interval[nx0][nx1][nx2].fx1x2 = std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)));
				interval[nx0][nx1][nx2].fx0x1x2 = std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)));
				
				for(int i = 0; i < 2; i ++)
				{
					for(int j = 0; j < 2; j ++)
					{
						for(int k = 0; k < 2; k ++)
						{
							interval[nx0][nx1][nx2].p[i][j][k] = {x0[nx0 + i], x1[nx1 + j], x2[nx2 + k]};
							interval[nx0][nx1][nx2].f[i][j][k] = f[nx0 + i][nx1 + j][nx2 + k];
							interval[nx0][nx1][nx2].fx0[i][j][k] = fx0[nx0 + i][nx1 + j][nx2 + k];
							interval[nx0][nx1][nx2].fx1[i][j][k] = fx1[nx0 + i][nx1 + j][nx2 + k];
							interval[nx0][nx1][nx2].fx2[i][j][k] = fx2[nx0 + i][nx1 + j][nx2 + k];
							interval[nx0][nx1][nx2].fx0x1[i][j][k] = fx0x1[nx0 + i][nx1 + j][nx2 + k];
							interval[nx0][nx1][nx2].fx0x2[i][j][k] = fx0x2[nx0 + i][nx1 + j][nx2 + k];
							interval[nx0][nx1][nx2].fx1x2[i][j][k] = fx1x2[nx0 + i][nx1 + j][nx2 + k];
							interval[nx0][nx1][nx2].fx0x1x2[i][j][k] = fx0x1x2[nx0 + i][nx1 + j][nx2 + k];
						}
					}
				}

				if(regular_grid == false)
				{
					interval[nx0][nx1][nx2].makeInterpolator();
				}
				else if(regular_grid == true)
				{
					interval[nx0][nx1][nx2].makeInterpolator(A);
				}

				interval[nx0][nx1][nx2].clearData();
			}
		}
	}

	clearData();

	return;
}

inline void TriCubicInterpolator::TriCubicSpline::makeInterpolator(std::vector<std::vector<double>>& A)
{
	std::vector<double> rhs(64);
	std::vector<double> ans(64);

	int row;

	for(int nx2 = 0; nx2 < 2; nx2 ++)
	{
		for(int nx1 = 0; nx1 < 2; nx1 ++)
		{
			for(int nx0 = 0; nx0 < 2; nx0 ++)
			{
				row = nx2 * 4 + nx1 * 2 + nx0;
				rhs[row] = f[nx0][nx1][nx2];
				rhs[row + 8 * 1] = fx0[nx0][nx1][nx2];
				rhs[row + 8 * 2] = fx1[nx0][nx1][nx2];
				rhs[row + 8 * 3] = fx2[nx0][nx1][nx2];
				rhs[row + 8 * 4] = fx0x1[nx0][nx1][nx2];
				rhs[row + 8 * 5] = fx0x2[nx0][nx1][nx2];
				rhs[row + 8 * 6] = fx1x2[nx0][nx1][nx2];
				rhs[row + 8 * 7] = fx0x1x2[nx0][nx1][nx2];
			}
		}
	}

	#pragma omp parallel for
	for(int i = 0; i < rhs.size(); i ++)
	{
		ans[i] = 0.0;
		for(int j = 0; j < rhs.size(); j ++)
		{
			ans[i] += A[i][j] * rhs[j];
		}
	}

	a = std::vector<std::vector<std::vector<double>>>(4, std::vector<std::vector<double>>(4, std::vector<double>(4)));

	for(int nx2 = 0; nx2 < 4; nx2 ++)
	{
		for(int nx1 = 0; nx1 < 4; nx1 ++)
		{
			for(int nx0 = 0; nx0 < 4; nx0 ++)
			{
				int idx = nx2 * 16 + nx1 * 4 + nx0;
				a[nx0][nx1][nx2] = ans[idx];
			}
		}
	}

	return;
}

inline double TriCubicInterpolator::TriCubicSpline::interpolation(double dx0, double dx1, double dx2)
{
	double result = 0.0;

	//std::cout << x00 << ", " << x10 << ", " << x20 << ", " << x30 << ", " << x40 << std::flush;

	//std::cout << a[0][0][0] << ", " << dx0 << ", " << pow(dx0, 0) << ", " << dx1 << ", " << pow(dx1, 0) << ", " << dx2 << ", " << pow(dx2, 0) << std::endl << std::flush;

	auto pow = [](double v1, int v2)
	{
		if(v1 == 0 && v2 == 0)
		{
			return 1.0;
		}
		else if(v1 == 0)
		{
			return 0.0;
		}
		else if(v2 == 0)
		{
			return 1.0;
		}
		else
		{
			return std::pow(v1, double(v2));
		}
    };

	for(int i = 0; i < 4; i ++)
	{
		for(int j = 0; j < 4; j ++)
		{
			for(int k = 0; k < 4; k ++)
			{
				result += a[i][j][k] * pow(dx0, i) * pow(dx1, j) * pow(dx2, k);
			}
		}
	}

	return result;
}

inline void TriCubicInterpolator::TriCubicSpline::makeInterpolator(void)
{
	std::vector<std::vector<double>> A = std::vector<std::vector<double>>(64, std::vector<double>(64));

	Dx0 = p[1][0][0][0] - p[0][0][0][0];
	Dx1 = p[0][1][0][1] - p[0][0][0][1];
	Dx2 = p[0][0][1][2] - p[0][0][0][2];

	std::vector<double> rhs(64);

	auto pow = [](double v1, int v2)
	{
		if(v1 == 0 && v2 == 0)
		{
			return 1.0;
		}
		else if(v1 == 0)
		{
			return 0.0;
		}
		else if(v2 == 0)
		{
			return 1.0;
		}
		else
		{
			return std::pow(v1, double(v2));
		}
	};

	int row;

	for(int nx2 = 0; nx2 < 2; nx2 ++)
	{
		double dx2 = Dx2 * (double(nx2));
		
		for(int nx1 = 0; nx1 < 2; nx1 ++)
		{
			double dx1 = Dx1 * (double(nx1));

			for(int nx0 = 0; nx0 < 2; nx0 ++)
			{
				double dx0 = Dx0 * (double(nx0));

				int row = nx2 * 4 + nx1 * 2 + nx0;

				for(int k = 0; k < 4; k ++)
				{
					for(int j = 0; j < 4; j ++)
					{
						for(int i = 0; i < 4; i ++)
						{
							int col = k * 16 + j * 4 + i;

							//f
							A[row][col] = pow(dx0, i) * pow(dx1, j) * pow(dx2, k);

							//fx
							if(i == 0)
							{
								A[row + 8 * 1][col] = 0.0;
							}
							else
							{
								A[row + 8 * 1][col] = double(i) * pow(dx0, i - 1) * pow(dx1, j) * pow(dx2, k);
							}

							if(j == 0)
							{
								A[row + 8 * 2][col] = 0.0;
							}
							else
							{
								A[row + 8 * 2][col] = double(j) * pow(dx0, i) * pow(dx1, j - 1) * pow(dx2, k);
							}

							if(k == 0)
							{
								A[row + 8 * 3][col] = 0.0;
							}
							else
							{
								A[row + 8 * 3][col] = double(k) * pow(dx0, i) * pow(dx1, j) * pow(dx2, k - 1);
							}

							//fxx
							if(i == 0 || j == 0)
							{
								A[row + 8 * 4][col] = 0.0;
							}
							else
							{
								A[row + 8 * 4][col] = double(i) * double(j) * pow(dx0, i - 1) * pow(dx1, j - 1) * pow(dx2, k);
							}

							if(i == 0 || k == 0)
							{
								A[row+ 8 * 5][col] = 0.0;
							}
							else
							{
								A[row+ 8 * 5][col] = double(i) * double(k) * pow(dx0, i - 1) * pow(dx1, j) * pow(dx2, k - 1);
							}

							if(j == 0 || k == 0)
							{
								A[row + 8 * 6][col] = 0.0;
							}
							else
							{
								A[row + 8 * 6][col] = double(j) * double(k) * pow(dx0, i) * pow(dx1, j - 1) * pow(dx2, k - 1);
							}

							//fxxx
							if(i == 0 || j == 0 || k == 0)
							{
								A[row + 8 * 7][col] = 0.0;
							}
							else
							{
								A[row + 8 * 7][col] = double(i) * double(j) * double(k) * pow(dx0, i - 1) * pow(dx1, j - 1) * pow(dx2, k - 1);
							}
						}
					}
				}
			
				rhs[row] = f[nx0][nx1][nx2];
				rhs[row + 8 * 1] = fx0[nx0][nx1][nx2];
				rhs[row + 8 * 2] = fx1[nx0][nx1][nx2];
				rhs[row + 8 * 3] = fx2[nx0][nx1][nx2];
				rhs[row + 8 * 4] = fx0x1[nx0][nx1][nx2];
				rhs[row + 8 * 5] = fx0x2[nx0][nx1][nx2];
				rhs[row + 8 * 6] = fx1x2[nx0][nx1][nx2];
				rhs[row + 8 * 7] = fx0x1x2[nx0][nx1][nx2];
			}
		}
	}

	invertMatrix(A, rhs);

	a = std::vector<std::vector<std::vector<double>>>(4, std::vector<std::vector<double>>(4, std::vector<double>(4)));

	for(int nx2 = 0; nx2 < 4; nx2 ++)
	{
		for(int nx1 = 0; nx1 < 4; nx1 ++)
		{
			for(int nx0 = 0; nx0 < 4; nx0 ++)
			{
				int idx = nx2 * 16 + nx1 * 4 + nx0;
				a[nx0][nx1][nx2] = rhs[idx];
			}
		}
	}

	return;
}

inline double TriCubicInterpolator::interpolation(double x00, double x10, double x20)
{
	double result = 0.0;

	int nx0 = 0;
	int nx1 = 0;
	int nx2 = 0;

	if(x00 <= x0[0])
	{
		x00 = x0[0];
	}
	else if(x00 >= x0[x0.size() - 1])
	{
		x00 = x0[x0.size() - 1];
	}
	if(x10 <= x1[0])
	{
		x10 = x1[0];
	}
	else if(x10 >= x1[x1.size() - 1])
	{
		x10 = x1[x1.size() - 1];
	}
	if(x20 <= x2[0])
	{
		x20 = x2[0];
	}
	else if(x20 >= x2[x2.size() - 1])
	{
		x20 = x2[x2.size() - 1];
	}

	for(int i = 0; i < x0.size() - 1; i ++)
	{
		if(x0[i] <= x00 && x00 <= x0[i + 1])
		{
			nx0 = i;
			break;
		}
	}
	for(int i = 0; i < x1.size() - 1; i ++)
	{
		if(x1[i] <= x10 && x10 <= x1[i + 1])
		{
			nx1 = i;
			break;
		}
	}
	for(int i = 0; i < x2.size() - 1; i ++)
	{
		if(x2[i] <= x20 && x20 <= x2[i + 1])
		{
			nx2 = i;
			break;
		}
	}

	// std::cout << nx0 << ", " << nx1 << ", " << nx2 << ", " << nx3 << ", " << nx4 << std::endl << std::flush;
	// std::cout << interval.size() << std::flush;
	// std::cout << ", " << interval[nx0].size() << std::flush;
	// std::cout << ", " << interval[nx0][nx1].size() << std::flush;
	// std::cout << ", " << interval[nx0][nx1][nx2].size() << std::flush;
	// std::cout << ", " << interval[nx0][nx1][nx2][nx3].size() << std::endl << std::flush;

	result = interval[nx0][nx1][nx2].interpolation(x00 - x0[nx0], x10 - x1[nx1], x20 - x2[nx2]);

	return result;
}

inline double TriCubicInterpolator::interpolation(std::vector<double> x0)
{
	return interpolation(x0[0], x0[1], x0[2]);
}

inline void TriCubicInterpolator::exportInterpolator(std::string filename)
{
	std::ofstream output(filename);

	//std::cout << x0.size() << ", " << x1.size() << ", " << x2.size() << ", " << x3.size() << ", " << x4.size() << std::endl;

	output << std::fixed << std::setprecision(20) << std::scientific << Double2Hex(x0[0]);
	for(int nx = 1; nx < x0.size(); nx ++)
	{
		output << std::fixed << std::setprecision(20) << std::scientific << ", " << Double2Hex(x0[nx]);
	}
	output << std::endl;
	output << std::fixed << std::setprecision(20) << std::scientific << Double2Hex(x1[0]);
	for(int nx = 1; nx < x1.size(); nx ++)
	{
		output << std::fixed << std::setprecision(20) << std::scientific << ", " << Double2Hex(x1[nx]);
	}
	output << std::endl;
	output << std::fixed << std::setprecision(20) << std::scientific << Double2Hex(x2[0]);
	for(int nx = 1; nx < x2.size(); nx ++)
	{
		output << std::fixed << std::setprecision(20) << std::scientific << ", " << Double2Hex(x2[nx]);
	}
	output << std::endl;

	for(int nx0 = 0; nx0 < x0.size() - 1; nx0 ++)
	{
		for(int nx1 = 0; nx1 < x1.size() - 1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < x2.size() - 1; nx2 ++)
			{
				output << std::dec << nx0 << ", " << nx1 << ", " << nx2 << std::flush;

				for(int i = 0; i < 4; i ++)
				{
					for(int j = 0; j < 4; j ++)
					{
						for(int k = 0; k < 4; k ++)
						{
							//std::cout << std::dec << nx0 << ", " << nx1 << ", " << nx2 << ", " << nx3 << ", " << nx4 << ", " << i << ", " << j << ", " << k << ", " << l << ", " << m << std::endl;
							output << std::fixed << std::setprecision(20) << std::scientific << ", " << Double2Hex(interval[nx0][nx1][nx2].a[i][j][k]) << std::flush;
						}
					}
				}

				output << std::endl << std::flush;
			}
		}
	}

	return;
}

inline void TriCubicInterpolator::importInterpolator(std::string filename)
{
	std::ifstream input(filename);

	std::string str;
	std::vector<double> x0in, x1in, x2in;
	
	{
		std::getline(input, str);
		if(str[0] != '#' && str.size() > 0)
		{
			auto data = spritString(str, ',');
			for(int i = 0; i < data.size(); i ++)
			{
				x0in.push_back(Hex2Double(data[i]));
			}
		}
		std::getline(input, str);
		if(str[0] != '#' && str.size() > 0)
		{
			auto data = spritString(str, ',');
			for(int i = 0; i < data.size(); i ++)
			{
				x1in.push_back(Hex2Double(data[i]));
			}
		}
		std::getline(input, str);
		if(str[0] != '#' && str.size() > 0)
		{
			auto data = spritString(str, ',');
			for(int i = 0; i < data.size(); i ++)
			{
				x2in.push_back(Hex2Double(data[i]));
			}
		}
	}

	x0 = x0in;
	x1 = x1in;
	x2 = x2in;

	interval = std::vector<std::vector<std::vector<TriCubicSpline>>>(x0.size() - 1, std::vector<std::vector<TriCubicSpline>>(x1.size() - 1, std::vector<TriCubicSpline>(x2.size() - 1)));

	while(std::getline(input, str))
	{
		if(str[0] != '#' && str.size() > 0)
		{
			auto data = spritString(str, ',');
			
			int nx0 = std::stoi(data[0]);
			int nx1 = std::stoi(data[1]);
			int nx2 = std::stoi(data[2]);

			interval[nx0][nx1][nx2].a = std::vector<std::vector<std::vector<double>>>(4, std::vector<std::vector<double>>(4, std::vector<double>(4)));
			for(int i = 0; i < 4; i ++)
			{
				for(int j = 0; j < 4; j ++)
				{
					for(int k = 0; k < 4; k ++)
					{
						int idx = 3 + i * 16 + j * 4 + k;
						interval[nx0][nx1][nx2].a[i][j][k] = Hex2Double(data[idx]);
					}
				}
			}
			interval[nx0][nx1][nx2].p = std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(3))));
			for(int i = 0; i < 2; i ++)
			{
				for(int j = 0; j < 2; j ++)
				{
					for(int k = 0; k < 2; k ++)
					{
						interval[nx0][nx1][nx2].p[i][j][k] = {x0[nx0 + i], x1[nx1 + j], x2[nx2 + k]};
					}
				}
			}
		}
	}

	return;
}

inline void TriCubicInterpolator::initialization(void)
{
	f = std::vector<std::vector<std::vector<double>>>(x0.size(), std::vector<std::vector<double>>(x1.size(), std::vector<double>(x2.size())));

	return;
}

inline void TriCubicInterpolator::clear(void)
{
	std::vector<std::vector<std::vector<double>>>().swap(f);
	std::vector<std::vector<std::vector<double>>>().swap(fx0);
	std::vector<std::vector<std::vector<double>>>().swap(fx1);
	std::vector<std::vector<std::vector<double>>>().swap(fx2);
	std::vector<std::vector<std::vector<double>>>().swap(fx0x1);
	std::vector<std::vector<std::vector<double>>>().swap(fx0x2);
	std::vector<std::vector<std::vector<double>>>().swap(fx1x2);
	std::vector<std::vector<std::vector<double>>>().swap(fx0x1x2);

	std::vector<std::vector<std::vector<TriCubicInterpolator::TriCubicSpline>>>().swap(interval);
	std::vector<std::vector<double>>().swap(A);

	return;
}

inline void TriCubicInterpolator::clearData(void)
{
	//f.clear();
	fx0.clear();
	fx1.clear();
	fx2.clear();
	fx0x1.clear();
	fx0x2.clear();
	fx1x2.clear();
	fx0x1x2.clear();

	for(int nx0 = 0; nx0 < interval.size(); nx0 ++)
	{
		for(int nx1 = 0; nx1 < interval[nx0].size(); nx1 ++)
		{
			for(int nx2 = 0; nx2 < interval[nx0][nx1].size(); nx2 ++)
			{
				interval[nx0][nx1][nx2].clearData();
			}
		}
	}

	A.clear();

	return;
}

inline void TriCubicInterpolator::TriCubicSpline::clearData(void)
{
	f.clear();
	p.clear();
	fx0.clear();
	fx1.clear();
	fx2.clear();
	fx0x1.clear();
	fx0x2.clear();
	fx1x2.clear();
	fx0x1x2.clear();

	return;
}

inline void TetraCubicInterpolator::makeInterpolator(void)
{
	int Nx0 = x0.size();
	int Nx1 = x1.size();
	int Nx2 = x2.size();
	int Nx3 = x3.size();

	std::vector<std::vector<std::vector<Spline>>> spline_x0 = std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx3)));
	std::vector<std::vector<std::vector<Spline>>> spline_x1 = std::vector<std::vector<std::vector<Spline>>>(Nx0, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx3)));
	std::vector<std::vector<std::vector<Spline>>> spline_x2 = std::vector<std::vector<std::vector<Spline>>>(Nx0, std::vector<std::vector<Spline>>(Nx1, std::vector<Spline>(Nx3)));
	std::vector<std::vector<std::vector<Spline>>> spline_x3 = std::vector<std::vector<std::vector<Spline>>>(Nx0, std::vector<std::vector<Spline>>(Nx1, std::vector<Spline>(Nx2)));

	//MakeSpline spline_x0
	for(int nx1 = 0; nx1 < Nx1; nx1 ++)
	{
		for(int nx2 = 0; nx2 < Nx2; nx2 ++)
		{
			for(int nx3 = 0; nx3 < Nx3; nx3 ++)
			{
				for(int nx0 = 0; nx0 < Nx0; nx0 ++)
				{
					spline_x0[nx1][nx2][nx3].x.push_back(x0[nx0]);
					spline_x0[nx1][nx2][nx3].f.push_back(f[nx0][nx1][nx2][nx3]);
				}
				if(spline_type[0] == SPLINE_TYPE::NATURAL)
				{
					spline_x0[nx1][nx2][nx3].makeNaturalSpline();
				}
				else if(spline_type[0] == SPLINE_TYPE::CLAMPED)
				{
					spline_x0[nx1][nx2][nx3].makeClampedSpline();
				}
			}
		}
	}

	//MakeSpline spline_x1
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx2 = 0; nx2 < Nx2; nx2 ++)
		{
			for(int nx3 = 0; nx3 < Nx3; nx3 ++)
			{
				for(int nx1 = 0; nx1 < Nx1; nx1 ++)
				{
					spline_x1[nx0][nx2][nx3].x.push_back(x1[nx1]);
					spline_x1[nx0][nx2][nx3].f.push_back(f[nx0][nx1][nx2][nx3]);
				}
				if(spline_type[1] == SPLINE_TYPE::NATURAL)
				{
					spline_x1[nx0][nx2][nx3].makeNaturalSpline();
				}
				else if(spline_type[1] == SPLINE_TYPE::CLAMPED)
				{
					spline_x1[nx0][nx2][nx3].makeClampedSpline();
				}
			}
		}
	}

	//MakeSpline spline_x2
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx3 = 0; nx3 < Nx3; nx3 ++)
			{
				for(int nx2 = 0; nx2 < Nx2; nx2 ++)
				{
					spline_x2[nx0][nx1][nx3].x.push_back(x2[nx2]);
					spline_x2[nx0][nx1][nx3].f.push_back(f[nx0][nx1][nx2][nx3]);
				}
				if(spline_type[2] == SPLINE_TYPE::NATURAL)
				{
					spline_x2[nx0][nx1][nx3].makeNaturalSpline();
				}
				else if(spline_type[2] == SPLINE_TYPE::CLAMPED)
				{
					spline_x2[nx0][nx1][nx3].makeClampedSpline();
				}
			}
		}
	}

	//MakeSpline spline_x3
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					spline_x3[nx0][nx1][nx2].x.push_back(x3[nx3]);
					spline_x3[nx0][nx1][nx2].f.push_back(f[nx0][nx1][nx2][nx3]);
				}
				if(spline_type[3] == SPLINE_TYPE::NATURAL)
				{
					spline_x3[nx0][nx1][nx2].makeNaturalSpline();
				}
				else if(spline_type[3] == SPLINE_TYPE::CLAMPED)
				{
					spline_x3[nx0][nx1][nx2].makeClampedSpline();
				}
			}
		}
	}

	//Derive fx0, fx1, fx2, fx3
	fx0 = std::vector<std::vector<std::vector<std::vector<double>>>>(Nx0, std::vector<std::vector<std::vector<double>>>(Nx1, std::vector<std::vector<double>>(Nx2, std::vector<double>(Nx3))));
	fx1 = std::vector<std::vector<std::vector<std::vector<double>>>>(Nx0, std::vector<std::vector<std::vector<double>>>(Nx1, std::vector<std::vector<double>>(Nx2, std::vector<double>(Nx3))));
	fx2 = std::vector<std::vector<std::vector<std::vector<double>>>>(Nx0, std::vector<std::vector<std::vector<double>>>(Nx1, std::vector<std::vector<double>>(Nx2, std::vector<double>(Nx3))));
	fx3 = std::vector<std::vector<std::vector<std::vector<double>>>>(Nx0, std::vector<std::vector<std::vector<double>>>(Nx1, std::vector<std::vector<double>>(Nx2, std::vector<double>(Nx3))));

	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					if(nx0 != Nx0 - 1)
					{
						fx0[nx0][nx1][nx2][nx3] = spline_x0[nx1][nx2][nx3].c[nx0];
					}
					else
					{
						double Dx0 = x0[Nx0 - 1] - x0[Nx0 - 2];
						fx0[nx0][nx1][nx2][nx3] = 3.0 * spline_x0[nx1][nx2][nx3].a[nx0 - 1] * Dx0 * Dx0 + 2.0 * spline_x0[nx1][nx2][nx3].b[nx0 - 1] * Dx0 + spline_x0[nx1][nx2][nx3].c[nx0 - 1];
					}

					if(nx1 != Nx1 - 1)
					{
						fx1[nx0][nx1][nx2][nx3] = spline_x1[nx0][nx2][nx3].c[nx1];
					}
					else
					{
						double Dx1 = x1[Nx1 - 1] - x1[Nx1 - 2];
						fx1[nx0][nx1][nx2][nx3] = 3.0 * spline_x1[nx0][nx2][nx3].a[nx1 - 1] * Dx1 * Dx1 + 2.0 * spline_x1[nx0][nx2][nx3].b[nx1 - 1] * Dx1 + spline_x1[nx0][nx2][nx3].c[nx1 - 1];
					}

					if(nx2 != Nx2 - 1)
					{
						fx2[nx0][nx1][nx2][nx3] = spline_x2[nx0][nx1][nx3].c[nx2];
					}
					else
					{
						double Dx2 = x2[Nx2 - 1] - x2[Nx2 - 2];
						fx2[nx0][nx1][nx2][nx3] = 3.0 * spline_x2[nx0][nx1][nx3].a[nx2 - 1] * Dx2 * Dx2 + 2.0 * spline_x2[nx0][nx1][nx3].b[nx2 - 1] * Dx2 + spline_x2[nx0][nx1][nx3].c[nx2 - 1];
					}

					if(nx3 != Nx3 - 1)
					{
						fx3[nx0][nx1][nx2][nx3] = spline_x3[nx0][nx1][nx2].c[nx3];
					}
					else
					{
						double Dx3 = x3[Nx3 - 1] - x3[Nx3 - 2];
						fx3[nx0][nx1][nx2][nx3] = 3.0 * spline_x3[nx0][nx1][nx2].a[nx3 - 1] * Dx3 * Dx3 + 2.0 * spline_x3[nx0][nx1][nx2].b[nx3 - 1] * Dx3 + spline_x3[nx0][nx1][nx2].c[nx3 - 1];
					}
				}
			}
		}
	}

	std::vector<std::vector<std::vector<Spline>>> spline_dx0_x1 = std::vector<std::vector<std::vector<Spline>>>(Nx0, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx3)));	// for fx0x1
	std::vector<std::vector<std::vector<Spline>>> spline_dx0_x2 = std::vector<std::vector<std::vector<Spline>>>(Nx0, std::vector<std::vector<Spline>>(Nx1, std::vector<Spline>(Nx3)));	// for fx0x2
	std::vector<std::vector<std::vector<Spline>>> spline_dx0_x3 = std::vector<std::vector<std::vector<Spline>>>(Nx0, std::vector<std::vector<Spline>>(Nx1, std::vector<Spline>(Nx2)));	// for fx0x3
	std::vector<std::vector<std::vector<Spline>>> spline_dx1_x2 = std::vector<std::vector<std::vector<Spline>>>(Nx0, std::vector<std::vector<Spline>>(Nx1, std::vector<Spline>(Nx3)));	// for fx1x2
	std::vector<std::vector<std::vector<Spline>>> spline_dx1_x3 = std::vector<std::vector<std::vector<Spline>>>(Nx0, std::vector<std::vector<Spline>>(Nx1, std::vector<Spline>(Nx2)));	// for fx1x3
	std::vector<std::vector<std::vector<Spline>>> spline_dx2_x3 = std::vector<std::vector<std::vector<Spline>>>(Nx0, std::vector<std::vector<Spline>>(Nx1, std::vector<Spline>(Nx2)));	// for fx2x3

	//MakeSpline spline_dx0_x1
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx2 = 0; nx2 < Nx2; nx2 ++)
		{
			for(int nx3 = 0; nx3 < Nx3; nx3 ++)
			{
				for(int nx1 = 0; nx1 < Nx1; nx1 ++)
				{
					spline_dx0_x1[nx0][nx2][nx3].x.push_back(x1[nx1]);
					spline_dx0_x1[nx0][nx2][nx3].f.push_back(fx0[nx0][nx1][nx2][nx3]);
				}

				if(spline_type[1] == SPLINE_TYPE::NATURAL)
				{
					spline_dx0_x1[nx0][nx2][nx3].makeNaturalSpline();
				}
				else if(spline_type[1] == SPLINE_TYPE::CLAMPED)
				{
					spline_dx0_x1[nx0][nx2][nx3].makeClampedSpline();
				}
			}
		}
	}
	
	//MakeSpline spline_dx0_x2
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx3 = 0; nx3 < Nx3; nx3 ++)
			{
				for(int nx2 = 0; nx2 < Nx2; nx2 ++)
				{
					spline_dx0_x2[nx0][nx1][nx3].x.push_back(x2[nx2]);
					spline_dx0_x2[nx0][nx1][nx3].f.push_back(fx0[nx0][nx1][nx2][nx3]);
				}

				if(spline_type[2] == SPLINE_TYPE::NATURAL)
				{
					spline_dx0_x2[nx0][nx1][nx3].makeNaturalSpline();
				}
				else if(spline_type[2] == SPLINE_TYPE::CLAMPED)
				{
					spline_dx0_x2[nx0][nx1][nx3].makeClampedSpline();
				}
			}
		}
	}

	//MakeSpline spline_dx0_x3
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					spline_dx0_x3[nx0][nx1][nx2].x.push_back(x3[nx3]);
					spline_dx0_x3[nx0][nx1][nx2].f.push_back(fx0[nx0][nx1][nx2][nx3]);
				}

				if(spline_type[3] == SPLINE_TYPE::NATURAL)
				{
					spline_dx0_x3[nx0][nx1][nx2].makeNaturalSpline();
				}
				else if(spline_type[3] == SPLINE_TYPE::CLAMPED)
				{
					spline_dx0_x3[nx0][nx1][nx2].makeClampedSpline();
				}
			}
		}
	}

	//MakeSpline spline_dx1_x2
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx3 = 0; nx3 < Nx3; nx3 ++)
			{
				for(int nx2 = 0; nx2 < Nx2; nx2 ++)
				{
					spline_dx1_x2[nx0][nx1][nx3].x.push_back(x2[nx2]);
					spline_dx1_x2[nx0][nx1][nx3].f.push_back(fx1[nx0][nx1][nx2][nx3]);
				}

				if(spline_type[2] == SPLINE_TYPE::NATURAL)
				{
					spline_dx1_x2[nx0][nx1][nx3].makeNaturalSpline();
				}
				else if(spline_type[2] == SPLINE_TYPE::CLAMPED)
				{
					spline_dx1_x2[nx0][nx1][nx3].makeClampedSpline();
				}
			}
		}
	}

	//MakeSpline spline_dx1_x3
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					spline_dx1_x3[nx0][nx1][nx2].x.push_back(x3[nx3]);
					spline_dx1_x3[nx0][nx1][nx2].f.push_back(fx1[nx0][nx1][nx2][nx3]);
				}

				if(spline_type[3] == SPLINE_TYPE::NATURAL)
				{
					spline_dx1_x3[nx0][nx1][nx2].makeNaturalSpline();
				}
				else if(spline_type[3] == SPLINE_TYPE::CLAMPED)
				{
					spline_dx1_x3[nx0][nx1][nx2].makeClampedSpline();
				}
			}
		}
	}

	//MakeSpline spline_dx2_x3
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					spline_dx2_x3[nx0][nx1][nx2].x.push_back(x3[nx3]);
					spline_dx2_x3[nx0][nx1][nx2].f.push_back(fx2[nx0][nx1][nx2][nx3]);
				}

				if(spline_type[3] == SPLINE_TYPE::NATURAL)
				{
					spline_dx2_x3[nx0][nx1][nx2].makeNaturalSpline();
				}
				else if(spline_type[3] == SPLINE_TYPE::CLAMPED)
				{
					spline_dx2_x3[nx0][nx1][nx2].makeClampedSpline();
				}
			}
		}
	}

	fx0x1 = std::vector<std::vector<std::vector<std::vector<double>>>>(Nx0, std::vector<std::vector<std::vector<double>>>(Nx1, std::vector<std::vector<double>>(Nx2, std::vector<double>(Nx3))));
	fx0x2 = std::vector<std::vector<std::vector<std::vector<double>>>>(Nx0, std::vector<std::vector<std::vector<double>>>(Nx1, std::vector<std::vector<double>>(Nx2, std::vector<double>(Nx3))));
	fx0x3 = std::vector<std::vector<std::vector<std::vector<double>>>>(Nx0, std::vector<std::vector<std::vector<double>>>(Nx1, std::vector<std::vector<double>>(Nx2, std::vector<double>(Nx3))));
	fx1x2 = std::vector<std::vector<std::vector<std::vector<double>>>>(Nx0, std::vector<std::vector<std::vector<double>>>(Nx1, std::vector<std::vector<double>>(Nx2, std::vector<double>(Nx3))));
	fx1x3 = std::vector<std::vector<std::vector<std::vector<double>>>>(Nx0, std::vector<std::vector<std::vector<double>>>(Nx1, std::vector<std::vector<double>>(Nx2, std::vector<double>(Nx3))));
	fx2x3 = std::vector<std::vector<std::vector<std::vector<double>>>>(Nx0, std::vector<std::vector<std::vector<double>>>(Nx1, std::vector<std::vector<double>>(Nx2, std::vector<double>(Nx3))));
	
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					if(nx1 != Nx1 - 1)
					{
						fx0x1[nx0][nx1][nx2][nx3] = spline_dx0_x1[nx0][nx2][nx3].c[nx1];
					}
					else
					{
						double Dx1 = x1[Nx1 - 1] - x1[Nx1 - 2];
						fx0x1[nx0][nx1][nx2][nx3] = 3.0 * spline_dx0_x1[nx0][nx2][nx3].a[nx1 - 1] * Dx1 * Dx1 + 2.0 * spline_dx0_x1[nx0][nx2][nx3].b[nx1 - 1] * Dx1 + spline_dx0_x1[nx0][nx2][nx3].c[nx1 - 1];
					}

					if(nx2 != Nx2 - 1)
					{
						fx0x2[nx0][nx1][nx2][nx3] = spline_dx0_x2[nx0][nx1][nx3].c[nx2];
					}
					else
					{
						double Dx2 = x2[Nx2 - 1] - x2[Nx2 - 2];
						fx0x2[nx0][nx1][nx2][nx3] = 3.0 * spline_dx0_x2[nx0][nx1][nx3].a[nx2 - 1] * Dx2 * Dx2 + 2.0 * spline_dx0_x2[nx0][nx1][nx3].b[nx2 - 1] * Dx2 + spline_dx0_x2[nx0][nx1][nx3].c[nx2 - 1];
					}

					if(nx3 != Nx3 - 1)
					{
						fx0x3[nx0][nx1][nx2][nx3] = spline_dx0_x3[nx0][nx1][nx2].c[nx3];
					}
					else
					{
						double Dx3 = x3[Nx3 - 1] - x3[Nx3 - 2];
						fx0x3[nx0][nx1][nx2][nx3] = 3.0 * spline_dx0_x3[nx0][nx1][nx2].a[nx3 - 1] * Dx3 * Dx3 + 2.0 * spline_dx0_x3[nx0][nx1][nx2].b[nx3 - 1] * Dx3 + spline_dx0_x3[nx0][nx1][nx2].c[nx3 - 1];
					}

					if(nx2 != Nx2 - 1)
					{
						fx1x2[nx0][nx1][nx2][nx3] = spline_dx1_x2[nx0][nx1][nx3].c[nx2];
					}
					else
					{
						double Dx2 = x2[Nx2 - 1] - x2[Nx2 - 2];
						fx1x2[nx0][nx1][nx2][nx3] = 3.0 * spline_dx1_x2[nx0][nx1][nx3].a[nx2 - 1] * Dx2 * Dx2 + 2.0 * spline_dx1_x2[nx0][nx1][nx3].b[nx2 - 1] * Dx2 + spline_dx1_x2[nx0][nx1][nx3].c[nx2 - 1];
					}

					if(nx3 != Nx3 - 1)
					{
						fx1x3[nx0][nx1][nx2][nx3] = spline_dx1_x3[nx0][nx1][nx2].c[nx3];
					}
					else
					{
						double Dx3 = x3[Nx3 - 1] - x3[Nx3 - 2];
						fx1x3[nx0][nx1][nx2][nx3] = 3.0 * spline_dx1_x3[nx0][nx1][nx2].a[nx3 - 1] * Dx3 * Dx3 + 2.0 * spline_dx1_x3[nx0][nx1][nx2].b[nx3 - 1] * Dx3 + spline_dx1_x3[nx0][nx1][nx2].c[nx3 - 1];
					}

					if(nx3 != Nx3 - 1)
					{
						fx2x3[nx0][nx1][nx2][nx3] = spline_dx2_x3[nx0][nx1][nx2].c[nx3];
					}
					else
					{
						double Dx3 = x3[Nx3 - 1] - x3[Nx3 - 2];
						fx2x3[nx0][nx1][nx2][nx3] = 3.0 * spline_dx2_x3[nx0][nx1][nx2].a[nx3 - 1] * Dx3 * Dx3 + 2.0 * spline_dx2_x3[nx0][nx1][nx2].b[nx3 - 1] * Dx3 + spline_dx2_x3[nx0][nx1][nx2].c[nx3 - 1];
					}
				}
			}
		}
	}

	std::vector<std::vector<std::vector<Spline>>> spline_dx0dx1_x2 = std::vector<std::vector<std::vector<Spline>>>(Nx0, std::vector<std::vector<Spline>>(Nx1, std::vector<Spline>(Nx3)));	// for fx0x1x2
	std::vector<std::vector<std::vector<Spline>>> spline_dx0dx1_x3 = std::vector<std::vector<std::vector<Spline>>>(Nx0, std::vector<std::vector<Spline>>(Nx1, std::vector<Spline>(Nx2)));	// for fx0x1x3
	std::vector<std::vector<std::vector<Spline>>> spline_dx0dx2_x3 = std::vector<std::vector<std::vector<Spline>>>(Nx0, std::vector<std::vector<Spline>>(Nx1, std::vector<Spline>(Nx2)));	// for fx0x2x3
	std::vector<std::vector<std::vector<Spline>>> spline_dx1dx2_x3 = std::vector<std::vector<std::vector<Spline>>>(Nx0, std::vector<std::vector<Spline>>(Nx1, std::vector<Spline>(Nx2)));	// for fx1x2x3

	//MakeSpline spline_dx0dx1_x2
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx3 = 0; nx3 < Nx3; nx3 ++)
			{
				for(int nx2 = 0; nx2 < Nx2; nx2 ++)
				{
					spline_dx0dx1_x2[nx0][nx1][nx3].x.push_back(x2[nx2]);
					spline_dx0dx1_x2[nx0][nx1][nx3].f.push_back(fx0x1[nx0][nx1][nx2][nx3]);
				}

				if(spline_type[2] == SPLINE_TYPE::NATURAL)
				{
					spline_dx0dx1_x2[nx0][nx1][nx3].makeNaturalSpline();
				}
				else if(spline_type[2] == SPLINE_TYPE::CLAMPED)
				{
					spline_dx0dx1_x2[nx0][nx1][nx3].makeClampedSpline();
				}
			}
		}
	}

	//MakeSpline spline_dx0dx1_x3
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					spline_dx0dx1_x3[nx0][nx1][nx2].x.push_back(x3[nx3]);
					spline_dx0dx1_x3[nx0][nx1][nx2].f.push_back(fx0x1[nx0][nx1][nx2][nx3]);
				}

				if(spline_type[3] == SPLINE_TYPE::NATURAL)
				{
					spline_dx0dx1_x3[nx0][nx1][nx2].makeNaturalSpline();
				}
				else if(spline_type[3] == SPLINE_TYPE::CLAMPED)
				{
					spline_dx0dx1_x3[nx0][nx1][nx2].makeClampedSpline();
				}
			}
		}
	}

	//MakeSpline spline_dx0dx2_x3
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					spline_dx0dx2_x3[nx0][nx1][nx2].x.push_back(x3[nx3]);
					spline_dx0dx2_x3[nx0][nx1][nx2].f.push_back(fx0x2[nx0][nx1][nx2][nx3]);
				}

				if(spline_type[3] == SPLINE_TYPE::NATURAL)
				{
					spline_dx0dx2_x3[nx0][nx1][nx2].makeNaturalSpline();
				}
				else if(spline_type[3] == SPLINE_TYPE::CLAMPED)
				{
					spline_dx0dx2_x3[nx0][nx1][nx2].makeClampedSpline();
				}
			}
		}
	}

	//MakeSpline spline_dx1dx2_x3
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					spline_dx1dx2_x3[nx0][nx1][nx2].x.push_back(x3[nx3]);
					spline_dx1dx2_x3[nx0][nx1][nx2].f.push_back(fx1x2[nx0][nx1][nx2][nx3]);
				}

				if(spline_type[3] == SPLINE_TYPE::NATURAL)
				{
					spline_dx1dx2_x3[nx0][nx1][nx2].makeNaturalSpline();
				}
				else if(spline_type[3] == SPLINE_TYPE::CLAMPED)
				{
					spline_dx1dx2_x3[nx0][nx1][nx2].makeClampedSpline();
				}
			}
		}
	}

	fx0x1x2 = std::vector<std::vector<std::vector<std::vector<double>>>>(Nx0, std::vector<std::vector<std::vector<double>>>(Nx1, std::vector<std::vector<double>>(Nx2, std::vector<double>(Nx3))));
	fx0x1x3 = std::vector<std::vector<std::vector<std::vector<double>>>>(Nx0, std::vector<std::vector<std::vector<double>>>(Nx1, std::vector<std::vector<double>>(Nx2, std::vector<double>(Nx3))));
	fx0x2x3 = std::vector<std::vector<std::vector<std::vector<double>>>>(Nx0, std::vector<std::vector<std::vector<double>>>(Nx1, std::vector<std::vector<double>>(Nx2, std::vector<double>(Nx3))));
	fx1x2x3 = std::vector<std::vector<std::vector<std::vector<double>>>>(Nx0, std::vector<std::vector<std::vector<double>>>(Nx1, std::vector<std::vector<double>>(Nx2, std::vector<double>(Nx3))));
	
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					if(nx2 != Nx2 - 1)
					{
						fx0x1x2[nx0][nx1][nx2][nx3] = spline_dx0dx1_x2[nx0][nx1][nx3].c[nx2];
					}
					else
					{
						double Dx2 = x2[Nx2 - 1] - x2[Nx2 - 2];
						fx0x1x2[nx0][nx1][nx2][nx3] = 3.0 * spline_dx0dx1_x2[nx0][nx1][nx3].a[nx2 - 1] * Dx2 * Dx2 + 2.0 * spline_dx0dx1_x2[nx0][nx1][nx3].b[nx2 - 1] * Dx2 + spline_dx0dx1_x2[nx0][nx1][nx3].c[nx2 - 1];
					}

					if(nx3 != Nx3 - 1)
					{
						fx0x1x3[nx0][nx1][nx2][nx3] = spline_dx0dx1_x3[nx0][nx1][nx2].c[nx3];
					}
					else
					{
						double Dx3 = x3[Nx3 - 1] - x3[Nx3 - 2];
						fx0x1x3[nx0][nx1][nx2][nx3] = 3.0 * spline_dx0dx1_x3[nx0][nx1][nx2].a[nx3 - 1] * Dx3 * Dx3 + 2.0 * spline_dx0dx1_x3[nx0][nx1][nx2].b[nx3 - 1] * Dx3 + spline_dx0dx1_x3[nx0][nx1][nx2].c[nx3 - 1];
					}

					if(nx3 != Nx3 - 1)
					{
						fx0x2x3[nx0][nx1][nx2][nx3] = spline_dx0dx2_x3[nx0][nx1][nx2].c[nx3];
					}
					else
					{
						double Dx3 = x3[Nx3 - 1] - x3[Nx3 - 2];
						fx0x2x3[nx0][nx1][nx2][nx3] = 3.0 * spline_dx0dx2_x3[nx0][nx1][nx2].a[nx3 - 1] * Dx3 * Dx3 + 2.0 * spline_dx0dx2_x3[nx0][nx1][nx2].b[nx3 - 1] * Dx3 + spline_dx0dx2_x3[nx0][nx1][nx2].c[nx3 - 1];
					}

					if(nx3 != Nx3 - 1)
					{
						fx1x2x3[nx0][nx1][nx2][nx3] = spline_dx1dx2_x3[nx0][nx1][nx2].c[nx3];
					}
					else
					{
						double Dx3 = x3[Nx3 - 1] - x3[Nx3 - 2];
						fx1x2x3[nx0][nx1][nx2][nx3] = 3.0 * spline_dx1dx2_x3[nx0][nx1][nx2].a[nx3 - 1] * Dx3 * Dx3 + 2.0 * spline_dx1dx2_x3[nx0][nx1][nx2].b[nx3 - 1] * Dx3 + spline_dx1dx2_x3[nx0][nx1][nx2].c[nx3 - 1];
					}
				}
			}
		}
	}

	std::vector<std::vector<std::vector<Spline>>> spline_dx0dx1dx2_x3 = std::vector<std::vector<std::vector<Spline>>>(Nx0, std::vector<std::vector<Spline>>(Nx1, std::vector<Spline>(Nx2)));	// for fx0x1x2x3

	//MakeSpline spline_dx0dx1dx2_x3
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					spline_dx0dx1dx2_x3[nx0][nx1][nx2].x.push_back(x3[nx3]);
					spline_dx0dx1dx2_x3[nx0][nx1][nx2].f.push_back(fx0x1x2[nx0][nx1][nx2][nx3]);
				}

				if(spline_type[3] == SPLINE_TYPE::NATURAL)
				{
					spline_dx0dx1dx2_x3[nx0][nx1][nx2].makeNaturalSpline();
				}
				else if(spline_type[3] == SPLINE_TYPE::CLAMPED)
				{
					spline_dx0dx1dx2_x3[nx0][nx1][nx2].makeClampedSpline();
				}
			}
		}
	}

	fx0x1x2x3 = std::vector<std::vector<std::vector<std::vector<double>>>>(Nx0, std::vector<std::vector<std::vector<double>>>(Nx1, std::vector<std::vector<double>>(Nx2, std::vector<double>(Nx3))));
	
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					if(nx3 != Nx3 - 1)
					{
						fx0x1x2x3[nx0][nx1][nx2][nx3] = spline_dx0dx1dx2_x3[nx0][nx1][nx2].c[nx3];
					}
					else
					{
						double Dx3 = x3[Nx3 - 1] - x3[Nx3 - 2];
						fx0x1x2x3[nx0][nx1][nx2][nx3] = 3.0 * spline_dx0dx1dx2_x3[nx0][nx1][nx2].a[nx3 - 1] * Dx3 * Dx3 + 2.0 * spline_dx0dx1dx2_x3[nx0][nx1][nx2].b[nx3 - 1] * Dx3 + spline_dx0dx1dx2_x3[nx0][nx1][nx2].c[nx3 - 1];
					}
				}
			}
		}
	}

	interval = std::vector<std::vector<std::vector<std::vector<TetraCubicSpline>>>>(Nx0 - 1, std::vector<std::vector<std::vector<TetraCubicSpline>>>(Nx1 - 1, std::vector<std::vector<TetraCubicSpline>>(Nx2 - 1, std::vector<TetraCubicSpline>(Nx3 - 1))));

	if(regular_grid == true)
	{
		A = std::vector<std::vector<double>>(256, std::vector<double>(256));
		double Dx0 = x0[1] - x0[0];
		double Dx1 = x1[1] - x1[0];
		double Dx2 = x2[1] - x2[0];
		double Dx3 = x3[1] - x3[0];

		auto pow = [](double v1, int v2)
		{
			if(v1 == 0 && v2 == 0)
			{
				return 1.0;
			}
			else if(v1 == 0)
			{
				return 0.0;
			}
			else if(v2 == 0)
			{
				return 1.0;
			}
			else
			{
				return std::pow(v1, double(v2));
			}
		};

		for(int nx3 = 0; nx3 < 2; nx3 ++)
		{
			double dx3 = Dx3 * (double(nx3));

			for(int nx2 = 0; nx2 < 2; nx2 ++)
			{
				double dx2 = Dx2 * (double(nx2));
				
				for(int nx1 = 0; nx1 < 2; nx1 ++)
				{
					double dx1 = Dx1 * (double(nx1));

					for(int nx0 = 0; nx0 < 2; nx0 ++)
					{
						double dx0 = Dx0 * (double(nx0));

						int row = nx3 * 8 + nx2 * 4 + nx1 * 2 + nx0;

						for(int l = 0; l < 4; l ++)
						{
							for(int k = 0; k < 4; k ++)
							{
								for(int j = 0; j < 4; j ++)
								{
									for(int i = 0; i < 4; i ++)
									{
										int col = l * 64 + k * 16 + j * 4 + i;

										//f
										A[row][col] = pow(dx0, i) * pow(dx1, j) * pow(dx2, k) * pow(dx3, l);

										//fx
										if(i == 0)
										{
											A[row + 16 * 1][col] = 0.0;
										}
										else
										{
											A[row + 16 * 1][col] = double(i) * pow(dx0, i - 1) * pow(dx1, j) * pow(dx2, k) * pow(dx3, l);
										}

										if(j == 0)
										{
											A[row + 16 * 2][col] = 0.0;
										}
										else
										{
											A[row + 16 * 2][col] = double(j) * pow(dx0, i) * pow(dx1, j - 1) * pow(dx2, k) * pow(dx3, l);
										}

										if(k == 0)
										{
											A[row + 16 * 3][col] = 0.0;
										}
										else
										{
											A[row + 16 * 3][col] = double(k) * pow(dx0, i) * pow(dx1, j) * pow(dx2, k - 1) * pow(dx3, l);
										}

										if(l == 0)
										{
											A[row + 16 * 4][col] = 0.0;
										}
										else
										{
											A[row + 16 * 4][col] = double(l) * pow(dx0, i) * pow(dx1, j) * pow(dx2, k) * pow(dx3, l - 1);
										}

										//fxx
										if(i == 0 || j == 0)
										{
											A[row + 16 * 5][col] = 0.0;
										}
										else
										{
											A[row + 16 * 5][col] = double(i) * double(j) * pow(dx0, i - 1) * pow(dx1, j - 1) * pow(dx2, k) * pow(dx3, l);
										}

										if(i == 0 || k == 0)
										{
											A[row+ 16 * 6][col] = 0.0;
										}
										else
										{
											A[row+ 16 * 6][col] = double(i) * double(k) * pow(dx0, i - 1) * pow(dx1, j) * pow(dx2, k - 1) * pow(dx3, l);
										}

										if(i == 0 || l == 0)
										{
											A[row + 16 * 7][col] = 0.0;
										}
										else
										{
											A[row + 16 * 7][col] = double(i) * double(l) * pow(dx0, i - 1) * pow(dx1, j) * pow(dx2, k) * pow(dx3, l - 1);
										}

										if(j == 0 || k == 0)
										{
											A[row + 16 * 8][col] = 0.0;
										}
										else
										{
											A[row + 16 * 8][col] = double(j) * double(k) * pow(dx0, i) * pow(dx1, j - 1) * pow(dx2, k - 1) * pow(dx3, l);
										}

										if(j == 0 || l == 0)
										{
											A[row + 16 * 9][col] = 0.0;
										}
										else
										{
											A[row + 16 * 9][col] = double(j) * double(l) * pow(dx0, i) * pow(dx1, j - 1) * pow(dx2, k) * pow(dx3, l - 1);
										}

										if(k == 0 || l == 0)
										{
											A[row + 16 * 10][col] = 0.0;
										}
										else
										{
											A[row + 16 * 10][col] = double(k) * double(l) * pow(dx0, i) * pow(dx1, j) * pow(dx2, k - 1) * pow(dx3, l - 1);
										}

										//fxxx
										if(i == 0 || j == 0 || k == 0)
										{
											A[row + 16 * 11][col] = 0.0;
										}
										else
										{
											A[row + 16 * 11][col] = double(i) * double(j) * double(k) * pow(dx0, i - 1) * pow(dx1, j - 1) * pow(dx2, k - 1) * pow(dx3, l);
										}

										if(i == 0 || j == 0 || l == 0)
										{
											A[row + 16 * 12][col] = 0.0;
										}
										else
										{
											A[row + 16 * 12][col] = double(i) * double(j) * double(l) * pow(dx0, i - 1) * pow(dx1, j - 1) * pow(dx2, k) * pow(dx3, l - 1);
										}

										if(i == 0 || k == 0 || l == 0)
										{
											A[row + 16 * 13][col] = 0.0;
										}
										else
										{
											A[row + 16 * 13][col] = double(i) * double(k) * double(l) * pow(dx0, i - 1) * pow(dx1, j) * pow(dx2, k - 1) * pow(dx3, l - 1);
										}

										if(j == 0 || k == 0 || l == 0)
										{
											A[row + 16 * 14][col] = 0.0;
										}
										else
										{
											A[row + 16 * 14][col] = double(j) * double(k) * double(l) * pow(dx0, i) * pow(dx1, j - 1) * pow(dx2, k - 1) * pow(dx3, l - 1);
										}

										//fxxxx
										if(i == 0 || j == 0 || k == 0 || l == 0)
										{
											A[row + 16 * 15][col] = 0.0;
										}
										else
										{
											A[row + 16 * 15][col] = double(i) * double(j) * double(k) * double(l) * pow(dx0, i - 1) * pow(dx1, j - 1) * pow(dx2, k - 1) * pow(dx3, l - 1);
										}
									}
								}
							}
						}
					}
				}
			}
		}

		invertMatrix(A);
	}

	for(int nx0 = 0; nx0 < Nx0 - 1; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1 - 1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2 - 1; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3 - 1; nx3 ++)
				{
					interval[nx0][nx1][nx2][nx3].p = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(4)))));
					interval[nx0][nx1][nx2][nx3].f = std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2))));
					interval[nx0][nx1][nx2][nx3].fx0 = std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2))));
					interval[nx0][nx1][nx2][nx3].fx1 = std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2))));
					interval[nx0][nx1][nx2][nx3].fx2 = std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2))));
					interval[nx0][nx1][nx2][nx3].fx3 = std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2))));
					interval[nx0][nx1][nx2][nx3].fx0x1 = std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2))));
					interval[nx0][nx1][nx2][nx3].fx0x2 = std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2))));
					interval[nx0][nx1][nx2][nx3].fx0x3 = std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2))));
					interval[nx0][nx1][nx2][nx3].fx1x2 = std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2))));
					interval[nx0][nx1][nx2][nx3].fx1x3 = std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2))));
					interval[nx0][nx1][nx2][nx3].fx2x3 = std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2))));
					interval[nx0][nx1][nx2][nx3].fx0x1x2 = std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2))));
					interval[nx0][nx1][nx2][nx3].fx0x1x3 = std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2))));
					interval[nx0][nx1][nx2][nx3].fx0x2x3 = std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2))));
					interval[nx0][nx1][nx2][nx3].fx1x2x3 = std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2))));
					interval[nx0][nx1][nx2][nx3].fx0x1x2x3 = std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2))));
					
					for(int i = 0; i < 2; i ++)
					{
						for(int j = 0; j < 2; j ++)
						{
							for(int k = 0; k < 2; k ++)
							{
								for(int l = 0; l < 2; l ++)
								{
									interval[nx0][nx1][nx2][nx3].p[i][j][k][l] = {x0[nx0 + i], x1[nx1 + j], x2[nx2 + k], x3[nx3 + l]};
									interval[nx0][nx1][nx2][nx3].f[i][j][k][l] = f[nx0 + i][nx1 + j][nx2 + k][nx3 + l];
									interval[nx0][nx1][nx2][nx3].fx0[i][j][k][l] = fx0[nx0 + i][nx1 + j][nx2 + k][nx3 + l];
									interval[nx0][nx1][nx2][nx3].fx1[i][j][k][l] = fx1[nx0 + i][nx1 + j][nx2 + k][nx3 + l];
									interval[nx0][nx1][nx2][nx3].fx2[i][j][k][l] = fx2[nx0 + i][nx1 + j][nx2 + k][nx3 + l];
									interval[nx0][nx1][nx2][nx3].fx3[i][j][k][l] = fx3[nx0 + i][nx1 + j][nx2 + k][nx3 + l];
									interval[nx0][nx1][nx2][nx3].fx0x1[i][j][k][l] = fx0x1[nx0 + i][nx1 + j][nx2 + k][nx3 + l];
									interval[nx0][nx1][nx2][nx3].fx0x2[i][j][k][l] = fx0x2[nx0 + i][nx1 + j][nx2 + k][nx3 + l];
									interval[nx0][nx1][nx2][nx3].fx0x3[i][j][k][l] = fx0x3[nx0 + i][nx1 + j][nx2 + k][nx3 + l];
									interval[nx0][nx1][nx2][nx3].fx1x2[i][j][k][l] = fx1x2[nx0 + i][nx1 + j][nx2 + k][nx3 + l];
									interval[nx0][nx1][nx2][nx3].fx1x3[i][j][k][l] = fx1x3[nx0 + i][nx1 + j][nx2 + k][nx3 + l];
									interval[nx0][nx1][nx2][nx3].fx2x3[i][j][k][l] = fx2x3[nx0 + i][nx1 + j][nx2 + k][nx3 + l];
									interval[nx0][nx1][nx2][nx3].fx0x1x2[i][j][k][l] = fx0x1x2[nx0 + i][nx1 + j][nx2 + k][nx3 + l];
									interval[nx0][nx1][nx2][nx3].fx0x1x3[i][j][k][l] = fx0x1x3[nx0 + i][nx1 + j][nx2 + k][nx3 + l];
									interval[nx0][nx1][nx2][nx3].fx0x2x3[i][j][k][l] = fx0x2x3[nx0 + i][nx1 + j][nx2 + k][nx3 + l];
									interval[nx0][nx1][nx2][nx3].fx1x2x3[i][j][k][l] = fx1x2x3[nx0 + i][nx1 + j][nx2 + k][nx3 + l];
									interval[nx0][nx1][nx2][nx3].fx0x1x2x3[i][j][k][l] = fx0x1x2x3[nx0 + i][nx1 + j][nx2 + k][nx3 + l];
								}
							}
						}
					}

					if(regular_grid == false)
					{
						interval[nx0][nx1][nx2][nx3].makeInterpolator();
					}
					else if(regular_grid == true)
					{
						interval[nx0][nx1][nx2][nx3].makeInterpolator(A);
					}

					interval[nx0][nx1][nx2][nx3].clearData();
				}
			}
		}
	}

	clearData();

	return;
}

inline void TetraCubicInterpolator::TetraCubicSpline::makeInterpolator(std::vector<std::vector<double>>& A)
{
	std::vector<double> rhs(256);
	std::vector<double> ans(256);

	int row;

	for(int nx3 = 0; nx3 < 2; nx3 ++)
	{
		for(int nx2 = 0; nx2 < 2; nx2 ++)
		{
			for(int nx1 = 0; nx1 < 2; nx1 ++)
			{
				for(int nx0 = 0; nx0 < 2; nx0 ++)
				{
					row = nx3 * 8 + nx2 * 4 + nx1 * 2 + nx0;
					rhs[row] = f[nx0][nx1][nx2][nx3];
					rhs[row + 16 * 1] = fx0[nx0][nx1][nx2][nx3];
					rhs[row + 16 * 2] = fx1[nx0][nx1][nx2][nx3];
					rhs[row + 16 * 3] = fx2[nx0][nx1][nx2][nx3];
					rhs[row + 16 * 4] = fx3[nx0][nx1][nx2][nx3];
					rhs[row + 16 * 5] = fx0x1[nx0][nx1][nx2][nx3];
					rhs[row + 16 * 6] = fx0x2[nx0][nx1][nx2][nx3];
					rhs[row + 16 * 7] = fx0x3[nx0][nx1][nx2][nx3];
					rhs[row + 16 * 8] = fx1x2[nx0][nx1][nx2][nx3];
					rhs[row + 16 * 9] = fx1x3[nx0][nx1][nx2][nx3];
					rhs[row + 16 * 10] = fx2x3[nx0][nx1][nx2][nx3];
					rhs[row + 16 * 11] = fx0x1x2[nx0][nx1][nx2][nx3];
					rhs[row + 16 * 12] = fx0x1x3[nx0][nx1][nx2][nx3];
					rhs[row + 16 * 13] = fx0x2x3[nx0][nx1][nx2][nx3];
					rhs[row + 16 * 14] = fx1x2x3[nx0][nx1][nx2][nx3];
					rhs[row + 16 * 15] = fx0x1x2x3[nx0][nx1][nx2][nx3];
				}
			}
		}
	}

	#pragma omp parallel for
	for(int i = 0; i < rhs.size(); i ++)
	{
		ans[i] = 0.0;
		for(int j = 0; j < rhs.size(); j ++)
		{
			ans[i] += A[i][j] * rhs[j];
		}
	}

	a = std::vector<std::vector<std::vector<std::vector<double>>>>(4, std::vector<std::vector<std::vector<double>>>(4, std::vector<std::vector<double>>(4, std::vector<double>(4))));

	for(int nx3 = 0; nx3 < 4; nx3 ++)
	{
		for(int nx2 = 0; nx2 < 4; nx2 ++)
		{
			for(int nx1 = 0; nx1 < 4; nx1 ++)
			{
				for(int nx0 = 0; nx0 < 4; nx0 ++)
				{
					int idx = nx3 * 64 + nx2 * 16 + nx1 * 4 + nx0;
					a[nx0][nx1][nx2][nx3] = ans[idx];
				}
			}
		}
	}

	return;
}

inline double TetraCubicInterpolator::TetraCubicSpline::interpolation(double dx0, double dx1, double dx2, double dx3)
{
	double result = 0.0;

	//std::cout << x00 << ", " << x10 << ", " << x20 << ", " << x30 << ", " << x40 << std::flush;

	//std::cout << ", " << dx0 << ", " << dx1 << ", " << dx2 << ", " << dx3 << ", " << dx4 << std::endl << std::flush;

	auto pow = [](double v1, int v2)
	{
		if(v1 == 0 && v2 == 0)
		{
			return 1.0;
		}
		else if(v1 == 0)
		{
			return 0.0;
		}
		else if(v2 == 0)
		{
			return 1.0;
		}
		else
		{
			return std::pow(v1, double(v2));
		}
    };

	for(int i = 0; i < 4; i ++)
	{
		for(int j = 0; j < 4; j ++)
		{
			for(int k = 0; k < 4; k ++)
			{
				for(int l = 0; l < 4; l ++)
				{
					result += a[i][j][k][l] * pow(dx0, i) * pow(dx1, j) * pow(dx2, k) * pow(dx3, l);
				}
			}
		}
	}

	return result;
}

inline void TetraCubicInterpolator::TetraCubicSpline::makeInterpolator(void)
{
	std::vector<std::vector<double>> A = std::vector<std::vector<double>>(256, std::vector<double>(256));

	Dx0 = p[1][0][0][0][0] - p[0][0][0][0][0];
	Dx1 = p[0][1][0][0][1] - p[0][0][0][0][1];
	Dx2 = p[0][0][1][0][2] - p[0][0][0][0][2];
	Dx3 = p[0][0][0][1][3] - p[0][0][0][0][3];

	std::vector<double> rhs(256);

	auto pow = [](double v1, int v2)
	{
		if(v1 == 0 && v2 == 0)
		{
			return 1.0;
		}
		else if(v1 == 0)
		{
			return 0.0;
		}
		else if(v2 == 0)
		{
			return 1.0;
		}
		else
		{
			return std::pow(v1, double(v2));
		}
	};

	int row;

	for(int nx3 = 0; nx3 < 2; nx3 ++)
	{
		double dx3 = Dx3 * (double(nx3));

		for(int nx2 = 0; nx2 < 2; nx2 ++)
		{
			double dx2 = Dx2 * (double(nx2));
			
			for(int nx1 = 0; nx1 < 2; nx1 ++)
			{
				double dx1 = Dx1 * (double(nx1));

				for(int nx0 = 0; nx0 < 2; nx0 ++)
				{
					double dx0 = Dx0 * (double(nx0));

					int row = nx3 * 8 + nx2 * 4 + nx1 * 2 + nx0;

					for(int l = 0; l < 4; l ++)
					{
						for(int k = 0; k < 4; k ++)
						{
							for(int j = 0; j < 4; j ++)
							{
								for(int i = 0; i < 4; i ++)
								{
									int col = l * 64 + k * 16 + j * 4 + i;

									//f
									A[row][col] = pow(dx0, i) * pow(dx1, j) * pow(dx2, k) * pow(dx3, l);

									//fx
									if(i == 0)
									{
										A[row + 16 * 1][col] = 0.0;
									}
									else
									{
										A[row + 16 * 1][col] = double(i) * pow(dx0, i - 1) * pow(dx1, j) * pow(dx2, k) * pow(dx3, l);
									}

									if(j == 0)
									{
										A[row + 16 * 2][col] = 0.0;
									}
									else
									{
										A[row + 16 * 2][col] = double(j) * pow(dx0, i) * pow(dx1, j - 1) * pow(dx2, k) * pow(dx3, l);
									}

									if(k == 0)
									{
										A[row + 16 * 3][col] = 0.0;
									}
									else
									{
										A[row + 16 * 3][col] = double(k) * pow(dx0, i) * pow(dx1, j) * pow(dx2, k - 1) * pow(dx3, l);
									}

									if(l == 0)
									{
										A[row + 16 * 4][col] = 0.0;
									}
									else
									{
										A[row + 16 * 4][col] = double(l) * pow(dx0, i) * pow(dx1, j) * pow(dx2, k) * pow(dx3, l - 1);
									}

									//fxx
									if(i == 0 || j == 0)
									{
										A[row + 16 * 5][col] = 0.0;
									}
									else
									{
										A[row + 16 * 5][col] = double(i) * double(j) * pow(dx0, i - 1) * pow(dx1, j - 1) * pow(dx2, k) * pow(dx3, l);
									}

									if(i == 0 || k == 0)
									{
										A[row+ 16 * 6][col] = 0.0;
									}
									else
									{
										A[row+ 16 * 6][col] = double(i) * double(k) * pow(dx0, i - 1) * pow(dx1, j) * pow(dx2, k - 1) * pow(dx3, l);
									}

									if(i == 0 || l == 0)
									{
										A[row + 16 * 7][col] = 0.0;
									}
									else
									{
										A[row + 16 * 7][col] = double(i) * double(l) * pow(dx0, i - 1) * pow(dx1, j) * pow(dx2, k) * pow(dx3, l - 1);
									}

									if(j == 0 || k == 0)
									{
										A[row + 16 * 8][col] = 0.0;
									}
									else
									{
										A[row + 16 * 8][col] = double(j) * double(k) * pow(dx0, i) * pow(dx1, j - 1) * pow(dx2, k - 1) * pow(dx3, l);
									}

									if(j == 0 || l == 0)
									{
										A[row + 16 * 9][col] = 0.0;
									}
									else
									{
										A[row + 16 * 9][col] = double(j) * double(l) * pow(dx0, i) * pow(dx1, j - 1) * pow(dx2, k) * pow(dx3, l - 1);
									}

									if(k == 0 || l == 0)
									{
										A[row + 16 * 10][col] = 0.0;
									}
									else
									{
										A[row + 16 * 10][col] = double(k) * double(l) * pow(dx0, i) * pow(dx1, j) * pow(dx2, k - 1) * pow(dx3, l - 1);
									}

									//fxxx
									if(i == 0 || j == 0 || k == 0)
									{
										A[row + 16 * 11][col] = 0.0;
									}
									else
									{
										A[row + 16 * 11][col] = double(i) * double(j) * double(k) * pow(dx0, i - 1) * pow(dx1, j - 1) * pow(dx2, k - 1) * pow(dx3, l);
									}

									if(i == 0 || j == 0 || l == 0)
									{
										A[row + 16 * 12][col] = 0.0;
									}
									else
									{
										A[row + 16 * 12][col] = double(i) * double(j) * double(l) * pow(dx0, i - 1) * pow(dx1, j - 1) * pow(dx2, k) * pow(dx3, l - 1);
									}

									if(i == 0 || k == 0 || l == 0)
									{
										A[row + 16 * 13][col] = 0.0;
									}
									else
									{
										A[row + 16 * 13][col] = double(i) * double(k) * double(l) * pow(dx0, i - 1) * pow(dx1, j) * pow(dx2, k - 1) * pow(dx3, l - 1);
									}

									if(j == 0 || k == 0 || l == 0)
									{
										A[row + 16 * 14][col] = 0.0;
									}
									else
									{
										A[row + 16 * 14][col] = double(j) * double(k) * double(l) * pow(dx0, i) * pow(dx1, j - 1) * pow(dx2, k - 1) * pow(dx3, l - 1);
									}

									//fxxxx
									if(i == 0 || j == 0 || k == 0 || l == 0)
									{
										A[row + 16 * 15][col] = 0.0;
									}
									else
									{
										A[row + 16 * 15][col] = double(i) * double(j) * double(k) * double(l) * pow(dx0, i - 1) * pow(dx1, j - 1) * pow(dx2, k - 1) * pow(dx3, l - 1);
									}
								}
							}
						}
					}
				
					rhs[row] = f[nx0][nx1][nx2][nx3];
					rhs[row + 16 * 1] = fx0[nx0][nx1][nx2][nx3];
					rhs[row + 16 * 2] = fx1[nx0][nx1][nx2][nx3];
					rhs[row + 16 * 3] = fx2[nx0][nx1][nx2][nx3];
					rhs[row + 16 * 4] = fx3[nx0][nx1][nx2][nx3];
					rhs[row + 16 * 5] = fx0x1[nx0][nx1][nx2][nx3];
					rhs[row + 16 * 6] = fx0x2[nx0][nx1][nx2][nx3];
					rhs[row + 16 * 7] = fx0x3[nx0][nx1][nx2][nx3];
					rhs[row + 16 * 8] = fx1x2[nx0][nx1][nx2][nx3];
					rhs[row + 16 * 9] = fx1x3[nx0][nx1][nx2][nx3];
					rhs[row + 16 * 10] = fx2x3[nx0][nx1][nx2][nx3];
					rhs[row + 16 * 11] = fx0x1x2[nx0][nx1][nx2][nx3];
					rhs[row + 16 * 12] = fx0x1x3[nx0][nx1][nx2][nx3];
					rhs[row + 16 * 13] = fx0x2x3[nx0][nx1][nx2][nx3];
					rhs[row + 16 * 14] = fx1x2x3[nx0][nx1][nx2][nx3];
					rhs[row + 16 * 15] = fx0x1x2x3[nx0][nx1][nx2][nx3];
				}
			}
		}
	}

	invertMatrix(A, rhs);

	a = std::vector<std::vector<std::vector<std::vector<double>>>>(4, std::vector<std::vector<std::vector<double>>>(4, std::vector<std::vector<double>>(4, std::vector<double>(4))));

	for(int nx3 = 0; nx3 < 4; nx3 ++)
	{
		for(int nx2 = 0; nx2 < 4; nx2 ++)
		{
			for(int nx1 = 0; nx1 < 4; nx1 ++)
			{
				for(int nx0 = 0; nx0 < 4; nx0 ++)
				{
					int idx = nx3 * 64 + nx2 * 16 + nx1 * 4 + nx0;
					a[nx0][nx1][nx2][nx3] = rhs[idx];
				}
			}
		}
	}

	return;
}

inline double TetraCubicInterpolator::interpolation(double x00, double x10, double x20, double x30)
{
	double result = 0.0;

	int nx0 = 0;
	int nx1 = 0;
	int nx2 = 0;
	int nx3 = 0;

	for(int i = 0; i < x0.size() - 1; i ++)
	{
		if(x0[i] <= x00 && x00 <= x0[i + 1])
		{
			nx0 = i;
			break;
		}
	}
	for(int i = 0; i < x1.size() - 1; i ++)
	{
		if(x1[i] <= x10 && x10 <= x1[i + 1])
		{
			nx1 = i;
			break;
		}
	}
	for(int i = 0; i < x2.size() - 1; i ++)
	{
		if(x2[i] <= x20 && x20 <= x2[i + 1])
		{
			nx2 = i;
			break;
		}
	}
	for(int i = 0; i < x3.size() - 1; i ++)
	{
		if(x3[i] <= x30 && x30 <= x3[i + 1])
		{
			nx3 = i;
			break;
		}
	}

	// std::cout << nx0 << ", " << nx1 << ", " << nx2 << ", " << nx3 << ", " << nx4 << std::endl << std::flush;
	// std::cout << interval.size() << std::flush;
	// std::cout << ", " << interval[nx0].size() << std::flush;
	// std::cout << ", " << interval[nx0][nx1].size() << std::flush;
	// std::cout << ", " << interval[nx0][nx1][nx2].size() << std::flush;
	// std::cout << ", " << interval[nx0][nx1][nx2][nx3].size() << std::endl << std::flush;

	result = interval[nx0][nx1][nx2][nx3].interpolation(x00 - x0[nx0], x10 - x1[nx1], x20 - x2[nx2], x30 - x3[nx3]);

	return result;
}

inline double TetraCubicInterpolator::interpolation(std::vector<double> x0)
{
	return interpolation(x0[0], x0[1], x0[2], x0[3]);
}

inline void TetraCubicInterpolator::exportInterpolator(std::string filename)
{
	std::ofstream output(filename);

	//std::cout << x0.size() << ", " << x1.size() << ", " << x2.size() << ", " << x3.size() << ", " << x4.size() << std::endl;

	output << std::fixed << std::setprecision(20) << std::scientific << Double2Hex(x0[0]);
	for(int nx = 1; nx < x0.size(); nx ++)
	{
		output << std::fixed << std::setprecision(20) << std::scientific << ", " << Double2Hex(x0[nx]);
	}
	output << std::endl;
	output << std::fixed << std::setprecision(20) << std::scientific << Double2Hex(x1[0]);
	for(int nx = 1; nx < x1.size(); nx ++)
	{
		output << std::fixed << std::setprecision(20) << std::scientific << ", " << Double2Hex(x1[nx]);
	}
	output << std::endl;
	output << std::fixed << std::setprecision(20) << std::scientific << Double2Hex(x2[0]);
	for(int nx = 1; nx < x2.size(); nx ++)
	{
		output << std::fixed << std::setprecision(20) << std::scientific << ", " << Double2Hex(x2[nx]);
	}
	output << std::endl;
	output << std::fixed << std::setprecision(20) << std::scientific << Double2Hex(x3[0]);
	for(int nx = 1; nx < x3.size(); nx ++)
	{
		output << std::fixed << std::setprecision(20) << std::scientific << ", " << Double2Hex(x3[nx]);
	}
	output << std::endl;

	for(int nx0 = 0; nx0 < x0.size() - 1; nx0 ++)
	{
		for(int nx1 = 0; nx1 < x1.size() - 1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < x2.size() - 1; nx2 ++)
			{
				for(int nx3 = 0; nx3 < x3.size() - 1; nx3 ++)
				{
					output << std::dec << nx0 << ", " << nx1 << ", " << nx2 << ", " << nx3 << std::flush;

					for(int i = 0; i < 4; i ++)
					{
						for(int j = 0; j < 4; j ++)
						{
							for(int k = 0; k < 4; k ++)
							{
								for(int l = 0; l < 4; l ++)
								{
									output << std::fixed << std::setprecision(20) << std::scientific << ", " << Double2Hex(interval[nx0][nx1][nx2][nx3].a[i][j][k][l]) << std::flush;
								}
							}
						}
					}

					output << std::endl << std::flush;
				}
			}
		}
	}

	return;
}

inline void TetraCubicInterpolator::importInterpolator(std::string filename)
{
	std::ifstream input(filename);

	std::string str;
	std::vector<double> x0in, x1in, x2in, x3in;
	
	{
		std::getline(input, str);
		if(str[0] != '#' && str.size() > 0)
		{
			auto data = spritString(str, ',');
			for(int i = 0; i < data.size(); i ++)
			{
				x0in.push_back(Hex2Double(data[i]));
			}
		}
		std::getline(input, str);
		if(str[0] != '#' && str.size() > 0)
		{
			auto data = spritString(str, ',');
			for(int i = 0; i < data.size(); i ++)
			{
				x1in.push_back(Hex2Double(data[i]));
			}
		}
		std::getline(input, str);
		if(str[0] != '#' && str.size() > 0)
		{
			auto data = spritString(str, ',');
			for(int i = 0; i < data.size(); i ++)
			{
				x2in.push_back(Hex2Double(data[i]));
			}
		}
		std::getline(input, str);
		if(str[0] != '#' && str.size() > 0)
		{
			auto data = spritString(str, ',');
			for(int i = 0; i < data.size(); i ++)
			{
				x3in.push_back(Hex2Double(data[i]));
			}
		}
	}

	x0 = x0in;
	x1 = x1in;
	x2 = x2in;
	x3 = x3in;

	interval = std::vector<std::vector<std::vector<std::vector<TetraCubicSpline>>>>(x0.size() - 1, std::vector<std::vector<std::vector<TetraCubicSpline>>>(x1.size() - 1, std::vector<std::vector<TetraCubicSpline>>(x2.size() - 1, std::vector<TetraCubicSpline>(x3.size() - 1))));

	while(std::getline(input, str))
	{
		if(str[0] != '#' && str.size() > 0)
		{
			auto data = spritString(str, ',');
			
			int nx0 = std::stoi(data[0]);
			int nx1 = std::stoi(data[1]);
			int nx2 = std::stoi(data[2]);
			int nx3 = std::stoi(data[3]);

			interval[nx0][nx1][nx2][nx3].a = std::vector<std::vector<std::vector<std::vector<double>>>>(4, std::vector<std::vector<std::vector<double>>>(4, std::vector<std::vector<double>>(4, std::vector<double>(4))));
			for(int i = 0; i < 4; i ++)
			{
				for(int j = 0; j < 4; j ++)
				{
					for(int k = 0; k < 4; k ++)
					{
						for(int l = 0; l < 4; l ++)
						{
							int idx = 4 + i * 64 + j * 16 + k * 4 + l;
							interval[nx0][nx1][nx2][nx3].a[i][j][k][l] = Hex2Double(data[idx]);
						}
					}
				}
			}
			interval[nx0][nx1][nx2][nx3].p = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(4)))));
			for(int i = 0; i < 2; i ++)
			{
				for(int j = 0; j < 2; j ++)
				{
					for(int k = 0; k < 2; k ++)
					{
						for(int l = 0; l < 2; l ++)
						{
							interval[nx0][nx1][nx2][nx3].p[i][j][k][l] = {x0[nx0 + i], x1[nx1 + j], x2[nx2 + k], x3[nx3 + l]};
						}
					}
				}
			}
		}
	}

	return;
}

inline void TetraCubicInterpolator::initialization(void)
{
	f = std::vector<std::vector<std::vector<std::vector<double>>>>(x0.size(), std::vector<std::vector<std::vector<double>>>(x1.size(), std::vector<std::vector<double>>(x2.size(), std::vector<double>(x3.size()))));

	return;
}

inline void TetraCubicInterpolator::clear(void)
{
	f.clear();
	fx0.clear();
	fx1.clear();
	fx2.clear();
	fx3.clear();
	fx0x1.clear();
	fx0x2.clear();
	fx0x3.clear();
	fx1x2.clear();
	fx1x3.clear();
	fx2x3.clear();
	fx0x1x2.clear();
	fx0x1x3.clear();
	fx0x2x3.clear();
	fx1x2x3.clear();
	fx0x1x2x3.clear();

	interval.clear();
	A.clear();

	return;
}

inline void TetraCubicInterpolator::clearData(void)
{
	f.clear();
	fx0.clear();
	fx1.clear();
	fx2.clear();
	fx3.clear();
	fx0x1.clear();
	fx0x2.clear();
	fx0x3.clear();
	fx1x2.clear();
	fx1x3.clear();
	fx2x3.clear();
	fx0x1x2.clear();
	fx0x1x3.clear();
	fx0x2x3.clear();
	fx1x2x3.clear();
	fx0x1x2x3.clear();

	for(int nx0 = 0; nx0 < interval.size(); nx0 ++)
	{
		for(int nx1 = 0; nx1 < interval[nx0].size(); nx1 ++)
		{
			for(int nx2 = 0; nx2 < interval[nx0][nx1].size(); nx2 ++)
			{
				for(int nx3 = 0; nx3 < interval[nx0][nx1][nx2].size(); nx3 ++)
				{
					interval[nx0][nx1][nx2][nx3].clearData();
				}
			}
		}
	}

	A.clear();

	return;
}

inline void TetraCubicInterpolator::TetraCubicSpline::clearData(void)
{
	f.clear();
	p.clear();
	fx0.clear();
	fx1.clear();
	fx2.clear();
	fx3.clear();
	fx0x1.clear();
	fx0x2.clear();
	fx0x3.clear();
	fx1x2.clear();
	fx1x3.clear();
	fx2x3.clear();
	fx0x1x2.clear();
	fx0x1x3.clear();
	fx0x2x3.clear();
	fx1x2x3.clear();
	fx0x1x2x3.clear();

	return;
}

inline void PentaCubicInterpolator::makeInterpolator(void)
{
	int Nx0 = x0.size();
	int Nx1 = x1.size();
	int Nx2 = x2.size();
	int Nx3 = x3.size();
	int Nx4 = x4.size();

	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_x0 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx1, std::vector<std::vector<std::vector<Spline>>>(Nx2, std::vector<std::vector<Spline>>(Nx3, std::vector<Spline>(Nx4))));
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_x1 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx2, std::vector<std::vector<Spline>>(Nx3, std::vector<Spline>(Nx4))));
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_x2 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx3, std::vector<Spline>(Nx4))));
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_x3 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx4))));
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_x4 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx3))));

	//MakeSpline spline_x0
	for(int nx1 = 0; nx1 < Nx1; nx1 ++)
	{
		for(int nx2 = 0; nx2 < Nx2; nx2 ++)
		{
			for(int nx3 = 0; nx3 < Nx3; nx3 ++)
			{
				for(int nx4 = 0; nx4 < Nx4; nx4 ++)
				{
					for(int nx0 = 0; nx0 < Nx0; nx0 ++)
					{
						spline_x0[nx1][nx2][nx3][nx4].x.push_back(x0[nx0]);
						spline_x0[nx1][nx2][nx3][nx4].f.push_back(f[nx0][nx1][nx2][nx3][nx4]);
					}
					if(spline_type[0] == SPLINE_TYPE::NATURAL)
					{
						spline_x0[nx1][nx2][nx3][nx4].makeNaturalSpline();
					}
					else if(spline_type[0] == SPLINE_TYPE::CLAMPED)
					{
						spline_x0[nx1][nx2][nx3][nx4].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_x1
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx2 = 0; nx2 < Nx2; nx2 ++)
		{
			for(int nx3 = 0; nx3 < Nx3; nx3 ++)
			{
				for(int nx4 = 0; nx4 < Nx4; nx4 ++)
				{
					for(int nx1 = 0; nx1 < Nx1; nx1 ++)
					{
						spline_x1[nx0][nx2][nx3][nx4].x.push_back(x1[nx1]);
						spline_x1[nx0][nx2][nx3][nx4].f.push_back(f[nx0][nx1][nx2][nx3][nx4]);
					}
					if(spline_type[1] == SPLINE_TYPE::NATURAL)
					{
						spline_x1[nx0][nx2][nx3][nx4].makeNaturalSpline();
					}
					else if(spline_type[1] == SPLINE_TYPE::CLAMPED)
					{
						spline_x1[nx0][nx2][nx3][nx4].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_x2
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx3 = 0; nx3 < Nx3; nx3 ++)
			{
				for(int nx4 = 0; nx4 < Nx4; nx4 ++)
				{
					for(int nx2 = 0; nx2 < Nx2; nx2 ++)
					{
						spline_x2[nx0][nx1][nx3][nx4].x.push_back(x2[nx2]);
						spline_x2[nx0][nx1][nx3][nx4].f.push_back(f[nx0][nx1][nx2][nx3][nx4]);
					}
					if(spline_type[2] == SPLINE_TYPE::NATURAL)
					{
						spline_x2[nx0][nx1][nx3][nx4].makeNaturalSpline();
					}
					else if(spline_type[2] == SPLINE_TYPE::CLAMPED)
					{
						spline_x2[nx0][nx1][nx3][nx4].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_x3
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx4 = 0; nx4 < Nx4; nx4 ++)
				{
					for(int nx3 = 0; nx3 < Nx3; nx3 ++)
					{
						spline_x3[nx0][nx1][nx2][nx4].x.push_back(x3[nx3]);
						spline_x3[nx0][nx1][nx2][nx4].f.push_back(f[nx0][nx1][nx2][nx3][nx4]);
					}
					if(spline_type[3] == SPLINE_TYPE::NATURAL)
					{
						spline_x3[nx0][nx1][nx2][nx4].makeNaturalSpline();
					}
					else if(spline_type[3] == SPLINE_TYPE::CLAMPED)
					{
						spline_x3[nx0][nx1][nx2][nx4].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_x4
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					for(int nx4 = 0; nx4 < Nx4; nx4 ++)
					{
						spline_x4[nx0][nx1][nx2][nx3].x.push_back(x4[nx4]);
						spline_x4[nx0][nx1][nx2][nx3].f.push_back(f[nx0][nx1][nx2][nx3][nx4]);
					}
					if(spline_type[4] == SPLINE_TYPE::NATURAL)
					{
						spline_x4[nx0][nx1][nx2][nx3].makeNaturalSpline();
					}
					else if(spline_type[4] == SPLINE_TYPE::CLAMPED)
					{
						spline_x4[nx0][nx1][nx2][nx3].makeClampedSpline();
					}
				}
			}
		}
	}

	//Derive fx0, fx1, fx2, fx3, fx4
	fx0 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx1 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx2 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx3 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));

	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					for(int nx4 = 0; nx4 < Nx4; nx4 ++)
					{
						if(nx0 != Nx0 - 1)
						{
							fx0[nx0][nx1][nx2][nx3][nx4] = spline_x0[nx1][nx2][nx3][nx4].c[nx0];
						}
						else
						{
							double Dx0 = x0[Nx0 - 1] - x0[Nx0 - 2];
							fx0[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_x0[nx1][nx2][nx3][nx4].a[nx0 - 1] * Dx0 * Dx0 + 2.0 * spline_x0[nx1][nx2][nx3][nx4].b[nx0 - 1] * Dx0 + spline_x0[nx1][nx2][nx3][nx4].c[nx0 - 1];
						}

						if(nx1 != Nx1 - 1)
						{
							fx1[nx0][nx1][nx2][nx3][nx4] = spline_x1[nx0][nx2][nx3][nx4].c[nx1];
						}
						else
						{
							double Dx1 = x1[Nx1 - 1] - x1[Nx1 - 2];
							fx1[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_x1[nx0][nx2][nx3][nx4].a[nx1 - 1] * Dx1 * Dx1 + 2.0 * spline_x1[nx0][nx2][nx3][nx4].b[nx1 - 1] * Dx1 + spline_x1[nx0][nx2][nx3][nx4].c[nx1 - 1];
						}

						if(nx2 != Nx2 - 1)
						{
							fx2[nx0][nx1][nx2][nx3][nx4] = spline_x2[nx0][nx1][nx3][nx4].c[nx2];
						}
						else
						{
							double Dx2 = x2[Nx2 - 1] - x2[Nx2 - 2];
							fx2[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_x2[nx0][nx1][nx3][nx4].a[nx2 - 1] * Dx2 * Dx2 + 2.0 * spline_x2[nx0][nx1][nx3][nx4].b[nx2 - 1] * Dx2 + spline_x2[nx0][nx1][nx3][nx4].c[nx2 - 1];
						}

						if(nx3 != Nx3 - 1)
						{
							fx3[nx0][nx1][nx2][nx3][nx4] = spline_x3[nx0][nx1][nx2][nx4].c[nx3];
						}
						else
						{
							double Dx3 = x3[Nx3 - 1] - x3[Nx3 - 2];
							fx3[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_x3[nx0][nx1][nx2][nx4].a[nx3 - 1] * Dx3 * Dx3 + 2.0 * spline_x3[nx0][nx1][nx2][nx4].b[nx3 - 1] * Dx3 + spline_x3[nx0][nx1][nx2][nx4].c[nx3 - 1];
						}

						if(nx4 != Nx4 - 1)
						{
							fx4[nx0][nx1][nx2][nx3][nx4] = spline_x4[nx0][nx1][nx2][nx3].c[nx4];
						}
						else
						{
							double Dx4 = x4[Nx4 - 1] - x4[Nx4 - 2];
							fx4[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_x4[nx0][nx1][nx2][nx3].a[nx4 - 1] * Dx4 * Dx4 + 2.0 * spline_x4[nx0][nx1][nx2][nx3].b[nx4 - 1] * Dx4 + spline_x4[nx0][nx1][nx2][nx3].c[nx4 - 1];
						}
					}
				}
			}
		}
	}

	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx0_x1 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx2, std::vector<std::vector<Spline>>(Nx3, std::vector<Spline>(Nx4))));	// for fx0x1
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx0_x2 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx3, std::vector<Spline>(Nx4))));	// for fx0x2
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx0_x3 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx4))));	// for fx0x3
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx0_x4 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx3))));	// for fx0x4
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx1_x2 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx3, std::vector<Spline>(Nx4))));	// for fx1x2
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx1_x3 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx4))));	// for fx1x3
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx1_x4 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx3))));	// for fx1x4
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx2_x3 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx4))));	// for fx2x3
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx2_x4 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx3))));	// for fx2x4
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx3_x4 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx3))));	// for fx3x4

	//MakeSpline spline_dx0_x1
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx2 = 0; nx2 < Nx2; nx2 ++)
		{
			for(int nx3 = 0; nx3 < Nx3; nx3 ++)
			{
				for(int nx4 = 0; nx4 < Nx4; nx4 ++)
				{
					for(int nx1 = 0; nx1 < Nx1; nx1 ++)
					{
						spline_dx0_x1[nx0][nx2][nx3][nx4].x.push_back(x1[nx1]);
						spline_dx0_x1[nx0][nx2][nx3][nx4].f.push_back(fx0[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[1] == SPLINE_TYPE::NATURAL)
					{
						spline_dx0_x1[nx0][nx2][nx3][nx4].makeNaturalSpline();
					}
					else if(spline_type[1] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx0_x1[nx0][nx2][nx3][nx4].makeClampedSpline();
					}
				}
			}
		}
	}
	
	//MakeSpline spline_dx0_x2
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx3 = 0; nx3 < Nx3; nx3 ++)
			{
				for(int nx4 = 0; nx4 < Nx4; nx4 ++)
				{
					for(int nx2 = 0; nx2 < Nx2; nx2 ++)
					{
						spline_dx0_x2[nx0][nx1][nx3][nx4].x.push_back(x2[nx2]);
						spline_dx0_x2[nx0][nx1][nx3][nx4].f.push_back(fx0[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[2] == SPLINE_TYPE::NATURAL)
					{
						spline_dx0_x2[nx0][nx1][nx3][nx4].makeNaturalSpline();
					}
					else if(spline_type[2] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx0_x2[nx0][nx1][nx3][nx4].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_dx0_x3
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx4 = 0; nx4 < Nx4; nx4 ++)
				{
					for(int nx3 = 0; nx3 < Nx3; nx3 ++)
					{
						spline_dx0_x3[nx0][nx1][nx2][nx4].x.push_back(x3[nx3]);
						spline_dx0_x3[nx0][nx1][nx2][nx4].f.push_back(fx0[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[3] == SPLINE_TYPE::NATURAL)
					{
						spline_dx0_x3[nx0][nx1][nx2][nx4].makeNaturalSpline();
					}
					else if(spline_type[3] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx0_x3[nx0][nx1][nx2][nx4].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_dx0_x4
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					for(int nx4 = 0; nx4 < Nx4; nx4 ++)
					{
						spline_dx0_x4[nx0][nx1][nx2][nx3].x.push_back(x4[nx4]);
						spline_dx0_x4[nx0][nx1][nx2][nx3].f.push_back(fx0[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[4] == SPLINE_TYPE::NATURAL)
					{
						spline_dx0_x4[nx0][nx1][nx2][nx3].makeNaturalSpline();
					}
					else if(spline_type[4] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx0_x4[nx0][nx1][nx2][nx3].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_dx1_x2
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx3 = 0; nx3 < Nx3; nx3 ++)
			{
				for(int nx4 = 0; nx4 < Nx4; nx4 ++)
				{
					for(int nx2 = 0; nx2 < Nx2; nx2 ++)
					{
						spline_dx1_x2[nx0][nx1][nx3][nx4].x.push_back(x2[nx2]);
						spline_dx1_x2[nx0][nx1][nx3][nx4].f.push_back(fx1[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[2] == SPLINE_TYPE::NATURAL)
					{
						spline_dx1_x2[nx0][nx1][nx3][nx4].makeNaturalSpline();
					}
					else if(spline_type[2] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx1_x2[nx0][nx1][nx3][nx4].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_dx1_x3
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx4 = 0; nx4 < Nx4; nx4 ++)
				{
					for(int nx3 = 0; nx3 < Nx3; nx3 ++)
					{
						spline_dx1_x3[nx0][nx1][nx2][nx4].x.push_back(x3[nx3]);
						spline_dx1_x3[nx0][nx1][nx2][nx4].f.push_back(fx1[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[3] == SPLINE_TYPE::NATURAL)
					{
						spline_dx1_x3[nx0][nx1][nx2][nx4].makeNaturalSpline();
					}
					else if(spline_type[3] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx1_x3[nx0][nx1][nx2][nx4].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_dx1_x4
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					for(int nx4 = 0; nx4 < Nx4; nx4 ++)
					{
						spline_dx1_x4[nx0][nx1][nx2][nx3].x.push_back(x4[nx4]);
						spline_dx1_x4[nx0][nx1][nx2][nx3].f.push_back(fx1[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[4] == SPLINE_TYPE::NATURAL)
					{
						spline_dx1_x4[nx0][nx1][nx2][nx3].makeNaturalSpline();
					}
					else if(spline_type[4] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx1_x4[nx0][nx1][nx2][nx3].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_dx2_x3
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx4 = 0; nx4 < Nx4; nx4 ++)
				{
					for(int nx3 = 0; nx3 < Nx3; nx3 ++)
					{
						spline_dx2_x3[nx0][nx1][nx2][nx4].x.push_back(x3[nx3]);
						spline_dx2_x3[nx0][nx1][nx2][nx4].f.push_back(fx2[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[3] == SPLINE_TYPE::NATURAL)
					{
						spline_dx2_x3[nx0][nx1][nx2][nx4].makeNaturalSpline();
					}
					else if(spline_type[3] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx2_x3[nx0][nx1][nx2][nx4].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_dx2_x4
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					for(int nx4 = 0; nx4 < Nx4; nx4 ++)
					{
						spline_dx2_x4[nx0][nx1][nx2][nx3].x.push_back(x4[nx4]);
						spline_dx2_x4[nx0][nx1][nx2][nx3].f.push_back(fx2[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[4] == SPLINE_TYPE::NATURAL)
					{
						spline_dx2_x4[nx0][nx1][nx2][nx3].makeNaturalSpline();
					}
					else if(spline_type[4] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx2_x4[nx0][nx1][nx2][nx3].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_dx3_x4
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					for(int nx4 = 0; nx4 < Nx4; nx4 ++)
					{
						spline_dx3_x4[nx0][nx1][nx2][nx3].x.push_back(x4[nx4]);
						spline_dx3_x4[nx0][nx1][nx2][nx3].f.push_back(fx3[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[4] == SPLINE_TYPE::NATURAL)
					{
						spline_dx3_x4[nx0][nx1][nx2][nx3].makeNaturalSpline();
					}
					else if(spline_type[4] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx3_x4[nx0][nx1][nx2][nx3].makeClampedSpline();
					}
				}
			}
		}
	}


	fx0x1 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx0x2 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx0x3 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx0x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx1x2 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx1x3 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx1x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx2x3 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx2x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx3x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));

	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					for(int nx4 = 0; nx4 < Nx4; nx4 ++)
					{
						if(nx1 != Nx1 - 1)
						{
							fx0x1[nx0][nx1][nx2][nx3][nx4] = spline_dx0_x1[nx0][nx2][nx3][nx4].c[nx1];
						}
						else
						{
							double Dx1 = x1[Nx1 - 1] - x1[Nx1 - 2];
							fx0x1[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx0_x1[nx0][nx2][nx3][nx4].a[nx1 - 1] * Dx1 * Dx1 + 2.0 * spline_dx0_x1[nx0][nx2][nx3][nx4].b[nx1 - 1] * Dx1 + spline_dx0_x1[nx0][nx2][nx3][nx4].c[nx1 - 1];
						}

						if(nx2 != Nx2 - 1)
						{
							fx0x2[nx0][nx1][nx2][nx3][nx4] = spline_dx0_x2[nx0][nx1][nx3][nx4].c[nx2];
						}
						else
						{
							double Dx2 = x2[Nx2 - 1] - x2[Nx2 - 2];
							fx0x2[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx0_x2[nx0][nx1][nx3][nx4].a[nx2 - 1] * Dx2 * Dx2 + 2.0 * spline_dx0_x2[nx0][nx1][nx3][nx4].b[nx2 - 1] * Dx2 + spline_dx0_x2[nx0][nx1][nx3][nx4].c[nx2 - 1];
						}

						if(nx3 != Nx3 - 1)
						{
							fx0x3[nx0][nx1][nx2][nx3][nx4] = spline_dx0_x3[nx0][nx1][nx2][nx4].c[nx3];
						}
						else
						{
							double Dx3 = x3[Nx3 - 1] - x3[Nx3 - 2];
							fx0x3[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx0_x3[nx0][nx1][nx2][nx4].a[nx3 - 1] * Dx3 * Dx3 + 2.0 * spline_dx0_x3[nx0][nx1][nx2][nx4].b[nx3 - 1] * Dx3 + spline_dx0_x3[nx0][nx1][nx2][nx4].c[nx3 - 1];
						}

						if(nx4 != Nx4 - 1)
						{
							fx0x4[nx0][nx1][nx2][nx3][nx4] = spline_dx0_x4[nx0][nx1][nx2][nx3].c[nx4];
						}
						else
						{
							double Dx4 = x4[Nx4 - 1] - x4[Nx4 - 2];
							fx0x4[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx0_x4[nx0][nx1][nx2][nx3].a[nx4 - 1] * Dx4 * Dx4 + 2.0 * spline_dx0_x4[nx0][nx1][nx2][nx3].b[nx4 - 1] * Dx4 + spline_dx0_x4[nx0][nx1][nx2][nx3].c[nx4 - 1];
						}

						if(nx2 != Nx2 - 1)
						{
							fx1x2[nx0][nx1][nx2][nx3][nx4] = spline_dx1_x2[nx0][nx1][nx3][nx4].c[nx2];
						}
						else
						{
							double Dx2 = x2[Nx2 - 1] - x2[Nx2 - 2];
							fx1x2[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx1_x2[nx0][nx1][nx3][nx4].a[nx2 - 1] * Dx2 * Dx2 + 2.0 * spline_dx1_x2[nx0][nx1][nx3][nx4].b[nx2 - 1] * Dx2 + spline_dx1_x2[nx0][nx1][nx3][nx4].c[nx2 - 1];
						}

						if(nx3 != Nx3 - 1)
						{
							fx1x3[nx0][nx1][nx2][nx3][nx4] = spline_dx1_x3[nx0][nx1][nx2][nx4].c[nx3];
						}
						else
						{
							double Dx3 = x3[Nx3 - 1] - x3[Nx3 - 2];
							fx1x3[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx1_x3[nx0][nx1][nx2][nx4].a[nx3 - 1] * Dx3 * Dx3 + 2.0 * spline_dx1_x3[nx0][nx1][nx2][nx4].b[nx3 - 1] * Dx3 + spline_dx1_x3[nx0][nx1][nx2][nx4].c[nx3 - 1];
						}

						if(nx4 != Nx4 - 1)
						{
							fx1x4[nx0][nx1][nx2][nx3][nx4] = spline_dx1_x4[nx0][nx1][nx2][nx3].c[nx4];
						}
						else
						{
							double Dx4 = x4[Nx4 - 1] - x4[Nx4 - 2];
							fx1x4[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx1_x4[nx0][nx1][nx2][nx3].a[nx4 - 1] * Dx4 * Dx4 + 2.0 * spline_dx1_x4[nx0][nx1][nx2][nx3].b[nx4 - 1] * Dx4 + spline_dx1_x4[nx0][nx1][nx2][nx3].c[nx4 - 1];
						}

						if(nx3 != Nx3 - 1)
						{
							fx2x3[nx0][nx1][nx2][nx3][nx4] = spline_dx2_x3[nx0][nx1][nx2][nx4].c[nx3];
						}
						else
						{
							double Dx3 = x3[Nx3 - 1] - x3[Nx3 - 2];
							fx2x3[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx2_x3[nx0][nx1][nx2][nx4].a[nx3 - 1] * Dx3 * Dx3 + 2.0 * spline_dx2_x3[nx0][nx1][nx2][nx4].b[nx3 - 1] * Dx3 + spline_dx2_x3[nx0][nx1][nx2][nx4].c[nx3 - 1];
						}

						if(nx4 != Nx4 - 1)
						{
							fx2x4[nx0][nx1][nx2][nx3][nx4] = spline_dx2_x4[nx0][nx1][nx2][nx3].c[nx4];
						}
						else
						{
							double Dx4 = x4[Nx4 - 1] - x4[Nx4 - 2];
							fx2x4[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx2_x4[nx0][nx1][nx2][nx3].a[nx4 - 1] * Dx4 * Dx4 + 2.0 * spline_dx2_x4[nx0][nx1][nx2][nx3].b[nx4 - 1] * Dx4 + spline_dx2_x4[nx0][nx1][nx2][nx3].c[nx4 - 1];
						}

						if(nx4 != Nx4 - 1)
						{
							fx3x4[nx0][nx1][nx2][nx3][nx4] = spline_dx3_x4[nx0][nx1][nx2][nx3].c[nx4];
						}
						else
						{
							double Dx4 = x4[Nx4 - 1] - x4[Nx4 - 2];
							fx3x4[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx3_x4[nx0][nx1][nx2][nx3].a[nx4 - 1] * Dx4 * Dx4 + 2.0 * spline_dx3_x4[nx0][nx1][nx2][nx3].b[nx4 - 1] * Dx4 + spline_dx3_x4[nx0][nx1][nx2][nx3].c[nx4 - 1];
						}
					}
				}
			}
		}
	}

	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx0dx1_x2 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx3, std::vector<Spline>(Nx4))));	// for fx0x1x2
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx0dx1_x3 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx4))));	// for fx0x1x3
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx0dx1_x4 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx3))));	// for fx0x1x4
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx0dx2_x3 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx4))));	// for fx0x2x3
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx0dx2_x4 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx3))));	// for fx0x2x4
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx0dx3_x4 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx3))));	// for fx0x3x4
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx1dx2_x3 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx4))));	// for fx1x2x3
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx1dx2_x4 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx3))));	// for fx1x2x4
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx1dx3_x4 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx3))));	// for fx1x3x4
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx2dx3_x4 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx3))));	// for fx2x3x4

	//MakeSpline spline_dx0dx1_x2
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx3 = 0; nx3 < Nx3; nx3 ++)
			{
				for(int nx4 = 0; nx4 < Nx4; nx4 ++)
				{
					for(int nx2 = 0; nx2 < Nx2; nx2 ++)
					{
						spline_dx0dx1_x2[nx0][nx1][nx3][nx4].x.push_back(x2[nx2]);
						spline_dx0dx1_x2[nx0][nx1][nx3][nx4].f.push_back(fx0x1[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[2] == SPLINE_TYPE::NATURAL)
					{
						spline_dx0dx1_x2[nx0][nx1][nx3][nx4].makeNaturalSpline();
					}
					else if(spline_type[2] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx0dx1_x2[nx0][nx1][nx3][nx4].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_dx0dx1_x3
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx4 = 0; nx4 < Nx4; nx4 ++)
				{
					for(int nx3 = 0; nx3 < Nx3; nx3 ++)
					{
						spline_dx0dx1_x3[nx0][nx1][nx2][nx4].x.push_back(x3[nx3]);
						spline_dx0dx1_x3[nx0][nx1][nx2][nx4].f.push_back(fx0x1[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[3] == SPLINE_TYPE::NATURAL)
					{
						spline_dx0dx1_x3[nx0][nx1][nx2][nx4].makeNaturalSpline();
					}
					else if(spline_type[3] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx0dx1_x3[nx0][nx1][nx2][nx4].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_dx0dx1_x4
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					for(int nx4 = 0; nx4 < Nx4; nx4 ++)
					{
						spline_dx0dx1_x4[nx0][nx1][nx2][nx3].x.push_back(x4[nx4]);
						spline_dx0dx1_x4[nx0][nx1][nx2][nx3].f.push_back(fx0x1[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[4] == SPLINE_TYPE::NATURAL)
					{
						spline_dx0dx1_x4[nx0][nx1][nx2][nx3].makeNaturalSpline();
					}
					else if(spline_type[4] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx0dx1_x4[nx0][nx1][nx2][nx3].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_dx0dx2_x3
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx4 = 0; nx4 < Nx4; nx4 ++)
				{
					for(int nx3 = 0; nx3 < Nx3; nx3 ++)
					{
						spline_dx0dx2_x3[nx0][nx1][nx2][nx4].x.push_back(x3[nx3]);
						spline_dx0dx2_x3[nx0][nx1][nx2][nx4].f.push_back(fx0x2[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[3] == SPLINE_TYPE::NATURAL)
					{
						spline_dx0dx2_x3[nx0][nx1][nx2][nx4].makeNaturalSpline();
					}
					else if(spline_type[3] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx0dx2_x3[nx0][nx1][nx2][nx4].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_dx0dx2_x4
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					for(int nx4 = 0; nx4 < Nx4; nx4 ++)
					{
						spline_dx0dx2_x4[nx0][nx1][nx2][nx3].x.push_back(x4[nx4]);
						spline_dx0dx2_x4[nx0][nx1][nx2][nx3].f.push_back(fx0x2[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[4] == SPLINE_TYPE::NATURAL)
					{
						spline_dx0dx2_x4[nx0][nx1][nx2][nx3].makeNaturalSpline();
					}
					else if(spline_type[4] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx0dx2_x4[nx0][nx1][nx2][nx3].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_dx0dx3_x4
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					for(int nx4 = 0; nx4 < Nx4; nx4 ++)
					{
						spline_dx0dx3_x4[nx0][nx1][nx2][nx3].x.push_back(x4[nx4]);
						spline_dx0dx3_x4[nx0][nx1][nx2][nx3].f.push_back(fx0x3[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[4] == SPLINE_TYPE::NATURAL)
					{
						spline_dx0dx3_x4[nx0][nx1][nx2][nx3].makeNaturalSpline();
					}
					else if(spline_type[4] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx0dx3_x4[nx0][nx1][nx2][nx3].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_dx1dx2_x3
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx4 = 0; nx4 < Nx4; nx4 ++)
				{
					for(int nx3 = 0; nx3 < Nx3; nx3 ++)
					{
						spline_dx1dx2_x3[nx0][nx1][nx2][nx4].x.push_back(x3[nx3]);
						spline_dx1dx2_x3[nx0][nx1][nx2][nx4].f.push_back(fx1x2[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[3] == SPLINE_TYPE::NATURAL)
					{
						spline_dx1dx2_x3[nx0][nx1][nx2][nx4].makeNaturalSpline();
					}
					else if(spline_type[3] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx1dx2_x3[nx0][nx1][nx2][nx4].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_dx1dx2_x4
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					for(int nx4 = 0; nx4 < Nx4; nx4 ++)
					{
						spline_dx1dx2_x4[nx0][nx1][nx2][nx3].x.push_back(x4[nx4]);
						spline_dx1dx2_x4[nx0][nx1][nx2][nx3].f.push_back(fx1x2[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[4] == SPLINE_TYPE::NATURAL)
					{
						spline_dx1dx2_x4[nx0][nx1][nx2][nx3].makeNaturalSpline();
					}
					else if(spline_type[4] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx1dx2_x4[nx0][nx1][nx2][nx3].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_dx1dx3_x4
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					for(int nx4 = 0; nx4 < Nx4; nx4 ++)
					{
						spline_dx1dx3_x4[nx0][nx1][nx2][nx3].x.push_back(x4[nx4]);
						spline_dx1dx3_x4[nx0][nx1][nx2][nx3].f.push_back(fx1x3[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[4] == SPLINE_TYPE::NATURAL)
					{
						spline_dx1dx3_x4[nx0][nx1][nx2][nx3].makeNaturalSpline();
					}
					else if(spline_type[4] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx1dx3_x4[nx0][nx1][nx2][nx3].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_dx2dx3_x4
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					for(int nx4 = 0; nx4 < Nx4; nx4 ++)
					{
						spline_dx2dx3_x4[nx0][nx1][nx2][nx3].x.push_back(x4[nx4]);
						spline_dx2dx3_x4[nx0][nx1][nx2][nx3].f.push_back(fx2x3[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[4] == SPLINE_TYPE::NATURAL)
					{
						spline_dx2dx3_x4[nx0][nx1][nx2][nx3].makeNaturalSpline();
					}
					else if(spline_type[4] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx2dx3_x4[nx0][nx1][nx2][nx3].makeClampedSpline();
					}
				}
			}
		}
	}
	
	fx0x1x2 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx0x1x3 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx0x1x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx0x2x3 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx0x2x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx0x3x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx1x2x3 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx1x2x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx1x3x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx2x3x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));

	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					for(int nx4 = 0; nx4 < Nx4; nx4 ++)
					{
						if(nx2 != Nx2 - 1)
						{
							fx0x1x2[nx0][nx1][nx2][nx3][nx4] = spline_dx0dx1_x2[nx0][nx1][nx3][nx4].c[nx2];
						}
						else
						{
							double Dx2 = x2[Nx2 - 1] - x2[Nx2 - 2];
							fx0x1x2[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx0dx1_x2[nx0][nx1][nx3][nx4].a[nx2 - 1] * Dx2 * Dx2 + 2.0 * spline_dx0dx1_x2[nx0][nx1][nx3][nx4].b[nx2 - 1] * Dx2 + spline_dx0dx1_x2[nx0][nx1][nx3][nx4].c[nx2 - 1];
						}

						if(nx3 != Nx3 - 1)
						{
							fx0x1x3[nx0][nx1][nx2][nx3][nx4] = spline_dx0dx1_x3[nx0][nx1][nx2][nx4].c[nx3];
						}
						else
						{
							double Dx3 = x3[Nx3 - 1] - x3[Nx3 - 2];
							fx0x1x3[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx0dx1_x3[nx0][nx1][nx2][nx4].a[nx3 - 1] * Dx3 * Dx3 + 2.0 * spline_dx0dx1_x3[nx0][nx1][nx2][nx4].b[nx3 - 1] * Dx3 + spline_dx0dx1_x3[nx0][nx1][nx2][nx4].c[nx3 - 1];
						}

						if(nx4 != Nx4 - 1)
						{
							fx0x1x4[nx0][nx1][nx2][nx3][nx4] = spline_dx0dx1_x4[nx0][nx1][nx2][nx3].c[nx4];
						}
						else
						{
							double Dx4 = x4[Nx4 - 1] - x4[Nx4 - 2];
							fx0x1x4[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx0dx1_x4[nx0][nx1][nx2][nx3].a[nx4 - 1] * Dx4 * Dx4 + 2.0 * spline_dx0dx1_x4[nx0][nx1][nx2][nx3].b[nx4 - 1] * Dx4 + spline_dx0dx1_x4[nx0][nx1][nx2][nx3].c[nx4 - 1];
						}

						if(nx3 != Nx3 - 1)
						{
							fx0x2x3[nx0][nx1][nx2][nx3][nx4] = spline_dx0dx2_x3[nx0][nx1][nx2][nx4].c[nx3];
						}
						else
						{
							double Dx3 = x3[Nx3 - 1] - x3[Nx3 - 2];
							fx0x2x3[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx0dx2_x3[nx0][nx1][nx2][nx4].a[nx3 - 1] * Dx3 * Dx3 + 2.0 * spline_dx0dx2_x3[nx0][nx1][nx2][nx4].b[nx3 - 1] * Dx3 + spline_dx0dx2_x3[nx0][nx1][nx2][nx4].c[nx3 - 1];
						}

						if(nx4 != Nx4 - 1)
						{
							fx0x2x4[nx0][nx1][nx2][nx3][nx4] = spline_dx0dx2_x4[nx0][nx1][nx2][nx3].c[nx4];
						}
						else
						{
							double Dx4 = x4[Nx4 - 1] - x4[Nx4 - 2];
							fx0x2x4[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx0dx2_x4[nx0][nx1][nx2][nx3].a[nx4 - 1] * Dx4 * Dx4 + 2.0 * spline_dx0dx2_x4[nx0][nx1][nx2][nx3].b[nx4 - 1] * Dx4 + spline_dx0dx2_x4[nx0][nx1][nx2][nx3].c[nx4 - 1];
						}

						if(nx4 != Nx4 - 1)
						{
							fx0x3x4[nx0][nx1][nx2][nx3][nx4] = spline_dx0dx3_x4[nx0][nx1][nx2][nx3].c[nx4];
						}
						else
						{
							double Dx4 = x4[Nx4 - 1] - x4[Nx4 - 2];
							fx0x3x4[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx0dx3_x4[nx0][nx1][nx2][nx3].a[nx4 - 1] * Dx4 * Dx4 + 2.0 * spline_dx0dx3_x4[nx0][nx1][nx2][nx3].b[nx4 - 1] * Dx4 + spline_dx0dx3_x4[nx0][nx1][nx2][nx3].c[nx4 - 1];
						}

						if(nx3 != Nx3 - 1)
						{
							fx1x2x3[nx0][nx1][nx2][nx3][nx4] = spline_dx1dx2_x3[nx0][nx1][nx2][nx4].c[nx3];
						}
						else
						{
							double Dx3 = x3[Nx3 - 1] - x3[Nx3 - 2];
							fx1x2x3[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx1dx2_x3[nx0][nx1][nx2][nx4].a[nx3 - 1] * Dx3 * Dx3 + 2.0 * spline_dx1dx2_x3[nx0][nx1][nx2][nx4].b[nx3 - 1] * Dx3 + spline_dx1dx2_x3[nx0][nx1][nx2][nx4].c[nx3 - 1];
						}

						if(nx4 != Nx4 - 1)
						{
							fx1x2x4[nx0][nx1][nx2][nx3][nx4] = spline_dx1dx2_x4[nx0][nx1][nx2][nx3].c[nx4];
						}
						else
						{
							double Dx4 = x4[Nx4 - 1] - x4[Nx4 - 2];
							fx1x2x4[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx1dx2_x4[nx0][nx1][nx2][nx3].a[nx4 - 1] * Dx4 * Dx4 + 2.0 * spline_dx1dx2_x4[nx0][nx1][nx2][nx3].b[nx4 - 1] * Dx4 + spline_dx1dx2_x4[nx0][nx1][nx2][nx3].c[nx4 - 1];
						}

						if(nx4 != Nx4 - 1)
						{
							fx1x3x4[nx0][nx1][nx2][nx3][nx4] = spline_dx1dx3_x4[nx0][nx1][nx2][nx3].c[nx4];
						}
						else
						{
							double Dx4 = x4[Nx4 - 1] - x4[Nx4 - 2];
							fx1x3x4[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx1dx3_x4[nx0][nx1][nx2][nx3].a[nx4 - 1] * Dx4 * Dx4 + 2.0 * spline_dx1dx3_x4[nx0][nx1][nx2][nx3].b[nx4 - 1] * Dx4 + spline_dx1dx3_x4[nx0][nx1][nx2][nx3].c[nx4 - 1];
						}

						if(nx4 != Nx4 - 1)
						{
							fx2x3x4[nx0][nx1][nx2][nx3][nx4] = spline_dx2dx3_x4[nx0][nx1][nx2][nx3].c[nx4];
						}
						else
						{
							double Dx4 = x4[Nx4 - 1] - x4[Nx4 - 2];
							fx2x3x4[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx2dx3_x4[nx0][nx1][nx2][nx3].a[nx4 - 1] * Dx4 * Dx4 + 2.0 * spline_dx2dx3_x4[nx0][nx1][nx2][nx3].b[nx4 - 1] * Dx4 + spline_dx2dx3_x4[nx0][nx1][nx2][nx3].c[nx4 - 1];
						}
					}
				}
			}
		}
	}

	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx0dx1dx2_x3 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx4))));	// for fx0x1x2x3
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx0dx1dx2_x4 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx3))));	// for fx0x1x2x3
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx0dx1dx3_x4 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx3))));	// for fx0x1x2x3
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx0dx2dx3_x4 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx3))));	// for fx0x1x2x3
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx1dx2dx3_x4 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx3))));	// for fx0x1x2x3

	//MakeSpline spline_dx0dx1dx2_x3
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx4 = 0; nx4 < Nx4; nx4 ++)
				{
					for(int nx3 = 0; nx3 < Nx3; nx3 ++)
					{
						spline_dx0dx1dx2_x3[nx0][nx1][nx2][nx4].x.push_back(x3[nx3]);
						spline_dx0dx1dx2_x3[nx0][nx1][nx2][nx4].f.push_back(fx0x1x2[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[3] == SPLINE_TYPE::NATURAL)
					{
						spline_dx0dx1dx2_x3[nx0][nx1][nx2][nx4].makeNaturalSpline();
					}
					else if(spline_type[3] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx0dx1dx2_x3[nx0][nx1][nx2][nx4].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_dx0dx1dx2_x4
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					for(int nx4 = 0; nx4 < Nx4; nx4 ++)
					{
						spline_dx0dx1dx2_x4[nx0][nx1][nx2][nx3].x.push_back(x4[nx4]);
						spline_dx0dx1dx2_x4[nx0][nx1][nx2][nx3].f.push_back(fx0x1x2[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[4] == SPLINE_TYPE::NATURAL)
					{
						spline_dx0dx1dx2_x4[nx0][nx1][nx2][nx3].makeNaturalSpline();
					}
					else if(spline_type[4] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx0dx1dx2_x4[nx0][nx1][nx2][nx3].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_dx0dx1dx3_x4
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					for(int nx4 = 0; nx4 < Nx4; nx4 ++)
					{
						spline_dx0dx1dx3_x4[nx0][nx1][nx2][nx3].x.push_back(x4[nx4]);
						spline_dx0dx1dx3_x4[nx0][nx1][nx2][nx3].f.push_back(fx0x1x3[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[4] == SPLINE_TYPE::NATURAL)
					{
						spline_dx0dx1dx3_x4[nx0][nx1][nx2][nx3].makeNaturalSpline();
					}
					else if(spline_type[4] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx0dx1dx3_x4[nx0][nx1][nx2][nx3].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_dx0dx2dx3_x4
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					for(int nx4 = 0; nx4 < Nx4; nx4 ++)
					{
						spline_dx0dx2dx3_x4[nx0][nx1][nx2][nx3].x.push_back(x4[nx4]);
						spline_dx0dx2dx3_x4[nx0][nx1][nx2][nx3].f.push_back(fx0x2x3[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[4] == SPLINE_TYPE::NATURAL)
					{
						spline_dx0dx2dx3_x4[nx0][nx1][nx2][nx3].makeNaturalSpline();
					}
					else if(spline_type[4] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx0dx2dx3_x4[nx0][nx1][nx2][nx3].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_dx1dx2dx3_x4
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					for(int nx4 = 0; nx4 < Nx4; nx4 ++)
					{
						spline_dx1dx2dx3_x4[nx0][nx1][nx2][nx3].x.push_back(x4[nx4]);
						spline_dx1dx2dx3_x4[nx0][nx1][nx2][nx3].f.push_back(fx1x2x3[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[4] == SPLINE_TYPE::NATURAL)
					{
						spline_dx1dx2dx3_x4[nx0][nx1][nx2][nx3].makeNaturalSpline();
					}
					else if(spline_type[4] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx1dx2dx3_x4[nx0][nx1][nx2][nx3].makeClampedSpline();
					}
				}
			}
		}
	}

	fx0x1x2x3 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx0x1x2x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx0x1x3x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx0x2x3x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx1x2x3x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));

	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					for(int nx4 = 0; nx4 < Nx4; nx4 ++)
					{
						if(nx3 != Nx3 - 1)
						{
							fx0x1x2x3[nx0][nx1][nx2][nx3][nx4] = spline_dx0dx1dx2_x3[nx0][nx1][nx2][nx4].c[nx3];
						}
						else
						{
							double Dx3 = x3[Nx3 - 1] - x3[Nx3 - 2];
							fx0x1x2x3[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx0dx1dx2_x3[nx0][nx1][nx2][nx4].a[nx3 - 1] * Dx3 * Dx3 + 2.0 * spline_dx0dx1dx2_x3[nx0][nx1][nx2][nx4].b[nx3 - 1] * Dx3 + spline_dx0dx1dx2_x3[nx0][nx1][nx2][nx4].c[nx3 - 1];
						}

						if(nx4 != Nx4 - 1)
						{
							fx0x1x2x4[nx0][nx1][nx2][nx3][nx4] = spline_dx0dx1dx2_x4[nx0][nx1][nx2][nx3].c[nx4];
						}
						else
						{
							double Dx4 = x4[Nx4 - 1] - x4[Nx4 - 2];
							fx0x1x2x4[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx0dx1dx2_x4[nx0][nx1][nx2][nx3].a[nx4 - 1] * Dx4 * Dx4 + 2.0 * spline_dx0dx1dx2_x4[nx0][nx1][nx2][nx3].b[nx4 - 1] * Dx4 + spline_dx0dx1dx2_x4[nx0][nx1][nx2][nx3].c[nx4 - 1];
						}

						if(nx4 != Nx4 - 1)
						{
							fx0x1x3x4[nx0][nx1][nx2][nx3][nx4] = spline_dx0dx1dx3_x4[nx0][nx1][nx2][nx3].c[nx4];
						}
						else
						{
							double Dx4 = x4[Nx4 - 1] - x4[Nx4 - 2];
							fx0x1x3x4[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx0dx1dx3_x4[nx0][nx1][nx2][nx3].a[nx4 - 1] * Dx4 * Dx4 + 2.0 * spline_dx0dx1dx3_x4[nx0][nx1][nx2][nx3].b[nx4 - 1] * Dx4 + spline_dx0dx1dx3_x4[nx0][nx1][nx2][nx3].c[nx4 - 1];
						}

						if(nx4 != Nx4 - 1)
						{
							fx0x2x3x4[nx0][nx1][nx2][nx3][nx4] = spline_dx0dx2dx3_x4[nx0][nx1][nx2][nx3].c[nx4];
						}
						else
						{
							double Dx4 = x4[Nx4 - 1] - x4[Nx4 - 2];
							fx0x2x3x4[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx0dx2dx3_x4[nx0][nx1][nx2][nx3].a[nx4 - 1] * Dx4 * Dx4 + 2.0 * spline_dx0dx2dx3_x4[nx0][nx1][nx2][nx3].b[nx4 - 1] * Dx4 + spline_dx0dx2dx3_x4[nx0][nx1][nx2][nx3].c[nx4 - 1];
						}

						if(nx4 != Nx4 - 1)
						{
							fx1x2x3x4[nx0][nx1][nx2][nx3][nx4] = spline_dx1dx2dx3_x4[nx0][nx1][nx2][nx3].c[nx4];
						}
						else
						{
							double Dx4 = x4[Nx4 - 1] - x4[Nx4 - 2];
							fx1x2x3x4[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx1dx2dx3_x4[nx0][nx1][nx2][nx3].a[nx4 - 1] * Dx4 * Dx4 + 2.0 * spline_dx1dx2dx3_x4[nx0][nx1][nx2][nx3].b[nx4 - 1] * Dx4 + spline_dx1dx2dx3_x4[nx0][nx1][nx2][nx3].c[nx4 - 1];
						}
					}
				}
			}
		}
	}

	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx0dx1dx2dx3_x4 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx3))));	// for fx0x1x2x3x4

	//MakeSpline spline_dx0dx1dx2dx3_x4
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					for(int nx4 = 0; nx4 < Nx4; nx4 ++)
					{
						spline_dx0dx1dx2dx3_x4[nx0][nx1][nx2][nx3].x.push_back(x4[nx4]);
						spline_dx0dx1dx2dx3_x4[nx0][nx1][nx2][nx3].f.push_back(fx0x1x2x3[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[4] == SPLINE_TYPE::NATURAL)
					{
						spline_dx0dx1dx2dx3_x4[nx0][nx1][nx2][nx3].makeNaturalSpline();
					}
					else if(spline_type[4] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx0dx1dx2dx3_x4[nx0][nx1][nx2][nx3].makeClampedSpline();
					}
				}
			}
		}
	}

	fx0x1x2x3x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));

	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					for(int nx4 = 0; nx4 < Nx4; nx4 ++)
					{
						if(nx4 != Nx4 - 1)
						{
							fx0x1x2x3x4[nx0][nx1][nx2][nx3][nx4] = spline_dx0dx1dx2dx3_x4[nx0][nx1][nx2][nx3].c[nx4];
						}
						else
						{
							double Dx4 = x4[Nx4 - 1] - x4[Nx4 - 2];
							fx0x1x2x3x4[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx0dx1dx2dx3_x4[nx0][nx1][nx2][nx3].a[nx4 - 1] * Dx4 * Dx4 + 2.0 *spline_dx0dx1dx2dx3_x4[nx0][nx1][nx2][nx3].b[nx4 - 1] * Dx4 +spline_dx0dx1dx2dx3_x4[nx0][nx1][nx2][nx3].c[nx4 - 1];
						}
					}
				}
			}
		}
	}

	interval = std::vector<std::vector<std::vector<std::vector<std::vector<PentaCubicSpline>>>>>(Nx0 - 1, std::vector<std::vector<std::vector<std::vector<PentaCubicSpline>>>>(Nx1 - 1, std::vector<std::vector<std::vector<PentaCubicSpline>>>(Nx2 - 1, std::vector<std::vector<PentaCubicSpline>>(Nx3 - 1, std::vector<PentaCubicSpline>(Nx4 - 1)))));

	if(regular_grid == true)
	{
		A = std::vector<std::vector<double>>(1024, std::vector<double>(1024));
		double Dx0 = x0[1] - x0[0];
		double Dx1 = x1[1] - x1[0];
		double Dx2 = x2[1] - x2[0];
		double Dx3 = x3[1] - x3[0];
		double Dx4 = x4[1] - x4[0];

		auto pow = [](double v1, int v2)
		{
			if(v1 == 0 && v2 == 0)
			{
				return 1.0;
			}
			else if(v1 == 0)
			{
				return 0.0;
			}
			else if(v2 == 0)
			{
				return 1.0;
			}
			else
			{
				return std::pow(v1, double(v2));
			}
		};

		for(int nx4 = 0; nx4 < 2; nx4 ++)
		{
			double dx4 = Dx4 * (double(nx4));

			for(int nx3 = 0; nx3 < 2; nx3 ++)
			{
				double dx3 = Dx3 * (double(nx3));

				for(int nx2 = 0; nx2 < 2; nx2 ++)
				{
					double dx2 = Dx2 * (double(nx2));
					
					for(int nx1 = 0; nx1 < 2; nx1 ++)
					{
						double dx1 = Dx1 * (double(nx1));

						for(int nx0 = 0; nx0 < 2; nx0 ++)
						{
							double dx0 = Dx0 * (double(nx0));

							int row = nx4 * 16 + nx3 * 8 + nx2 * 4 + nx1 * 2 + nx0;

							for(int m = 0; m < 4; m ++)
							{
								for(int l = 0; l < 4; l ++)
								{
									for(int k = 0; k < 4; k ++)
									{
										for(int j = 0; j < 4; j ++)
										{
											for(int i = 0; i < 4; i ++)
											{
												int col = m * 256 + l * 64 + k * 16 + j * 4 + i;

												//f
												A[row][col] = pow(dx0, i) * pow(dx1, j) * pow(dx2, k) * pow(dx3, l) * pow(dx4, m);

												//fx
												if(i == 0)
												{
													A[row + 32 * 1][col] = 0.0;
												}
												else
												{
													A[row + 32 * 1][col] = double(i) * pow(dx0, i - 1) * pow(dx1, j) * pow(dx2, k) * pow(dx3, l) * pow(dx4, m);
												}

												if(j == 0)
												{
													A[row + 32 * 2][col] = 0.0;
												}
												else
												{
													A[row + 32 * 2][col] = double(j) * pow(dx0, i) * pow(dx1, j - 1) * pow(dx2, k) * pow(dx3, l) * pow(dx4, m);
												}

												if(k == 0)
												{
													A[row + 32 * 3][col] = 0.0;
												}
												else
												{
													A[row + 32 * 3][col] = double(k) * pow(dx0, i) * pow(dx1, j) * pow(dx2, k - 1) * pow(dx3, l) * pow(dx4, m);
												}

												if(l == 0)
												{
													A[row + 32 * 4][col] = 0.0;
												}
												else
												{
													A[row + 32 * 4][col] = double(l) * pow(dx0, i) * pow(dx1, j) * pow(dx2, k) * pow(dx3, l - 1) * pow(dx4, m);
												}

												if(m == 0)
												{
													A[row + 32 * 5][col] = 0.0;
												}
												else
												{
													A[row + 32 * 5][col] = double(m) * pow(dx0, i) * pow(dx1, j) * pow(dx2, k) * pow(dx3, l) * pow(dx4, m - 1);
												}

												//fxx
												if(i == 0 || j == 0)
												{
													A[row + 32 * 6][col] = 0.0;
												}
												else
												{
													A[row + 32 * 6][col] = double(i) * double(j) * pow(dx0, i - 1) * pow(dx1, j - 1) * pow(dx2, k) * pow(dx3, l) * pow(dx4, m);
												}

												if(i == 0 || k == 0)
												{
													A[row+ 32 * 7][col] = 0.0;
												}
												else
												{
													A[row+ 32 * 7][col] = double(i) * double(k) * pow(dx0, i - 1) * pow(dx1, j) * pow(dx2, k - 1) * pow(dx3, l) * pow(dx4, m);
												}

												if(i == 0 || l == 0)
												{
													A[row + 32 * 8][col] = 0.0;
												}
												else
												{
													A[row + 32 * 8][col] = double(i) * double(l) * pow(dx0, i - 1) * pow(dx1, j) * pow(dx2, k) * pow(dx3, l - 1) * pow(dx4, m);
												}

												if(i == 0 || m == 0)
												{
													A[row + 32 * 9][col] = 0.0;
												}
												else
												{
													A[row + 32 * 9][col] = double(i) * double(m) * pow(dx0, i - 1) * pow(dx1, j) * pow(dx2, k) * pow(dx3, l) * pow(dx4, m - 1);
												}

												if(j == 0 || k == 0)
												{
													A[row + 32 * 10][col] = 0.0;
												}
												else
												{
													A[row + 32 * 10][col] = double(j) * double(k) * pow(dx0, i) * pow(dx1, j - 1) * pow(dx2, k - 1) * pow(dx3, l) * pow(dx4, m);
												}

												if(j == 0 || l == 0)
												{
													A[row + 32 * 11][col] = 0.0;
												}
												else
												{
													A[row + 32 * 11][col] = double(j) * double(l) * pow(dx0, i) * pow(dx1, j - 1) * pow(dx2, k) * pow(dx3, l - 1) * pow(dx4, m);
												}

												if(j == 0 || m == 0)
												{
													A[row + 32 * 12][col] = 0.0;
												}
												else
												{
													A[row + 32 * 12][col] = double(j) * double(m) * pow(dx0, i) * pow(dx1, j - 1) * pow(dx2, k) * pow(dx3, l) * pow(dx4, m - 1);
												}

												if(k == 0 || l == 0)
												{
													A[row + 32 * 13][col] = 0.0;
												}
												else
												{
													A[row + 32 * 13][col] = double(k) * double(l) * pow(dx0, i) * pow(dx1, j) * pow(dx2, k - 1) * pow(dx3, l - 1) * pow(dx4, m);
												}

												if(k == 0 || m == 0)
												{
													A[row + 32 * 14][col] = 0.0;
												}
												else
												{
													A[row + 32 * 14][col] = double(k) * double(m) * pow(dx0, i) * pow(dx1, j) * pow(dx2, k - 1) * pow(dx3, l) * pow(dx4, m - 1);
												}

												if(l == 0 || m == 0)
												{
													A[row + 32 * 15][col] = 0.0;
												}
												else
												{
													A[row + 32 * 15][col] = double(l) * double(m) * pow(dx0, i) * pow(dx1, j) * pow(dx2, k) * pow(dx3, l - 1) * pow(dx4, m - 1);
												}

												//fxxx
												if(i == 0 || j == 0 || k == 0)
												{
													A[row + 32 * 16][col] = 0.0;
												}
												else
												{
													A[row + 32 * 16][col] = double(i) * double(j) * double(k) * pow(dx0, i - 1) * pow(dx1, j - 1) * pow(dx2, k - 1) * pow(dx3, l) * pow(dx4, m);
												}

												if(i == 0 || j == 0 || l == 0)
												{
													A[row + 32 * 17][col] = 0.0;
												}
												else
												{
													A[row + 32 * 17][col] = double(i) * double(j) * double(l) * pow(dx0, i - 1) * pow(dx1, j - 1) * pow(dx2, k) * pow(dx3, l - 1) * pow(dx4, m);
												}

												if(i == 0 || j == 0 || m == 0)
												{
													A[row + 32 * 18][col] = 0.0;
												}
												else
												{
													A[row + 32 * 18][col] = double(i) * double(j) * double(m) * pow(dx0, i - 1) * pow(dx1, j - 1) * pow(dx2, k) * pow(dx3, l) * pow(dx4, m - 1);
												}

												if(i == 0 || k == 0 || l == 0)
												{
													A[row + 32 * 19][col] = 0.0;
												}
												else
												{
													A[row + 32 * 19][col] = double(i) * double(k) * double(l) * pow(dx0, i - 1) * pow(dx1, j) * pow(dx2, k - 1) * pow(dx3, l - 1) * pow(dx4, m);
												}

												if(i == 0 || k == 0 || m == 0)
												{
													A[row + 32 * 20][col] = 0.0;
												}
												else
												{
													A[row + 32 * 20][col] = double(i) * double(k) * double(m) * pow(dx0, i - 1) * pow(dx1, j) * pow(dx2, k - 1) * pow(dx3, l) * pow(dx4, m - 1);
												}

												if(i == 0 || l == 0 || m == 0)
												{
													A[row + 32 * 21][col] = 0.0;
												}
												else
												{
													A[row + 32 * 21][col] = double(i) * double(l) * double(m) * pow(dx0, i - 1) * pow(dx1, j) * pow(dx2, k) * pow(dx3, l - 1) * pow(dx4, m - 1);
												}

												if(j == 0 || k == 0 || l == 0)
												{
													A[row + 32 * 22][col] = 0.0;
												}
												else
												{
													A[row + 32 * 22][col] = double(j) * double(k) * double(l) * pow(dx0, i) * pow(dx1, j - 1) * pow(dx2, k - 1) * pow(dx3, l - 1) * pow(dx4, m);
												}

												if(j == 0 || k == 0 || m == 0)
												{
													A[row + 32 * 23][col] = 0.0;
												}
												else
												{
													A[row + 32 * 23][col] = double(j) * double(k) * double(m) * pow(dx0, i) * pow(dx1, j - 1) * pow(dx2, k - 1) * pow(dx3, l) * pow(dx4, m - 1);
												}

												if(j == 0 || l == 0 || m == 0)
												{
													A[row + 32 * 24][col] = 0.0;
												}
												else
												{
													A[row + 32 * 24][col] = double(j) * double(l) * double(m) * pow(dx0, i) * pow(dx1, j - 1) * pow(dx2, k) * pow(dx3, l - 1) * pow(dx4, m - 1);
												}

												if(k == 0 || l == 0 || m == 0)
												{
													A[row + 32 * 25][col] = 0.0;
												}
												else
												{
													A[row + 32 * 25][col] = double(k) * double(l) * double(m) * pow(dx0, i) * pow(dx1, j) * pow(dx2, k - 1) * pow(dx3, l - 1) * pow(dx4, m - 1);
												}

												//fxxxx
												if(i == 0 || j == 0 || k == 0 || l == 0)
												{
													A[row + 32 * 26][col] = 0.0;
												}
												else
												{
													A[row + 32 * 26][col] = double(i) * double(j) * double(k) * double(l) * pow(dx0, i - 1) * pow(dx1, j - 1) * pow(dx2, k - 1) * pow(dx3, l - 1) * pow(dx4, m);
												}

												if(i == 0 || j == 0 || k == 0 || m == 0)
												{
													A[row + 32 * 27][col] = 0.0;
												}
												else
												{
													A[row + 32 * 27][col] = double(i) * double(j) * double(k) * double(m) * pow(dx0, i - 1) * pow(dx1, j - 1) * pow(dx2, k - 1) * pow(dx3, l) * pow(dx4, m - 1);
												}

												if(i == 0 || j == 0 || l == 0 || m == 0)
												{
													A[row + 32 * 28][col] = 0.0;
												}
												else
												{
													A[row + 32 * 28][col] = double(i) * double(j) * double(l) * double(m) * pow(dx0, i - 1) * pow(dx1, j - 1) * pow(dx2, k) * pow(dx3, l - 1) * pow(dx4, m - 1);
												}

												if(i == 0 || k == 0 || l == 0 || m == 0)
												{
													A[row + 32 * 29][col] = 0.0;
												}
												else
												{
													A[row + 32 * 29][col] = double(i) * double(k) * double(l) * double(m) * pow(dx0, i - 1) * pow(dx1, j) * pow(dx2, k - 1) * pow(dx3, l - 1) * pow(dx4, m - 1);
												}

												if(j == 0 || k == 0 || l == 0 || m == 0)
												{
													A[row + 32 * 30][col] = 0.0;
												}
												else
												{
													A[row + 32 * 30][col] = double(j) * double(k) * double(l) * double(m) * pow(dx0, i) * pow(dx1, j - 1) * pow(dx2, k - 1) * pow(dx3, l - 1) * pow(dx4, m - 1);
												}

												//fxxxxx
												if(i == 0 || j == 0 || k == 0 || l == 0 || m == 0)
												{
													A[row + 32 * 31][col] = 0.0;
												}
												else
												{
													A[row + 32 * 31][col] = double(i) * double(j) * double(k) * double(l) * double(m) * pow(dx0, i - 1) * pow(dx1, j - 1) * pow(dx2, k - 1) * pow(dx3, l - 1) * pow(dx4, m - 1);
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}

		invertMatrix(A);
	}

	for(int nx0 = 0; nx0 < Nx0 - 1; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1 - 1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2 - 1; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3 - 1; nx3 ++)
				{
					for(int nx4 = 0; nx4 < Nx4 - 1; nx4 ++)
					{
						interval[nx0][nx1][nx2][nx3][nx4].p = std::vector<std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>>(2, std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(5))))));
						interval[nx0][nx1][nx2][nx3][nx4].f = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						interval[nx0][nx1][nx2][nx3][nx4].fx0 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						interval[nx0][nx1][nx2][nx3][nx4].fx1 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						interval[nx0][nx1][nx2][nx3][nx4].fx2 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						interval[nx0][nx1][nx2][nx3][nx4].fx3 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						interval[nx0][nx1][nx2][nx3][nx4].fx4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						interval[nx0][nx1][nx2][nx3][nx4].fx0x1 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						interval[nx0][nx1][nx2][nx3][nx4].fx0x2 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						interval[nx0][nx1][nx2][nx3][nx4].fx0x3 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						interval[nx0][nx1][nx2][nx3][nx4].fx0x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						interval[nx0][nx1][nx2][nx3][nx4].fx1x2 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						interval[nx0][nx1][nx2][nx3][nx4].fx1x3 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						interval[nx0][nx1][nx2][nx3][nx4].fx1x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						interval[nx0][nx1][nx2][nx3][nx4].fx2x3 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						interval[nx0][nx1][nx2][nx3][nx4].fx2x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						interval[nx0][nx1][nx2][nx3][nx4].fx3x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						interval[nx0][nx1][nx2][nx3][nx4].fx0x1x2 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						interval[nx0][nx1][nx2][nx3][nx4].fx0x1x3 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						interval[nx0][nx1][nx2][nx3][nx4].fx0x1x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						interval[nx0][nx1][nx2][nx3][nx4].fx0x2x3 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						interval[nx0][nx1][nx2][nx3][nx4].fx0x2x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						interval[nx0][nx1][nx2][nx3][nx4].fx0x3x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						interval[nx0][nx1][nx2][nx3][nx4].fx1x2x3 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						interval[nx0][nx1][nx2][nx3][nx4].fx1x2x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						interval[nx0][nx1][nx2][nx3][nx4].fx1x3x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						interval[nx0][nx1][nx2][nx3][nx4].fx2x3x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						interval[nx0][nx1][nx2][nx3][nx4].fx0x1x2x3 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						interval[nx0][nx1][nx2][nx3][nx4].fx0x1x2x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						interval[nx0][nx1][nx2][nx3][nx4].fx0x1x3x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						interval[nx0][nx1][nx2][nx3][nx4].fx0x2x3x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						interval[nx0][nx1][nx2][nx3][nx4].fx1x2x3x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						interval[nx0][nx1][nx2][nx3][nx4].fx0x1x2x3x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));

						for(int i = 0; i < 2; i ++)
						{
							for(int j = 0; j < 2; j ++)
							{
								for(int k = 0; k < 2; k ++)
								{
									for(int l = 0; l < 2; l ++)
									{
										for(int m = 0; m < 2; m ++)
										{
											interval[nx0][nx1][nx2][nx3][nx4].p[i][j][k][l][m] = {x0[nx0 + i], x1[nx1 + j], x2[nx2 + k], x3[nx3 + l], x4[nx4 + m]};
											interval[nx0][nx1][nx2][nx3][nx4].f[i][j][k][l][m] = f[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											interval[nx0][nx1][nx2][nx3][nx4].fx0[i][j][k][l][m] = fx0[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											interval[nx0][nx1][nx2][nx3][nx4].fx1[i][j][k][l][m] = fx1[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											interval[nx0][nx1][nx2][nx3][nx4].fx2[i][j][k][l][m] = fx2[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											interval[nx0][nx1][nx2][nx3][nx4].fx3[i][j][k][l][m] = fx3[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											interval[nx0][nx1][nx2][nx3][nx4].fx4[i][j][k][l][m] = fx4[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											interval[nx0][nx1][nx2][nx3][nx4].fx0x1[i][j][k][l][m] = fx0x1[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											interval[nx0][nx1][nx2][nx3][nx4].fx0x2[i][j][k][l][m] = fx0x2[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											interval[nx0][nx1][nx2][nx3][nx4].fx0x3[i][j][k][l][m] = fx0x3[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											interval[nx0][nx1][nx2][nx3][nx4].fx0x4[i][j][k][l][m] = fx0x4[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											interval[nx0][nx1][nx2][nx3][nx4].fx1x2[i][j][k][l][m] = fx1x2[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											interval[nx0][nx1][nx2][nx3][nx4].fx1x3[i][j][k][l][m] = fx1x3[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											interval[nx0][nx1][nx2][nx3][nx4].fx1x4[i][j][k][l][m] = fx1x4[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											interval[nx0][nx1][nx2][nx3][nx4].fx2x3[i][j][k][l][m] = fx2x3[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											interval[nx0][nx1][nx2][nx3][nx4].fx2x4[i][j][k][l][m] = fx2x4[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											interval[nx0][nx1][nx2][nx3][nx4].fx3x4[i][j][k][l][m] = fx3x4[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											interval[nx0][nx1][nx2][nx3][nx4].fx0x1x2[i][j][k][l][m] = fx0x1x2[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											interval[nx0][nx1][nx2][nx3][nx4].fx0x1x3[i][j][k][l][m] = fx0x1x3[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											interval[nx0][nx1][nx2][nx3][nx4].fx0x1x4[i][j][k][l][m] = fx0x1x4[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											interval[nx0][nx1][nx2][nx3][nx4].fx0x2x3[i][j][k][l][m] = fx0x2x3[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											interval[nx0][nx1][nx2][nx3][nx4].fx0x2x4[i][j][k][l][m] = fx0x2x4[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											interval[nx0][nx1][nx2][nx3][nx4].fx0x3x4[i][j][k][l][m] = fx0x3x4[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											interval[nx0][nx1][nx2][nx3][nx4].fx1x2x3[i][j][k][l][m] = fx1x2x3[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											interval[nx0][nx1][nx2][nx3][nx4].fx1x2x4[i][j][k][l][m] = fx1x2x4[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											interval[nx0][nx1][nx2][nx3][nx4].fx1x3x4[i][j][k][l][m] = fx1x3x4[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											interval[nx0][nx1][nx2][nx3][nx4].fx2x3x4[i][j][k][l][m] = fx2x3x4[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											interval[nx0][nx1][nx2][nx3][nx4].fx0x1x2x3[i][j][k][l][m] = fx0x1x2x3[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											interval[nx0][nx1][nx2][nx3][nx4].fx0x1x2x4[i][j][k][l][m] = fx0x1x2x4[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											interval[nx0][nx1][nx2][nx3][nx4].fx0x1x3x4[i][j][k][l][m] = fx0x1x3x4[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											interval[nx0][nx1][nx2][nx3][nx4].fx0x2x3x4[i][j][k][l][m] = fx0x2x3x4[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											interval[nx0][nx1][nx2][nx3][nx4].fx1x2x3x4[i][j][k][l][m] = fx1x2x3x4[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											interval[nx0][nx1][nx2][nx3][nx4].fx0x1x2x3x4[i][j][k][l][m] = fx0x1x2x3x4[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
										}
									}
								}
							}
						}

						if(regular_grid == false)
						{
							interval[nx0][nx1][nx2][nx3][nx4].makeInterpolator();
						}
						else if(regular_grid == true)
						{
							interval[nx0][nx1][nx2][nx3][nx4].makeInterpolator(A);
						}

						interval[nx0][nx1][nx2][nx3][nx4].clearData();
					}
				}
			}
		}
	}

	clearData();

	return;
}

inline void PentaCubicInterpolator::makeInterpolator(std::string filename)
{
	int Nx0 = x0.size();
	int Nx1 = x1.size();
	int Nx2 = x2.size();
	int Nx3 = x3.size();
	int Nx4 = x4.size();

	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_x0 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx1, std::vector<std::vector<std::vector<Spline>>>(Nx2, std::vector<std::vector<Spline>>(Nx3, std::vector<Spline>(Nx4))));
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_x1 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx2, std::vector<std::vector<Spline>>(Nx3, std::vector<Spline>(Nx4))));
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_x2 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx3, std::vector<Spline>(Nx4))));
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_x3 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx4))));
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_x4 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx3))));

	//MakeSpline spline_x0
	#pragma omp parallel for
	for(int nx1 = 0; nx1 < Nx1; nx1 ++)
	{
		for(int nx2 = 0; nx2 < Nx2; nx2 ++)
		{
			for(int nx3 = 0; nx3 < Nx3; nx3 ++)
			{
				for(int nx4 = 0; nx4 < Nx4; nx4 ++)
				{
					for(int nx0 = 0; nx0 < Nx0; nx0 ++)
					{
						spline_x0[nx1][nx2][nx3][nx4].x.push_back(x0[nx0]);
						spline_x0[nx1][nx2][nx3][nx4].f.push_back(f[nx0][nx1][nx2][nx3][nx4]);
					}
					if(spline_type[0] == SPLINE_TYPE::NATURAL)
					{
						spline_x0[nx1][nx2][nx3][nx4].makeNaturalSpline();
					}
					else if(spline_type[0] == SPLINE_TYPE::CLAMPED)
					{
						spline_x0[nx1][nx2][nx3][nx4].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_x1
	#pragma omp parallel for
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx2 = 0; nx2 < Nx2; nx2 ++)
		{
			for(int nx3 = 0; nx3 < Nx3; nx3 ++)
			{
				for(int nx4 = 0; nx4 < Nx4; nx4 ++)
				{
					for(int nx1 = 0; nx1 < Nx1; nx1 ++)
					{
						spline_x1[nx0][nx2][nx3][nx4].x.push_back(x1[nx1]);
						spline_x1[nx0][nx2][nx3][nx4].f.push_back(f[nx0][nx1][nx2][nx3][nx4]);
					}
					if(spline_type[1] == SPLINE_TYPE::NATURAL)
					{
						spline_x1[nx0][nx2][nx3][nx4].makeNaturalSpline();
					}
					else if(spline_type[1] == SPLINE_TYPE::CLAMPED)
					{
						spline_x1[nx0][nx2][nx3][nx4].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_x2
	#pragma omp parallel for
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx3 = 0; nx3 < Nx3; nx3 ++)
			{
				for(int nx4 = 0; nx4 < Nx4; nx4 ++)
				{
					for(int nx2 = 0; nx2 < Nx2; nx2 ++)
					{
						spline_x2[nx0][nx1][nx3][nx4].x.push_back(x2[nx2]);
						spline_x2[nx0][nx1][nx3][nx4].f.push_back(f[nx0][nx1][nx2][nx3][nx4]);
					}
					if(spline_type[2] == SPLINE_TYPE::NATURAL)
					{
						spline_x2[nx0][nx1][nx3][nx4].makeNaturalSpline();
					}
					else if(spline_type[2] == SPLINE_TYPE::CLAMPED)
					{
						spline_x2[nx0][nx1][nx3][nx4].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_x3
	#pragma omp parallel for
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx4 = 0; nx4 < Nx4; nx4 ++)
				{
					for(int nx3 = 0; nx3 < Nx3; nx3 ++)
					{
						spline_x3[nx0][nx1][nx2][nx4].x.push_back(x3[nx3]);
						spline_x3[nx0][nx1][nx2][nx4].f.push_back(f[nx0][nx1][nx2][nx3][nx4]);
					}
					if(spline_type[3] == SPLINE_TYPE::NATURAL)
					{
						spline_x3[nx0][nx1][nx2][nx4].makeNaturalSpline();
					}
					else if(spline_type[3] == SPLINE_TYPE::CLAMPED)
					{
						spline_x3[nx0][nx1][nx2][nx4].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_x4
	#pragma omp parallel for
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					for(int nx4 = 0; nx4 < Nx4; nx4 ++)
					{
						spline_x4[nx0][nx1][nx2][nx3].x.push_back(x4[nx4]);
						spline_x4[nx0][nx1][nx2][nx3].f.push_back(f[nx0][nx1][nx2][nx3][nx4]);
					}
					if(spline_type[4] == SPLINE_TYPE::NATURAL)
					{
						spline_x4[nx0][nx1][nx2][nx3].makeNaturalSpline();
					}
					else if(spline_type[4] == SPLINE_TYPE::CLAMPED)
					{
						spline_x4[nx0][nx1][nx2][nx3].makeClampedSpline();
					}
				}
			}
		}
	}

	//Derive fx0, fx1, fx2, fx3, fx4
	fx0 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx1 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx2 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx3 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));

	#pragma omp parallel for
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					for(int nx4 = 0; nx4 < Nx4; nx4 ++)
					{
						if(nx0 != Nx0 - 1)
						{
							fx0[nx0][nx1][nx2][nx3][nx4] = spline_x0[nx1][nx2][nx3][nx4].c[nx0];
						}
						else
						{
							double Dx0 = x0[Nx0 - 1] - x0[Nx0 - 2];
							fx0[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_x0[nx1][nx2][nx3][nx4].a[nx0 - 1] * Dx0 * Dx0 + 2.0 * spline_x0[nx1][nx2][nx3][nx4].b[nx0 - 1] * Dx0 + spline_x0[nx1][nx2][nx3][nx4].c[nx0 - 1];
						}

						if(nx1 != Nx1 - 1)
						{
							fx1[nx0][nx1][nx2][nx3][nx4] = spline_x1[nx0][nx2][nx3][nx4].c[nx1];
						}
						else
						{
							double Dx1 = x1[Nx1 - 1] - x1[Nx1 - 2];
							fx1[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_x1[nx0][nx2][nx3][nx4].a[nx1 - 1] * Dx1 * Dx1 + 2.0 * spline_x1[nx0][nx2][nx3][nx4].b[nx1 - 1] * Dx1 + spline_x1[nx0][nx2][nx3][nx4].c[nx1 - 1];
						}

						if(nx2 != Nx2 - 1)
						{
							fx2[nx0][nx1][nx2][nx3][nx4] = spline_x2[nx0][nx1][nx3][nx4].c[nx2];
						}
						else
						{
							double Dx2 = x2[Nx2 - 1] - x2[Nx2 - 2];
							fx2[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_x2[nx0][nx1][nx3][nx4].a[nx2 - 1] * Dx2 * Dx2 + 2.0 * spline_x2[nx0][nx1][nx3][nx4].b[nx2 - 1] * Dx2 + spline_x2[nx0][nx1][nx3][nx4].c[nx2 - 1];
						}

						if(nx3 != Nx3 - 1)
						{
							fx3[nx0][nx1][nx2][nx3][nx4] = spline_x3[nx0][nx1][nx2][nx4].c[nx3];
						}
						else
						{
							double Dx3 = x3[Nx3 - 1] - x3[Nx3 - 2];
							fx3[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_x3[nx0][nx1][nx2][nx4].a[nx3 - 1] * Dx3 * Dx3 + 2.0 * spline_x3[nx0][nx1][nx2][nx4].b[nx3 - 1] * Dx3 + spline_x3[nx0][nx1][nx2][nx4].c[nx3 - 1];
						}

						if(nx4 != Nx4 - 1)
						{
							fx4[nx0][nx1][nx2][nx3][nx4] = spline_x4[nx0][nx1][nx2][nx3].c[nx4];
						}
						else
						{
							double Dx4 = x4[Nx4 - 1] - x4[Nx4 - 2];
							fx4[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_x4[nx0][nx1][nx2][nx3].a[nx4 - 1] * Dx4 * Dx4 + 2.0 * spline_x4[nx0][nx1][nx2][nx3].b[nx4 - 1] * Dx4 + spline_x4[nx0][nx1][nx2][nx3].c[nx4 - 1];
						}
					}
				}
			}
		}
	}

	std::cout << "1st derivative" << std::endl << std::flush;

	spline_x0.clear();
	spline_x1.clear();
	spline_x2.clear();
	spline_x3.clear();
	spline_x4.clear();

	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx0_x1 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx2, std::vector<std::vector<Spline>>(Nx3, std::vector<Spline>(Nx4))));	// for fx0x1
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx0_x2 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx3, std::vector<Spline>(Nx4))));	// for fx0x2
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx0_x3 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx4))));	// for fx0x3
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx0_x4 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx3))));	// for fx0x4
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx1_x2 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx3, std::vector<Spline>(Nx4))));	// for fx1x2
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx1_x3 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx4))));	// for fx1x3
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx1_x4 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx3))));	// for fx1x4
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx2_x3 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx4))));	// for fx2x3
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx2_x4 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx3))));	// for fx2x4
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx3_x4 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx3))));	// for fx3x4

	//MakeSpline spline_dx0_x1
	#pragma omp parallel for
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx2 = 0; nx2 < Nx2; nx2 ++)
		{
			for(int nx3 = 0; nx3 < Nx3; nx3 ++)
			{
				for(int nx4 = 0; nx4 < Nx4; nx4 ++)
				{
					for(int nx1 = 0; nx1 < Nx1; nx1 ++)
					{
						spline_dx0_x1[nx0][nx2][nx3][nx4].x.push_back(x1[nx1]);
						spline_dx0_x1[nx0][nx2][nx3][nx4].f.push_back(fx0[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[1] == SPLINE_TYPE::NATURAL)
					{
						spline_dx0_x1[nx0][nx2][nx3][nx4].makeNaturalSpline();
					}
					else if(spline_type[1] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx0_x1[nx0][nx2][nx3][nx4].makeClampedSpline();
					}
				}
			}
		}
	}
	
	//MakeSpline spline_dx0_x2
	#pragma omp parallel for
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx3 = 0; nx3 < Nx3; nx3 ++)
			{
				for(int nx4 = 0; nx4 < Nx4; nx4 ++)
				{
					for(int nx2 = 0; nx2 < Nx2; nx2 ++)
					{
						spline_dx0_x2[nx0][nx1][nx3][nx4].x.push_back(x2[nx2]);
						spline_dx0_x2[nx0][nx1][nx3][nx4].f.push_back(fx0[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[2] == SPLINE_TYPE::NATURAL)
					{
						spline_dx0_x2[nx0][nx1][nx3][nx4].makeNaturalSpline();
					}
					else if(spline_type[2] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx0_x2[nx0][nx1][nx3][nx4].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_dx0_x3
	#pragma omp parallel for
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx4 = 0; nx4 < Nx4; nx4 ++)
				{
					for(int nx3 = 0; nx3 < Nx3; nx3 ++)
					{
						spline_dx0_x3[nx0][nx1][nx2][nx4].x.push_back(x3[nx3]);
						spline_dx0_x3[nx0][nx1][nx2][nx4].f.push_back(fx0[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[3] == SPLINE_TYPE::NATURAL)
					{
						spline_dx0_x3[nx0][nx1][nx2][nx4].makeNaturalSpline();
					}
					else if(spline_type[3] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx0_x3[nx0][nx1][nx2][nx4].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_dx0_x4
	#pragma omp parallel for
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					for(int nx4 = 0; nx4 < Nx4; nx4 ++)
					{
						spline_dx0_x4[nx0][nx1][nx2][nx3].x.push_back(x4[nx4]);
						spline_dx0_x4[nx0][nx1][nx2][nx3].f.push_back(fx0[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[4] == SPLINE_TYPE::NATURAL)
					{
						spline_dx0_x4[nx0][nx1][nx2][nx3].makeNaturalSpline();
					}
					else if(spline_type[4] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx0_x4[nx0][nx1][nx2][nx3].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_dx1_x2
	#pragma omp parallel for
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx3 = 0; nx3 < Nx3; nx3 ++)
			{
				for(int nx4 = 0; nx4 < Nx4; nx4 ++)
				{
					for(int nx2 = 0; nx2 < Nx2; nx2 ++)
					{
						spline_dx1_x2[nx0][nx1][nx3][nx4].x.push_back(x2[nx2]);
						spline_dx1_x2[nx0][nx1][nx3][nx4].f.push_back(fx1[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[2] == SPLINE_TYPE::NATURAL)
					{
						spline_dx1_x2[nx0][nx1][nx3][nx4].makeNaturalSpline();
					}
					else if(spline_type[2] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx1_x2[nx0][nx1][nx3][nx4].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_dx1_x3
	#pragma omp parallel for
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx4 = 0; nx4 < Nx4; nx4 ++)
				{
					for(int nx3 = 0; nx3 < Nx3; nx3 ++)
					{
						spline_dx1_x3[nx0][nx1][nx2][nx4].x.push_back(x3[nx3]);
						spline_dx1_x3[nx0][nx1][nx2][nx4].f.push_back(fx1[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[3] == SPLINE_TYPE::NATURAL)
					{
						spline_dx1_x3[nx0][nx1][nx2][nx4].makeNaturalSpline();
					}
					else if(spline_type[3] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx1_x3[nx0][nx1][nx2][nx4].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_dx1_x4
	#pragma omp parallel for
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					for(int nx4 = 0; nx4 < Nx4; nx4 ++)
					{
						spline_dx1_x4[nx0][nx1][nx2][nx3].x.push_back(x4[nx4]);
						spline_dx1_x4[nx0][nx1][nx2][nx3].f.push_back(fx1[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[4] == SPLINE_TYPE::NATURAL)
					{
						spline_dx1_x4[nx0][nx1][nx2][nx3].makeNaturalSpline();
					}
					else if(spline_type[4] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx1_x4[nx0][nx1][nx2][nx3].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_dx2_x3
	#pragma omp parallel for
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx4 = 0; nx4 < Nx4; nx4 ++)
				{
					for(int nx3 = 0; nx3 < Nx3; nx3 ++)
					{
						spline_dx2_x3[nx0][nx1][nx2][nx4].x.push_back(x3[nx3]);
						spline_dx2_x3[nx0][nx1][nx2][nx4].f.push_back(fx2[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[3] == SPLINE_TYPE::NATURAL)
					{
						spline_dx2_x3[nx0][nx1][nx2][nx4].makeNaturalSpline();
					}
					else if(spline_type[3] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx2_x3[nx0][nx1][nx2][nx4].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_dx2_x4
	#pragma omp parallel for
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					for(int nx4 = 0; nx4 < Nx4; nx4 ++)
					{
						spline_dx2_x4[nx0][nx1][nx2][nx3].x.push_back(x4[nx4]);
						spline_dx2_x4[nx0][nx1][nx2][nx3].f.push_back(fx2[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[4] == SPLINE_TYPE::NATURAL)
					{
						spline_dx2_x4[nx0][nx1][nx2][nx3].makeNaturalSpline();
					}
					else if(spline_type[4] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx2_x4[nx0][nx1][nx2][nx3].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_dx3_x4
	#pragma omp parallel for
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					for(int nx4 = 0; nx4 < Nx4; nx4 ++)
					{
						spline_dx3_x4[nx0][nx1][nx2][nx3].x.push_back(x4[nx4]);
						spline_dx3_x4[nx0][nx1][nx2][nx3].f.push_back(fx3[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[4] == SPLINE_TYPE::NATURAL)
					{
						spline_dx3_x4[nx0][nx1][nx2][nx3].makeNaturalSpline();
					}
					else if(spline_type[4] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx3_x4[nx0][nx1][nx2][nx3].makeClampedSpline();
					}
				}
			}
		}
	}

	fx0x1 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx0x2 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx0x3 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx0x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx1x2 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx1x3 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx1x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx2x3 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx2x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx3x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));

	#pragma omp parallel for
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					for(int nx4 = 0; nx4 < Nx4; nx4 ++)
					{
						if(nx1 != Nx1 - 1)
						{
							fx0x1[nx0][nx1][nx2][nx3][nx4] = spline_dx0_x1[nx0][nx2][nx3][nx4].c[nx1];
						}
						else
						{
							double Dx1 = x1[Nx1 - 1] - x1[Nx1 - 2];
							fx0x1[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx0_x1[nx0][nx2][nx3][nx4].a[nx1 - 1] * Dx1 * Dx1 + 2.0 * spline_dx0_x1[nx0][nx2][nx3][nx4].b[nx1 - 1] * Dx1 + spline_dx0_x1[nx0][nx2][nx3][nx4].c[nx1 - 1];
						}

						if(nx2 != Nx2 - 1)
						{
							fx0x2[nx0][nx1][nx2][nx3][nx4] = spline_dx0_x2[nx0][nx1][nx3][nx4].c[nx2];
						}
						else
						{
							double Dx2 = x2[Nx2 - 1] - x2[Nx2 - 2];
							fx0x2[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx0_x2[nx0][nx1][nx3][nx4].a[nx2 - 1] * Dx2 * Dx2 + 2.0 * spline_dx0_x2[nx0][nx1][nx3][nx4].b[nx2 - 1] * Dx2 + spline_dx0_x2[nx0][nx1][nx3][nx4].c[nx2 - 1];
						}

						if(nx3 != Nx3 - 1)
						{
							fx0x3[nx0][nx1][nx2][nx3][nx4] = spline_dx0_x3[nx0][nx1][nx2][nx4].c[nx3];
						}
						else
						{
							double Dx3 = x3[Nx3 - 1] - x3[Nx3 - 2];
							fx0x3[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx0_x3[nx0][nx1][nx2][nx4].a[nx3 - 1] * Dx3 * Dx3 + 2.0 * spline_dx0_x3[nx0][nx1][nx2][nx4].b[nx3 - 1] * Dx3 + spline_dx0_x3[nx0][nx1][nx2][nx4].c[nx3 - 1];
						}

						if(nx4 != Nx4 - 1)
						{
							fx0x4[nx0][nx1][nx2][nx3][nx4] = spline_dx0_x4[nx0][nx1][nx2][nx3].c[nx4];
						}
						else
						{
							double Dx4 = x4[Nx4 - 1] - x4[Nx4 - 2];
							fx0x4[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx0_x4[nx0][nx1][nx2][nx3].a[nx4 - 1] * Dx4 * Dx4 + 2.0 * spline_dx0_x4[nx0][nx1][nx2][nx3].b[nx4 - 1] * Dx4 + spline_dx0_x4[nx0][nx1][nx2][nx3].c[nx4 - 1];
						}

						if(nx2 != Nx2 - 1)
						{
							fx1x2[nx0][nx1][nx2][nx3][nx4] = spline_dx1_x2[nx0][nx1][nx3][nx4].c[nx2];
						}
						else
						{
							double Dx2 = x2[Nx2 - 1] - x2[Nx2 - 2];
							fx1x2[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx1_x2[nx0][nx1][nx3][nx4].a[nx2 - 1] * Dx2 * Dx2 + 2.0 * spline_dx1_x2[nx0][nx1][nx3][nx4].b[nx2 - 1] * Dx2 + spline_dx1_x2[nx0][nx1][nx3][nx4].c[nx2 - 1];
						}

						if(nx3 != Nx3 - 1)
						{
							fx1x3[nx0][nx1][nx2][nx3][nx4] = spline_dx1_x3[nx0][nx1][nx2][nx4].c[nx3];
						}
						else
						{
							double Dx3 = x3[Nx3 - 1] - x3[Nx3 - 2];
							fx1x3[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx1_x3[nx0][nx1][nx2][nx4].a[nx3 - 1] * Dx3 * Dx3 + 2.0 * spline_dx1_x3[nx0][nx1][nx2][nx4].b[nx3 - 1] * Dx3 + spline_dx1_x3[nx0][nx1][nx2][nx4].c[nx3 - 1];
						}

						if(nx4 != Nx4 - 1)
						{
							fx1x4[nx0][nx1][nx2][nx3][nx4] = spline_dx1_x4[nx0][nx1][nx2][nx3].c[nx4];
						}
						else
						{
							double Dx4 = x4[Nx4 - 1] - x4[Nx4 - 2];
							fx1x4[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx1_x4[nx0][nx1][nx2][nx3].a[nx4 - 1] * Dx4 * Dx4 + 2.0 * spline_dx1_x4[nx0][nx1][nx2][nx3].b[nx4 - 1] * Dx4 + spline_dx1_x4[nx0][nx1][nx2][nx3].c[nx4 - 1];
						}

						if(nx3 != Nx3 - 1)
						{
							fx2x3[nx0][nx1][nx2][nx3][nx4] = spline_dx2_x3[nx0][nx1][nx2][nx4].c[nx3];
						}
						else
						{
							double Dx3 = x3[Nx3 - 1] - x3[Nx3 - 2];
							fx2x3[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx2_x3[nx0][nx1][nx2][nx4].a[nx3 - 1] * Dx3 * Dx3 + 2.0 * spline_dx2_x3[nx0][nx1][nx2][nx4].b[nx3 - 1] * Dx3 + spline_dx2_x3[nx0][nx1][nx2][nx4].c[nx3 - 1];
						}

						if(nx4 != Nx4 - 1)
						{
							fx2x4[nx0][nx1][nx2][nx3][nx4] = spline_dx2_x4[nx0][nx1][nx2][nx3].c[nx4];
						}
						else
						{
							double Dx4 = x4[Nx4 - 1] - x4[Nx4 - 2];
							fx2x4[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx2_x4[nx0][nx1][nx2][nx3].a[nx4 - 1] * Dx4 * Dx4 + 2.0 * spline_dx2_x4[nx0][nx1][nx2][nx3].b[nx4 - 1] * Dx4 + spline_dx2_x4[nx0][nx1][nx2][nx3].c[nx4 - 1];
						}

						if(nx4 != Nx4 - 1)
						{
							fx3x4[nx0][nx1][nx2][nx3][nx4] = spline_dx3_x4[nx0][nx1][nx2][nx3].c[nx4];
						}
						else
						{
							double Dx4 = x4[Nx4 - 1] - x4[Nx4 - 2];
							fx3x4[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx3_x4[nx0][nx1][nx2][nx3].a[nx4 - 1] * Dx4 * Dx4 + 2.0 * spline_dx3_x4[nx0][nx1][nx2][nx3].b[nx4 - 1] * Dx4 + spline_dx3_x4[nx0][nx1][nx2][nx3].c[nx4 - 1];
						}
					}
				}
			}
		}
	}

	std::cout << "2nd derivative" << std::endl << std::flush;

	spline_dx0_x1.clear();
	spline_dx0_x2.clear();
	spline_dx0_x3.clear();
	spline_dx0_x4.clear();
	spline_dx1_x2.clear();
	spline_dx1_x3.clear();
	spline_dx1_x4.clear();
	spline_dx2_x3.clear();
	spline_dx2_x4.clear();
	spline_dx3_x4.clear();

	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx0dx1_x2 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx3, std::vector<Spline>(Nx4))));	// for fx0x1x2
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx0dx1_x3 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx4))));	// for fx0x1x3
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx0dx1_x4 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx3))));	// for fx0x1x4
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx0dx2_x3 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx4))));	// for fx0x2x3
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx0dx2_x4 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx3))));	// for fx0x2x4
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx0dx3_x4 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx3))));	// for fx0x3x4
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx1dx2_x3 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx4))));	// for fx1x2x3
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx1dx2_x4 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx3))));	// for fx1x2x4
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx1dx3_x4 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx3))));	// for fx1x3x4
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx2dx3_x4 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx3))));	// for fx2x3x4

	//MakeSpline spline_dx0dx1_x2
	#pragma omp parallel for
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx3 = 0; nx3 < Nx3; nx3 ++)
			{
				for(int nx4 = 0; nx4 < Nx4; nx4 ++)
				{
					for(int nx2 = 0; nx2 < Nx2; nx2 ++)
					{
						spline_dx0dx1_x2[nx0][nx1][nx3][nx4].x.push_back(x2[nx2]);
						spline_dx0dx1_x2[nx0][nx1][nx3][nx4].f.push_back(fx0x1[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[2] == SPLINE_TYPE::NATURAL)
					{
						spline_dx0dx1_x2[nx0][nx1][nx3][nx4].makeNaturalSpline();
					}
					else if(spline_type[2] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx0dx1_x2[nx0][nx1][nx3][nx4].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_dx0dx1_x3
	#pragma omp parallel for
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx4 = 0; nx4 < Nx4; nx4 ++)
				{
					for(int nx3 = 0; nx3 < Nx3; nx3 ++)
					{
						spline_dx0dx1_x3[nx0][nx1][nx2][nx4].x.push_back(x3[nx3]);
						spline_dx0dx1_x3[nx0][nx1][nx2][nx4].f.push_back(fx0x1[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[3] == SPLINE_TYPE::NATURAL)
					{
						spline_dx0dx1_x3[nx0][nx1][nx2][nx4].makeNaturalSpline();
					}
					else if(spline_type[3] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx0dx1_x3[nx0][nx1][nx2][nx4].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_dx0dx1_x4
	#pragma omp parallel for
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					for(int nx4 = 0; nx4 < Nx4; nx4 ++)
					{
						spline_dx0dx1_x4[nx0][nx1][nx2][nx3].x.push_back(x4[nx4]);
						spline_dx0dx1_x4[nx0][nx1][nx2][nx3].f.push_back(fx0x1[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[4] == SPLINE_TYPE::NATURAL)
					{
						spline_dx0dx1_x4[nx0][nx1][nx2][nx3].makeNaturalSpline();
					}
					else if(spline_type[4] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx0dx1_x4[nx0][nx1][nx2][nx3].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_dx0dx2_x3
	#pragma omp parallel for
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx4 = 0; nx4 < Nx4; nx4 ++)
				{
					for(int nx3 = 0; nx3 < Nx3; nx3 ++)
					{
						spline_dx0dx2_x3[nx0][nx1][nx2][nx4].x.push_back(x3[nx3]);
						spline_dx0dx2_x3[nx0][nx1][nx2][nx4].f.push_back(fx0x2[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[3] == SPLINE_TYPE::NATURAL)
					{
						spline_dx0dx2_x3[nx0][nx1][nx2][nx4].makeNaturalSpline();
					}
					else if(spline_type[3] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx0dx2_x3[nx0][nx1][nx2][nx4].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_dx0dx2_x4
	#pragma omp parallel for
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					for(int nx4 = 0; nx4 < Nx4; nx4 ++)
					{
						spline_dx0dx2_x4[nx0][nx1][nx2][nx3].x.push_back(x4[nx4]);
						spline_dx0dx2_x4[nx0][nx1][nx2][nx3].f.push_back(fx0x2[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[4] == SPLINE_TYPE::NATURAL)
					{
						spline_dx0dx2_x4[nx0][nx1][nx2][nx3].makeNaturalSpline();
					}
					else if(spline_type[4] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx0dx2_x4[nx0][nx1][nx2][nx3].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_dx0dx3_x4
	#pragma omp parallel for
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					for(int nx4 = 0; nx4 < Nx4; nx4 ++)
					{
						spline_dx0dx3_x4[nx0][nx1][nx2][nx3].x.push_back(x4[nx4]);
						spline_dx0dx3_x4[nx0][nx1][nx2][nx3].f.push_back(fx0x3[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[4] == SPLINE_TYPE::NATURAL)
					{
						spline_dx0dx3_x4[nx0][nx1][nx2][nx3].makeNaturalSpline();
					}
					else if(spline_type[4] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx0dx3_x4[nx0][nx1][nx2][nx3].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_dx1dx2_x3
	#pragma omp parallel for
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx4 = 0; nx4 < Nx4; nx4 ++)
				{
					for(int nx3 = 0; nx3 < Nx3; nx3 ++)
					{
						spline_dx1dx2_x3[nx0][nx1][nx2][nx4].x.push_back(x3[nx3]);
						spline_dx1dx2_x3[nx0][nx1][nx2][nx4].f.push_back(fx1x2[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[3] == SPLINE_TYPE::NATURAL)
					{
						spline_dx1dx2_x3[nx0][nx1][nx2][nx4].makeNaturalSpline();
					}
					else if(spline_type[3] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx1dx2_x3[nx0][nx1][nx2][nx4].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_dx1dx2_x4
	#pragma omp parallel for
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					for(int nx4 = 0; nx4 < Nx4; nx4 ++)
					{
						spline_dx1dx2_x4[nx0][nx1][nx2][nx3].x.push_back(x4[nx4]);
						spline_dx1dx2_x4[nx0][nx1][nx2][nx3].f.push_back(fx1x2[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[4] == SPLINE_TYPE::NATURAL)
					{
						spline_dx1dx2_x4[nx0][nx1][nx2][nx3].makeNaturalSpline();
					}
					else if(spline_type[4] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx1dx2_x4[nx0][nx1][nx2][nx3].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_dx1dx3_x4
	#pragma omp parallel for
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					for(int nx4 = 0; nx4 < Nx4; nx4 ++)
					{
						spline_dx1dx3_x4[nx0][nx1][nx2][nx3].x.push_back(x4[nx4]);
						spline_dx1dx3_x4[nx0][nx1][nx2][nx3].f.push_back(fx1x3[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[4] == SPLINE_TYPE::NATURAL)
					{
						spline_dx1dx3_x4[nx0][nx1][nx2][nx3].makeNaturalSpline();
					}
					else if(spline_type[4] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx1dx3_x4[nx0][nx1][nx2][nx3].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_dx2dx3_x4
	#pragma omp parallel for
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					for(int nx4 = 0; nx4 < Nx4; nx4 ++)
					{
						spline_dx2dx3_x4[nx0][nx1][nx2][nx3].x.push_back(x4[nx4]);
						spline_dx2dx3_x4[nx0][nx1][nx2][nx3].f.push_back(fx2x3[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[4] == SPLINE_TYPE::NATURAL)
					{
						spline_dx2dx3_x4[nx0][nx1][nx2][nx3].makeNaturalSpline();
					}
					else if(spline_type[4] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx2dx3_x4[nx0][nx1][nx2][nx3].makeClampedSpline();
					}
				}
			}
		}
	}
	
	fx0x1x2 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx0x1x3 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx0x1x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx0x2x3 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx0x2x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx0x3x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx1x2x3 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx1x2x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx1x3x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx2x3x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	
	#pragma omp parallel for
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					for(int nx4 = 0; nx4 < Nx4; nx4 ++)
					{
						if(nx2 != Nx2 - 1)
						{
							fx0x1x2[nx0][nx1][nx2][nx3][nx4] = spline_dx0dx1_x2[nx0][nx1][nx3][nx4].c[nx2];
						}
						else
						{
							double Dx2 = x2[Nx2 - 1] - x2[Nx2 - 2];
							fx0x1x2[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx0dx1_x2[nx0][nx1][nx3][nx4].a[nx2 - 1] * Dx2 * Dx2 + 2.0 * spline_dx0dx1_x2[nx0][nx1][nx3][nx4].b[nx2 - 1] * Dx2 + spline_dx0dx1_x2[nx0][nx1][nx3][nx4].c[nx2 - 1];
						}

						if(nx3 != Nx3 - 1)
						{
							fx0x1x3[nx0][nx1][nx2][nx3][nx4] = spline_dx0dx1_x3[nx0][nx1][nx2][nx4].c[nx3];
						}
						else
						{
							double Dx3 = x3[Nx3 - 1] - x3[Nx3 - 2];
							fx0x1x3[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx0dx1_x3[nx0][nx1][nx2][nx4].a[nx3 - 1] * Dx3 * Dx3 + 2.0 * spline_dx0dx1_x3[nx0][nx1][nx2][nx4].b[nx3 - 1] * Dx3 + spline_dx0dx1_x3[nx0][nx1][nx2][nx4].c[nx3 - 1];
						}

						if(nx4 != Nx4 - 1)
						{
							fx0x1x4[nx0][nx1][nx2][nx3][nx4] = spline_dx0dx1_x4[nx0][nx1][nx2][nx3].c[nx4];
						}
						else
						{
							double Dx4 = x4[Nx4 - 1] - x4[Nx4 - 2];
							fx0x1x4[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx0dx1_x4[nx0][nx1][nx2][nx3].a[nx4 - 1] * Dx4 * Dx4 + 2.0 * spline_dx0dx1_x4[nx0][nx1][nx2][nx3].b[nx4 - 1] * Dx4 + spline_dx0dx1_x4[nx0][nx1][nx2][nx3].c[nx4 - 1];
						}

						if(nx3 != Nx3 - 1)
						{
							fx0x2x3[nx0][nx1][nx2][nx3][nx4] = spline_dx0dx2_x3[nx0][nx1][nx2][nx4].c[nx3];
						}
						else
						{
							double Dx3 = x3[Nx3 - 1] - x3[Nx3 - 2];
							fx0x2x3[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx0dx2_x3[nx0][nx1][nx2][nx4].a[nx3 - 1] * Dx3 * Dx3 + 2.0 * spline_dx0dx2_x3[nx0][nx1][nx2][nx4].b[nx3 - 1] * Dx3 + spline_dx0dx2_x3[nx0][nx1][nx2][nx4].c[nx3 - 1];
						}

						if(nx4 != Nx4 - 1)
						{
							fx0x2x4[nx0][nx1][nx2][nx3][nx4] = spline_dx0dx2_x4[nx0][nx1][nx2][nx3].c[nx4];
						}
						else
						{
							double Dx4 = x4[Nx4 - 1] - x4[Nx4 - 2];
							fx0x2x4[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx0dx2_x4[nx0][nx1][nx2][nx3].a[nx4 - 1] * Dx4 * Dx4 + 2.0 * spline_dx0dx2_x4[nx0][nx1][nx2][nx3].b[nx4 - 1] * Dx4 + spline_dx0dx2_x4[nx0][nx1][nx2][nx3].c[nx4 - 1];
						}

						if(nx4 != Nx4 - 1)
						{
							fx0x3x4[nx0][nx1][nx2][nx3][nx4] = spline_dx0dx3_x4[nx0][nx1][nx2][nx3].c[nx4];
						}
						else
						{
							double Dx4 = x4[Nx4 - 1] - x4[Nx4 - 2];
							fx0x3x4[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx0dx3_x4[nx0][nx1][nx2][nx3].a[nx4 - 1] * Dx4 * Dx4 + 2.0 * spline_dx0dx3_x4[nx0][nx1][nx2][nx3].b[nx4 - 1] * Dx4 + spline_dx0dx3_x4[nx0][nx1][nx2][nx3].c[nx4 - 1];
						}

						if(nx3 != Nx3 - 1)
						{
							fx1x2x3[nx0][nx1][nx2][nx3][nx4] = spline_dx1dx2_x3[nx0][nx1][nx2][nx4].c[nx3];
						}
						else
						{
							double Dx3 = x3[Nx3 - 1] - x3[Nx3 - 2];
							fx1x2x3[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx1dx2_x3[nx0][nx1][nx2][nx4].a[nx3 - 1] * Dx3 * Dx3 + 2.0 * spline_dx1dx2_x3[nx0][nx1][nx2][nx4].b[nx3 - 1] * Dx3 + spline_dx1dx2_x3[nx0][nx1][nx2][nx4].c[nx3 - 1];
						}

						if(nx4 != Nx4 - 1)
						{
							fx1x2x4[nx0][nx1][nx2][nx3][nx4] = spline_dx1dx2_x4[nx0][nx1][nx2][nx3].c[nx4];
						}
						else
						{
							double Dx4 = x4[Nx4 - 1] - x4[Nx4 - 2];
							fx1x2x4[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx1dx2_x4[nx0][nx1][nx2][nx3].a[nx4 - 1] * Dx4 * Dx4 + 2.0 * spline_dx1dx2_x4[nx0][nx1][nx2][nx3].b[nx4 - 1] * Dx4 + spline_dx1dx2_x4[nx0][nx1][nx2][nx3].c[nx4 - 1];
						}

						if(nx4 != Nx4 - 1)
						{
							fx1x3x4[nx0][nx1][nx2][nx3][nx4] = spline_dx1dx3_x4[nx0][nx1][nx2][nx3].c[nx4];
						}
						else
						{
							double Dx4 = x4[Nx4 - 1] - x4[Nx4 - 2];
							fx1x3x4[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx1dx3_x4[nx0][nx1][nx2][nx3].a[nx4 - 1] * Dx4 * Dx4 + 2.0 * spline_dx1dx3_x4[nx0][nx1][nx2][nx3].b[nx4 - 1] * Dx4 + spline_dx1dx3_x4[nx0][nx1][nx2][nx3].c[nx4 - 1];
						}

						if(nx4 != Nx4 - 1)
						{
							fx2x3x4[nx0][nx1][nx2][nx3][nx4] = spline_dx2dx3_x4[nx0][nx1][nx2][nx3].c[nx4];
						}
						else
						{
							double Dx4 = x4[Nx4 - 1] - x4[Nx4 - 2];
							fx2x3x4[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx2dx3_x4[nx0][nx1][nx2][nx3].a[nx4 - 1] * Dx4 * Dx4 + 2.0 * spline_dx2dx3_x4[nx0][nx1][nx2][nx3].b[nx4 - 1] * Dx4 + spline_dx2dx3_x4[nx0][nx1][nx2][nx3].c[nx4 - 1];
						}
					}
				}
			}
		}
	}

	std::cout << "3rd derivative" << std::endl << std::flush;

	spline_dx0dx1_x2.clear();
	spline_dx0dx1_x3.clear();
	spline_dx0dx1_x4.clear();
	spline_dx0dx2_x3.clear();
	spline_dx0dx2_x4.clear();
	spline_dx0dx3_x4.clear();
	spline_dx1dx2_x3.clear();
	spline_dx1dx2_x4.clear();
	spline_dx1dx3_x4.clear();
	spline_dx2dx3_x4.clear();

	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx0dx1dx2_x3 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx4))));	// for fx0x1x2x3
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx0dx1dx2_x4 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx3))));	// for fx0x1x2x3
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx0dx1dx3_x4 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx3))));	// for fx0x1x2x3
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx0dx2dx3_x4 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx3))));	// for fx0x1x2x3
	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx1dx2dx3_x4 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx3))));	// for fx0x1x2x3

	//MakeSpline spline_dx0dx1dx2_x3
	#pragma omp parallel for
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx4 = 0; nx4 < Nx4; nx4 ++)
				{
					for(int nx3 = 0; nx3 < Nx3; nx3 ++)
					{
						spline_dx0dx1dx2_x3[nx0][nx1][nx2][nx4].x.push_back(x3[nx3]);
						spline_dx0dx1dx2_x3[nx0][nx1][nx2][nx4].f.push_back(fx0x1x2[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[3] == SPLINE_TYPE::NATURAL)
					{
						spline_dx0dx1dx2_x3[nx0][nx1][nx2][nx4].makeNaturalSpline();
					}
					else if(spline_type[3] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx0dx1dx2_x3[nx0][nx1][nx2][nx4].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_dx0dx1dx2_x4
	#pragma omp parallel for
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					for(int nx4 = 0; nx4 < Nx4; nx4 ++)
					{
						spline_dx0dx1dx2_x4[nx0][nx1][nx2][nx3].x.push_back(x4[nx4]);
						spline_dx0dx1dx2_x4[nx0][nx1][nx2][nx3].f.push_back(fx0x1x2[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[4] == SPLINE_TYPE::NATURAL)
					{
						spline_dx0dx1dx2_x4[nx0][nx1][nx2][nx3].makeNaturalSpline();
					}
					else if(spline_type[4] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx0dx1dx2_x4[nx0][nx1][nx2][nx3].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_dx0dx1dx3_x4
	#pragma omp parallel for
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					for(int nx4 = 0; nx4 < Nx4; nx4 ++)
					{
						spline_dx0dx1dx3_x4[nx0][nx1][nx2][nx3].x.push_back(x4[nx4]);
						spline_dx0dx1dx3_x4[nx0][nx1][nx2][nx3].f.push_back(fx0x1x3[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[4] == SPLINE_TYPE::NATURAL)
					{
						spline_dx0dx1dx3_x4[nx0][nx1][nx2][nx3].makeNaturalSpline();
					}
					else if(spline_type[4] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx0dx1dx3_x4[nx0][nx1][nx2][nx3].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_dx0dx2dx3_x4
	#pragma omp parallel for
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					for(int nx4 = 0; nx4 < Nx4; nx4 ++)
					{
						spline_dx0dx2dx3_x4[nx0][nx1][nx2][nx3].x.push_back(x4[nx4]);
						spline_dx0dx2dx3_x4[nx0][nx1][nx2][nx3].f.push_back(fx0x2x3[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[4] == SPLINE_TYPE::NATURAL)
					{
						spline_dx0dx2dx3_x4[nx0][nx1][nx2][nx3].makeNaturalSpline();
					}
					else if(spline_type[4] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx0dx2dx3_x4[nx0][nx1][nx2][nx3].makeClampedSpline();
					}
				}
			}
		}
	}

	//MakeSpline spline_dx1dx2dx3_x4
	#pragma omp parallel for
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					for(int nx4 = 0; nx4 < Nx4; nx4 ++)
					{
						spline_dx1dx2dx3_x4[nx0][nx1][nx2][nx3].x.push_back(x4[nx4]);
						spline_dx1dx2dx3_x4[nx0][nx1][nx2][nx3].f.push_back(fx1x2x3[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[4] == SPLINE_TYPE::NATURAL)
					{
						spline_dx1dx2dx3_x4[nx0][nx1][nx2][nx3].makeNaturalSpline();
					}
					else if(spline_type[4] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx1dx2dx3_x4[nx0][nx1][nx2][nx3].makeClampedSpline();
					}
				}
			}
		}
	}

	fx0x1x2x3 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx0x1x2x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx0x1x3x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx0x2x3x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));
	fx1x2x3x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));

	#pragma omp parallel for
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					for(int nx4 = 0; nx4 < Nx4; nx4 ++)
					{
						if(nx3 != Nx3 - 1)
						{
							fx0x1x2x3[nx0][nx1][nx2][nx3][nx4] = spline_dx0dx1dx2_x3[nx0][nx1][nx2][nx4].c[nx3];
						}
						else
						{
							double Dx3 = x3[Nx3 - 1] - x3[Nx3 - 2];
							fx0x1x2x3[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx0dx1dx2_x3[nx0][nx1][nx2][nx4].a[nx3 - 1] * Dx3 * Dx3 + 2.0 * spline_dx0dx1dx2_x3[nx0][nx1][nx2][nx4].b[nx3 - 1] * Dx3 + spline_dx0dx1dx2_x3[nx0][nx1][nx2][nx4].c[nx3 - 1];
						}

						if(nx4 != Nx4 - 1)
						{
							fx0x1x2x4[nx0][nx1][nx2][nx3][nx4] = spline_dx0dx1dx2_x4[nx0][nx1][nx2][nx3].c[nx4];
						}
						else
						{
							double Dx4 = x4[Nx4 - 1] - x4[Nx4 - 2];
							fx0x1x2x4[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx0dx1dx2_x4[nx0][nx1][nx2][nx3].a[nx4 - 1] * Dx4 * Dx4 + 2.0 * spline_dx0dx1dx2_x4[nx0][nx1][nx2][nx3].b[nx4 - 1] * Dx4 + spline_dx0dx1dx2_x4[nx0][nx1][nx2][nx3].c[nx4 - 1];
						}

						if(nx4 != Nx4 - 1)
						{
							fx0x1x3x4[nx0][nx1][nx2][nx3][nx4] = spline_dx0dx1dx3_x4[nx0][nx1][nx2][nx3].c[nx4];
						}
						else
						{
							double Dx4 = x4[Nx4 - 1] - x4[Nx4 - 2];
							fx0x1x3x4[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx0dx1dx3_x4[nx0][nx1][nx2][nx3].a[nx4 - 1] * Dx4 * Dx4 + 2.0 * spline_dx0dx1dx3_x4[nx0][nx1][nx2][nx3].b[nx4 - 1] * Dx4 + spline_dx0dx1dx3_x4[nx0][nx1][nx2][nx3].c[nx4 - 1];
						}

						if(nx4 != Nx4 - 1)
						{
							fx0x2x3x4[nx0][nx1][nx2][nx3][nx4] = spline_dx0dx2dx3_x4[nx0][nx1][nx2][nx3].c[nx4];
						}
						else
						{
							double Dx4 = x4[Nx4 - 1] - x4[Nx4 - 2];
							fx0x2x3x4[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx0dx2dx3_x4[nx0][nx1][nx2][nx3].a[nx4 - 1] * Dx4 * Dx4 + 2.0 * spline_dx0dx2dx3_x4[nx0][nx1][nx2][nx3].b[nx4 - 1] * Dx4 + spline_dx0dx2dx3_x4[nx0][nx1][nx2][nx3].c[nx4 - 1];
						}

						if(nx4 != Nx4 - 1)
						{
							fx1x2x3x4[nx0][nx1][nx2][nx3][nx4] = spline_dx1dx2dx3_x4[nx0][nx1][nx2][nx3].c[nx4];
						}
						else
						{
							double Dx4 = x4[Nx4 - 1] - x4[Nx4 - 2];
							fx1x2x3x4[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx1dx2dx3_x4[nx0][nx1][nx2][nx3].a[nx4 - 1] * Dx4 * Dx4 + 2.0 * spline_dx1dx2dx3_x4[nx0][nx1][nx2][nx3].b[nx4 - 1] * Dx4 + spline_dx1dx2dx3_x4[nx0][nx1][nx2][nx3].c[nx4 - 1];
						}
					}
				}
			}
		}
	}

	std::cout << "4th derivative" << std::endl << std::flush;

	spline_dx0dx1dx2_x3.clear();
	spline_dx0dx1dx2_x4.clear();
	spline_dx0dx1dx3_x4.clear();
	spline_dx0dx2dx3_x4.clear();
	spline_dx1dx2dx3_x4.clear();

	std::vector<std::vector<std::vector<std::vector<Spline>>>> spline_dx0dx1dx2dx3_x4 = std::vector<std::vector<std::vector<std::vector<Spline>>>>(Nx0, std::vector<std::vector<std::vector<Spline>>>(Nx1, std::vector<std::vector<Spline>>(Nx2, std::vector<Spline>(Nx3))));	// for fx0x1x2x3x4

	//MakeSpline spline_dx0dx1dx2dx3_x4
	#pragma omp parallel for
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					for(int nx4 = 0; nx4 < Nx4; nx4 ++)
					{
						spline_dx0dx1dx2dx3_x4[nx0][nx1][nx2][nx3].x.push_back(x4[nx4]);
						spline_dx0dx1dx2dx3_x4[nx0][nx1][nx2][nx3].f.push_back(fx0x1x2x3[nx0][nx1][nx2][nx3][nx4]);
					}

					if(spline_type[4] == SPLINE_TYPE::NATURAL)
					{
						spline_dx0dx1dx2dx3_x4[nx0][nx1][nx2][nx3].makeNaturalSpline();
					}
					else if(spline_type[4] == SPLINE_TYPE::CLAMPED)
					{
						spline_dx0dx1dx2dx3_x4[nx0][nx1][nx2][nx3].makeClampedSpline();
					}
				}
			}
		}
	}

	fx0x1x2x3x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(Nx0, std::vector<std::vector<std::vector<std::vector<double>>>>(Nx1, std::vector<std::vector<std::vector<double>>>(Nx2, std::vector<std::vector<double>>(Nx3, std::vector<double>(Nx4)))));

	#pragma omp parallel for
	for(int nx0 = 0; nx0 < Nx0; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3; nx3 ++)
				{
					for(int nx4 = 0; nx4 < Nx4; nx4 ++)
					{
						if(nx4 != Nx4 - 1)
						{
							fx0x1x2x3x4[nx0][nx1][nx2][nx3][nx4] = spline_dx0dx1dx2dx3_x4[nx0][nx1][nx2][nx3].c[nx4];
						}
						else
						{
							double Dx4 = x4[Nx4 - 1] - x4[Nx4 - 2];
							fx0x1x2x3x4[nx0][nx1][nx2][nx3][nx4] = 3.0 * spline_dx0dx1dx2dx3_x4[nx0][nx1][nx2][nx3].a[nx4 - 1] * Dx4 * Dx4 + 2.0 *spline_dx0dx1dx2dx3_x4[nx0][nx1][nx2][nx3].b[nx4 - 1] * Dx4 +spline_dx0dx1dx2dx3_x4[nx0][nx1][nx2][nx3].c[nx4 - 1];
						}
					}
				}
			}
		}
	}

	std::cout << "5th derivative" << std::endl << std::flush;

	spline_dx0dx1dx2dx3_x4.clear();

	//interval = std::vector<std::vector<std::vector<std::vector<std::vector<PentaCubicSpline>>>>>(Nx0 - 1, std::vector<std::vector<std::vector<std::vector<PentaCubicSpline>>>>(Nx1 - 1, std::vector<std::vector<std::vector<PentaCubicSpline>>>(Nx2 - 1, std::vector<std::vector<PentaCubicSpline>>(Nx3 - 1, std::vector<PentaCubicSpline>(Nx4 - 1)))));

	if(regular_grid == true)
	{
		A = std::vector<std::vector<double>>(1024, std::vector<double>(1024));
		double Dx0 = x0[1] - x0[0];
		double Dx1 = x1[1] - x1[0];
		double Dx2 = x2[1] - x2[0];
		double Dx3 = x3[1] - x3[0];
		double Dx4 = x4[1] - x4[0];

		auto pow = [](double v1, int v2)
		{
			if(v1 == 0 && v2 == 0)
			{
				return 1.0;
			}
			else if(v1 == 0)
			{
				return 0.0;
			}
			else if(v2 == 0)
			{
				return 1.0;
			}
			else
			{
				return std::pow(v1, double(v2));
			}
		};

		for(int nx4 = 0; nx4 < 2; nx4 ++)
		{
			double dx4 = Dx4 * (double(nx4));

			for(int nx3 = 0; nx3 < 2; nx3 ++)
			{
				double dx3 = Dx3 * (double(nx3));

				for(int nx2 = 0; nx2 < 2; nx2 ++)
				{
					double dx2 = Dx2 * (double(nx2));
					
					for(int nx1 = 0; nx1 < 2; nx1 ++)
					{
						double dx1 = Dx1 * (double(nx1));

						for(int nx0 = 0; nx0 < 2; nx0 ++)
						{
							double dx0 = Dx0 * (double(nx0));

							int row = nx4 * 16 + nx3 * 8 + nx2 * 4 + nx1 * 2 + nx0;

							for(int m = 0; m < 4; m ++)
							{
								for(int l = 0; l < 4; l ++)
								{
									for(int k = 0; k < 4; k ++)
									{
										for(int j = 0; j < 4; j ++)
										{
											for(int i = 0; i < 4; i ++)
											{
												int col = m * 256 + l * 64 + k * 16 + j * 4 + i;

												//f
												A[row][col] = pow(dx0, i) * pow(dx1, j) * pow(dx2, k) * pow(dx3, l) * pow(dx4, m);

												//fx
												if(i == 0)
												{
													A[row + 32 * 1][col] = 0.0;
												}
												else
												{
													A[row + 32 * 1][col] = double(i) * pow(dx0, i - 1) * pow(dx1, j) * pow(dx2, k) * pow(dx3, l) * pow(dx4, m);
												}

												if(j == 0)
												{
													A[row + 32 * 2][col] = 0.0;
												}
												else
												{
													A[row + 32 * 2][col] = double(j) * pow(dx0, i) * pow(dx1, j - 1) * pow(dx2, k) * pow(dx3, l) * pow(dx4, m);
												}

												if(k == 0)
												{
													A[row + 32 * 3][col] = 0.0;
												}
												else
												{
													A[row + 32 * 3][col] = double(k) * pow(dx0, i) * pow(dx1, j) * pow(dx2, k - 1) * pow(dx3, l) * pow(dx4, m);
												}

												if(l == 0)
												{
													A[row + 32 * 4][col] = 0.0;
												}
												else
												{
													A[row + 32 * 4][col] = double(l) * pow(dx0, i) * pow(dx1, j) * pow(dx2, k) * pow(dx3, l - 1) * pow(dx4, m);
												}

												if(m == 0)
												{
													A[row + 32 * 5][col] = 0.0;
												}
												else
												{
													A[row + 32 * 5][col] = double(m) * pow(dx0, i) * pow(dx1, j) * pow(dx2, k) * pow(dx3, l) * pow(dx4, m - 1);
												}

												//fxx
												if(i == 0 || j == 0)
												{
													A[row + 32 * 6][col] = 0.0;
												}
												else
												{
													A[row + 32 * 6][col] = double(i) * double(j) * pow(dx0, i - 1) * pow(dx1, j - 1) * pow(dx2, k) * pow(dx3, l) * pow(dx4, m);
												}

												if(i == 0 || k == 0)
												{
													A[row+ 32 * 7][col] = 0.0;
												}
												else
												{
													A[row+ 32 * 7][col] = double(i) * double(k) * pow(dx0, i - 1) * pow(dx1, j) * pow(dx2, k - 1) * pow(dx3, l) * pow(dx4, m);
												}

												if(i == 0 || l == 0)
												{
													A[row + 32 * 8][col] = 0.0;
												}
												else
												{
													A[row + 32 * 8][col] = double(i) * double(l) * pow(dx0, i - 1) * pow(dx1, j) * pow(dx2, k) * pow(dx3, l - 1) * pow(dx4, m);
												}

												if(i == 0 || m == 0)
												{
													A[row + 32 * 9][col] = 0.0;
												}
												else
												{
													A[row + 32 * 9][col] = double(i) * double(m) * pow(dx0, i - 1) * pow(dx1, j) * pow(dx2, k) * pow(dx3, l) * pow(dx4, m - 1);
												}

												if(j == 0 || k == 0)
												{
													A[row + 32 * 10][col] = 0.0;
												}
												else
												{
													A[row + 32 * 10][col] = double(j) * double(k) * pow(dx0, i) * pow(dx1, j - 1) * pow(dx2, k - 1) * pow(dx3, l) * pow(dx4, m);
												}

												if(j == 0 || l == 0)
												{
													A[row + 32 * 11][col] = 0.0;
												}
												else
												{
													A[row + 32 * 11][col] = double(j) * double(l) * pow(dx0, i) * pow(dx1, j - 1) * pow(dx2, k) * pow(dx3, l - 1) * pow(dx4, m);
												}

												if(j == 0 || m == 0)
												{
													A[row + 32 * 12][col] = 0.0;
												}
												else
												{
													A[row + 32 * 12][col] = double(j) * double(m) * pow(dx0, i) * pow(dx1, j - 1) * pow(dx2, k) * pow(dx3, l) * pow(dx4, m - 1);
												}

												if(k == 0 || l == 0)
												{
													A[row + 32 * 13][col] = 0.0;
												}
												else
												{
													A[row + 32 * 13][col] = double(k) * double(l) * pow(dx0, i) * pow(dx1, j) * pow(dx2, k - 1) * pow(dx3, l - 1) * pow(dx4, m);
												}

												if(k == 0 || m == 0)
												{
													A[row + 32 * 14][col] = 0.0;
												}
												else
												{
													A[row + 32 * 14][col] = double(k) * double(m) * pow(dx0, i) * pow(dx1, j) * pow(dx2, k - 1) * pow(dx3, l) * pow(dx4, m - 1);
												}

												if(l == 0 || m == 0)
												{
													A[row + 32 * 15][col] = 0.0;
												}
												else
												{
													A[row + 32 * 15][col] = double(l) * double(m) * pow(dx0, i) * pow(dx1, j) * pow(dx2, k) * pow(dx3, l - 1) * pow(dx4, m - 1);
												}

												//fxxx
												if(i == 0 || j == 0 || k == 0)
												{
													A[row + 32 * 16][col] = 0.0;
												}
												else
												{
													A[row + 32 * 16][col] = double(i) * double(j) * double(k) * pow(dx0, i - 1) * pow(dx1, j - 1) * pow(dx2, k - 1) * pow(dx3, l) * pow(dx4, m);
												}

												if(i == 0 || j == 0 || l == 0)
												{
													A[row + 32 * 17][col] = 0.0;
												}
												else
												{
													A[row + 32 * 17][col] = double(i) * double(j) * double(l) * pow(dx0, i - 1) * pow(dx1, j - 1) * pow(dx2, k) * pow(dx3, l - 1) * pow(dx4, m);
												}

												if(i == 0 || j == 0 || m == 0)
												{
													A[row + 32 * 18][col] = 0.0;
												}
												else
												{
													A[row + 32 * 18][col] = double(i) * double(j) * double(m) * pow(dx0, i - 1) * pow(dx1, j - 1) * pow(dx2, k) * pow(dx3, l) * pow(dx4, m - 1);
												}

												if(i == 0 || k == 0 || l == 0)
												{
													A[row + 32 * 19][col] = 0.0;
												}
												else
												{
													A[row + 32 * 19][col] = double(i) * double(k) * double(l) * pow(dx0, i - 1) * pow(dx1, j) * pow(dx2, k - 1) * pow(dx3, l - 1) * pow(dx4, m);
												}

												if(i == 0 || k == 0 || m == 0)
												{
													A[row + 32 * 20][col] = 0.0;
												}
												else
												{
													A[row + 32 * 20][col] = double(i) * double(k) * double(m) * pow(dx0, i - 1) * pow(dx1, j) * pow(dx2, k - 1) * pow(dx3, l) * pow(dx4, m - 1);
												}

												if(i == 0 || l == 0 || m == 0)
												{
													A[row + 32 * 21][col] = 0.0;
												}
												else
												{
													A[row + 32 * 21][col] = double(i) * double(l) * double(m) * pow(dx0, i - 1) * pow(dx1, j) * pow(dx2, k) * pow(dx3, l - 1) * pow(dx4, m - 1);
												}

												if(j == 0 || k == 0 || l == 0)
												{
													A[row + 32 * 22][col] = 0.0;
												}
												else
												{
													A[row + 32 * 22][col] = double(j) * double(k) * double(l) * pow(dx0, i) * pow(dx1, j - 1) * pow(dx2, k - 1) * pow(dx3, l - 1) * pow(dx4, m);
												}

												if(j == 0 || k == 0 || m == 0)
												{
													A[row + 32 * 23][col] = 0.0;
												}
												else
												{
													A[row + 32 * 23][col] = double(j) * double(k) * double(m) * pow(dx0, i) * pow(dx1, j - 1) * pow(dx2, k - 1) * pow(dx3, l) * pow(dx4, m - 1);
												}

												if(j == 0 || l == 0 || m == 0)
												{
													A[row + 32 * 24][col] = 0.0;
												}
												else
												{
													A[row + 32 * 24][col] = double(j) * double(l) * double(m) * pow(dx0, i) * pow(dx1, j - 1) * pow(dx2, k) * pow(dx3, l - 1) * pow(dx4, m - 1);
												}

												if(k == 0 || l == 0 || m == 0)
												{
													A[row + 32 * 25][col] = 0.0;
												}
												else
												{
													A[row + 32 * 25][col] = double(k) * double(l) * double(m) * pow(dx0, i) * pow(dx1, j) * pow(dx2, k - 1) * pow(dx3, l - 1) * pow(dx4, m - 1);
												}

												//fxxxx
												if(i == 0 || j == 0 || k == 0 || l == 0)
												{
													A[row + 32 * 26][col] = 0.0;
												}
												else
												{
													A[row + 32 * 26][col] = double(i) * double(j) * double(k) * double(l) * pow(dx0, i - 1) * pow(dx1, j - 1) * pow(dx2, k - 1) * pow(dx3, l - 1) * pow(dx4, m);
												}

												if(i == 0 || j == 0 || k == 0 || m == 0)
												{
													A[row + 32 * 27][col] = 0.0;
												}
												else
												{
													A[row + 32 * 27][col] = double(i) * double(j) * double(k) * double(m) * pow(dx0, i - 1) * pow(dx1, j - 1) * pow(dx2, k - 1) * pow(dx3, l) * pow(dx4, m - 1);
												}

												if(i == 0 || j == 0 || l == 0 || m == 0)
												{
													A[row + 32 * 28][col] = 0.0;
												}
												else
												{
													A[row + 32 * 28][col] = double(i) * double(j) * double(l) * double(m) * pow(dx0, i - 1) * pow(dx1, j - 1) * pow(dx2, k) * pow(dx3, l - 1) * pow(dx4, m - 1);
												}

												if(i == 0 || k == 0 || l == 0 || m == 0)
												{
													A[row + 32 * 29][col] = 0.0;
												}
												else
												{
													A[row + 32 * 29][col] = double(i) * double(k) * double(l) * double(m) * pow(dx0, i - 1) * pow(dx1, j) * pow(dx2, k - 1) * pow(dx3, l - 1) * pow(dx4, m - 1);
												}

												if(j == 0 || k == 0 || l == 0 || m == 0)
												{
													A[row + 32 * 30][col] = 0.0;
												}
												else
												{
													A[row + 32 * 30][col] = double(j) * double(k) * double(l) * double(m) * pow(dx0, i) * pow(dx1, j - 1) * pow(dx2, k - 1) * pow(dx3, l - 1) * pow(dx4, m - 1);
												}

												//fxxxxx
												if(i == 0 || j == 0 || k == 0 || l == 0 || m == 0)
												{
													A[row + 32 * 31][col] = 0.0;
												}
												else
												{
													A[row + 32 * 31][col] = double(i) * double(j) * double(k) * double(l) * double(m) * pow(dx0, i - 1) * pow(dx1, j - 1) * pow(dx2, k - 1) * pow(dx3, l - 1) * pow(dx4, m - 1);
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}

		invertMatrix(A);
	}

	std::ofstream output(filename);

	//std::cout << x0.size() << ", " << x1.size() << ", " << x2.size() << ", " << x3.size() << ", " << x4.size() << std::endl;

	output << std::fixed << std::setprecision(20) << std::scientific << Double2Hex(x0[0]);
	for(int nx = 1; nx < x0.size(); nx ++)
	{
		output << std::fixed << std::setprecision(20) << std::scientific << ", " << Double2Hex(x0[nx]);
	}
	output << std::endl;
	output << std::fixed << std::setprecision(20) << std::scientific << Double2Hex(x1[0]);
	for(int nx = 1; nx < x1.size(); nx ++)
	{
		output << std::fixed << std::setprecision(20) << std::scientific << ", " << Double2Hex(x1[nx]);
	}
	output << std::endl;
	output << std::fixed << std::setprecision(20) << std::scientific << Double2Hex(x2[0]);
	for(int nx = 1; nx < x2.size(); nx ++)
	{
		output << std::fixed << std::setprecision(20) << std::scientific << ", " << Double2Hex(x2[nx]);
	}
	output << std::endl;
	output << std::fixed << std::setprecision(20) << std::scientific << Double2Hex(x3[0]);
	for(int nx = 1; nx < x3.size(); nx ++)
	{
		output << std::fixed << std::setprecision(20) << std::scientific << ", " << Double2Hex(x3[nx]);
	}
	output << std::endl;
	output << std::fixed << std::setprecision(20) << std::scientific << Double2Hex(x4[0]);
	for(int nx = 1; nx < x4.size(); nx ++)
	{
		output << std::fixed << std::setprecision(20) << std::scientific << ", " << Double2Hex(x4[nx]);
	}
	output << std::endl;

	for(int nx0 = 0; nx0 < Nx0 - 1; nx0 ++)
	{
		for(int nx1 = 0; nx1 < Nx1 - 1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < Nx2 - 1; nx2 ++)
			{
				for(int nx3 = 0; nx3 < Nx3 - 1; nx3 ++)
				{
					for(int nx4 = 0; nx4 < Nx4 - 1; nx4 ++)
					{
						PentaCubicSpline spline;
						spline.p = std::vector<std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>>(2, std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(5))))));
						spline.f = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						spline.fx0 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						spline.fx1 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						spline.fx2 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						spline.fx3 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						spline.fx4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						spline.fx0x1 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						spline.fx0x2 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						spline.fx0x3 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						spline.fx0x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						spline.fx1x2 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						spline.fx1x3 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						spline.fx1x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						spline.fx2x3 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						spline.fx2x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						spline.fx3x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						spline.fx0x1x2 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						spline.fx0x1x3 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						spline.fx0x1x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						spline.fx0x2x3 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						spline.fx0x2x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						spline.fx0x3x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						spline.fx1x2x3 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						spline.fx1x2x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						spline.fx1x3x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						spline.fx2x3x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						spline.fx0x1x2x3 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						spline.fx0x1x2x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						spline.fx0x1x3x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						spline.fx0x2x3x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						spline.fx1x2x3x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));
						spline.fx0x1x2x3x4 = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(2)))));

						for(int i = 0; i < 2; i ++)
						{
							for(int j = 0; j < 2; j ++)
							{
								for(int k = 0; k < 2; k ++)
								{
									for(int l = 0; l < 2; l ++)
									{
										for(int m = 0; m < 2; m ++)
										{
											spline.p[i][j][k][l][m] = {x0[nx0 + i], x1[nx1 + j], x2[nx2 + k], x3[nx3 + l], x4[nx4 + m]};
											spline.f[i][j][k][l][m] = f[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											spline.fx0[i][j][k][l][m] = fx0[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											spline.fx1[i][j][k][l][m] = fx1[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											spline.fx2[i][j][k][l][m] = fx2[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											spline.fx3[i][j][k][l][m] = fx3[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											spline.fx4[i][j][k][l][m] = fx4[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											spline.fx0x1[i][j][k][l][m] = fx0x1[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											spline.fx0x2[i][j][k][l][m] = fx0x2[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											spline.fx0x3[i][j][k][l][m] = fx0x3[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											spline.fx0x4[i][j][k][l][m] = fx0x4[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											spline.fx1x2[i][j][k][l][m] = fx1x2[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											spline.fx1x3[i][j][k][l][m] = fx1x3[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											spline.fx1x4[i][j][k][l][m] = fx1x4[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											spline.fx2x3[i][j][k][l][m] = fx2x3[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											spline.fx2x4[i][j][k][l][m] = fx2x4[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											spline.fx3x4[i][j][k][l][m] = fx3x4[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											spline.fx0x1x2[i][j][k][l][m] = fx0x1x2[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											spline.fx0x1x3[i][j][k][l][m] = fx0x1x3[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											spline.fx0x1x4[i][j][k][l][m] = fx0x1x4[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											spline.fx0x2x3[i][j][k][l][m] = fx0x2x3[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											spline.fx0x2x4[i][j][k][l][m] = fx0x2x4[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											spline.fx0x3x4[i][j][k][l][m] = fx0x3x4[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											spline.fx1x2x3[i][j][k][l][m] = fx1x2x3[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											spline.fx1x2x4[i][j][k][l][m] = fx1x2x4[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											spline.fx1x3x4[i][j][k][l][m] = fx1x3x4[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											spline.fx2x3x4[i][j][k][l][m] = fx2x3x4[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											spline.fx0x1x2x3[i][j][k][l][m] = fx0x1x2x3[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											spline.fx0x1x2x4[i][j][k][l][m] = fx0x1x2x4[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											spline.fx0x1x3x4[i][j][k][l][m] = fx0x1x3x4[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											spline.fx0x2x3x4[i][j][k][l][m] = fx0x2x3x4[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											spline.fx1x2x3x4[i][j][k][l][m] = fx1x2x3x4[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
											spline.fx0x1x2x3x4[i][j][k][l][m] = fx0x1x2x3x4[nx0 + i][nx1 + j][nx2 + k][nx3 + l][nx4 + m];
										}
									}
								}
							}
						}

						if(regular_grid == false)
						{
							spline.makeInterpolator();
						}
						else if(regular_grid == true)
						{
							spline.makeInterpolator(A);
						}

						output << std::dec << nx0 << ", " << nx1 << ", " << nx2 << ", " << nx3 << ", " << nx4 << std::flush;
						for(int i = 0; i < 4; i ++)
						{
							for(int j = 0; j < 4; j ++)
							{
								for(int k = 0; k < 4; k ++)
								{
									for(int l = 0; l < 4; l ++)
									{
										for(int m = 0; m < 4; m ++)
										{
											//std::cout << std::dec << nx0 << ", " << nx1 << ", " << nx2 << ", " << nx3 << ", " << nx4 << ", " << i << ", " << j << ", " << k << ", " << l << ", " << m << std::endl;
											output << std::fixed << std::setprecision(20) << std::scientific << ", " << Double2Hex(spline.a[i][j][k][l][m]) << std::flush;
										}
									}
								}
							}
						}
						output << std::endl << std::flush;

						spline.clearData();
					}
				}
			}
		}
	}

	clearData();

	return;
}

inline void PentaCubicInterpolator::PentaCubicSpline::makeInterpolator(std::vector<std::vector<double>>& A)
{
	std::vector<double> rhs(1024);
	std::vector<double> ans(1024);

	int row;

	for(int nx4 = 0; nx4 < 2; nx4 ++)
	{
		for(int nx3 = 0; nx3 < 2; nx3 ++)
		{
			for(int nx2 = 0; nx2 < 2; nx2 ++)
			{
				for(int nx1 = 0; nx1 < 2; nx1 ++)
				{
					for(int nx0 = 0; nx0 < 2; nx0 ++)
					{
						row = nx4 * 16 + nx3 * 8 + nx2 * 4 + nx1 * 2 + nx0;
						rhs[row] = f[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 1] = fx0[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 2] = fx1[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 3] = fx2[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 4] = fx3[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 5] = fx4[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 6] = fx0x1[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 7] = fx0x2[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 8] = fx0x3[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 9] = fx0x4[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 10] = fx1x2[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 11] = fx1x3[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 12] = fx1x4[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 13] = fx2x3[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 14] = fx2x4[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 15] = fx3x4[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 16] = fx0x1x2[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 17] = fx0x1x3[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 18] = fx0x1x4[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 19] = fx0x2x3[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 20] = fx0x2x4[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 21] = fx0x3x4[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 22] = fx1x2x3[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 23] = fx1x2x4[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 24] = fx1x3x4[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 25] = fx2x3x4[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 26] = fx0x1x2x3[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 27] = fx0x1x2x4[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 28] = fx0x1x3x4[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 29] = fx0x2x3x4[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 30] = fx1x2x3x4[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 31] = fx0x1x2x3x4[nx0][nx1][nx2][nx3][nx4];
					}
				}
			}
		}
	}

	#pragma omp parallel for
	for(int i = 0; i < rhs.size(); i ++)
	{
		ans[i] = 0.0;
		for(int j = 0; j < rhs.size(); j ++)
		{
			ans[i] += A[i][j] * rhs[j];
		}
	}

	a = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(4, std::vector<std::vector<std::vector<std::vector<double>>>>(4, std::vector<std::vector<std::vector<double>>>(4, std::vector<std::vector<double>>(4, std::vector<double>(4)))));

	for(int nx4 = 0; nx4 < 4; nx4 ++)
	{
		for(int nx3 = 0; nx3 < 4; nx3 ++)
		{
			for(int nx2 = 0; nx2 < 4; nx2 ++)
			{
				for(int nx1 = 0; nx1 < 4; nx1 ++)
				{
					for(int nx0 = 0; nx0 < 4; nx0 ++)
					{
						int idx = nx4 * 256 + nx3 * 64 + nx2 * 16 + nx1 * 4 + nx0;
						a[nx0][nx1][nx2][nx3][nx4] = ans[idx];
					}
				}
			}
		}
	}

	return;
}

inline double PentaCubicInterpolator::PentaCubicSpline::interpolation(double dx0, double dx1, double dx2, double dx3, double dx4)
{
	double result = 0.0;

	//std::cout << x00 << ", " << x10 << ", " << x20 << ", " << x30 << ", " << x40 << std::flush;

	//std::cout << ", " << dx0 << ", " << dx1 << ", " << dx2 << ", " << dx3 << ", " << dx4 << std::endl << std::flush;

	auto pow = [](double v1, int v2)
	{
		if(v1 == 0 && v2 == 0)
		{
			return 1.0;
		}
		else if(v1 == 0)
		{
			return 0.0;
		}
		else if(v2 == 0)
		{
			return 1.0;
		}
		else
		{
			return std::pow(v1, double(v2));
		}
    };

	for(int i = 0; i < 4; i ++)
	{
		for(int j = 0; j < 4; j ++)
		{
			for(int k = 0; k < 4; k ++)
			{
				for(int l = 0; l < 4; l ++)
				{
					for(int m = 0; m < 4; m ++)
					{
						result += a[i][j][k][l][m] * pow(dx0, i) * pow(dx1, j) * pow(dx2, k) * pow(dx3, l) * pow(dx4, m);
					}
				}
			}
		}
	}

	return result;
}

inline void PentaCubicInterpolator::PentaCubicSpline::makeInterpolator(void)
{
	std::vector<std::vector<double>> A = std::vector<std::vector<double>>(1024, std::vector<double>(1024));

	Dx0 = p[1][0][0][0][0][0] - p[0][0][0][0][0][0];
	Dx1 = p[0][1][0][0][0][1] - p[0][0][0][0][0][1];
	Dx2 = p[0][0][1][0][0][2] - p[0][0][0][0][0][2];
	Dx3 = p[0][0][0][1][0][3] - p[0][0][0][0][0][3];
	Dx4 = p[0][0][0][0][1][4] - p[0][0][0][0][0][4];

	std::vector<double> rhs(1024);

	auto pow = [](double v1, int v2)
	{
		if(v1 == 0 && v2 == 0)
		{
			return 1.0;
		}
		else if(v1 == 0)
		{
			return 0.0;
		}
		else if(v2 == 0)
		{
			return 1.0;
		}
		else
		{
			return std::pow(v1, double(v2));
		}
	};

	int row;

	for(int nx4 = 0; nx4 < 2; nx4 ++)
	{
		double dx4 = Dx4 * (double(nx4));

		for(int nx3 = 0; nx3 < 2; nx3 ++)
		{
			double dx3 = Dx3 * (double(nx3));

			for(int nx2 = 0; nx2 < 2; nx2 ++)
			{
				double dx2 = Dx2 * (double(nx2));
				
				for(int nx1 = 0; nx1 < 2; nx1 ++)
				{
					double dx1 = Dx1 * (double(nx1));

					for(int nx0 = 0; nx0 < 2; nx0 ++)
					{
						double dx0 = Dx0 * (double(nx0));

						int row = nx4 * 16 + nx3 * 8 + nx2 * 4 + nx1 * 2 + nx0;

						for(int m = 0; m < 4; m ++)
						{
							for(int l = 0; l < 4; l ++)
							{
								for(int k = 0; k < 4; k ++)
								{
									for(int j = 0; j < 4; j ++)
									{
										for(int i = 0; i < 4; i ++)
										{
											int col = m * 256 + l * 64 + k * 16 + j * 4 + i;

											//f
											A[row][col] = pow(dx0, i) * pow(dx1, j) * pow(dx2, k) * pow(dx3, l) * pow(dx4, m);

											//fx
											if(i == 0)
											{
												A[row + 32 * 1][col] = 0.0;
											}
											else
											{
												A[row + 32 * 1][col] = double(i) * pow(dx0, i - 1) * pow(dx1, j) * pow(dx2, k) * pow(dx3, l) * pow(dx4, m);
											}

											if(j == 0)
											{
												A[row + 32 * 2][col] = 0.0;
											}
											else
											{
												A[row + 32 * 2][col] = double(j) * pow(dx0, i) * pow(dx1, j - 1) * pow(dx2, k) * pow(dx3, l) * pow(dx4, m);
											}

											if(k == 0)
											{
												A[row + 32 * 3][col] = 0.0;
											}
											else
											{
												A[row + 32 * 3][col] = double(k) * pow(dx0, i) * pow(dx1, j) * pow(dx2, k - 1) * pow(dx3, l) * pow(dx4, m);
											}

											if(l == 0)
											{
												A[row + 32 * 4][col] = 0.0;
											}
											else
											{
												A[row + 32 * 4][col] = double(l) * pow(dx0, i) * pow(dx1, j) * pow(dx2, k) * pow(dx3, l - 1) * pow(dx4, m);
											}

											if(m == 0)
											{
												A[row + 32 * 5][col] = 0.0;
											}
											else
											{
												A[row + 32 * 5][col] = double(m) * pow(dx0, i) * pow(dx1, j) * pow(dx2, k) * pow(dx3, l) * pow(dx4, m - 1);
											}

											//fxx
											if(i == 0 || j == 0)
											{
												A[row + 32 * 6][col] = 0.0;
											}
											else
											{
												A[row + 32 * 6][col] = double(i) * double(j) * pow(dx0, i - 1) * pow(dx1, j - 1) * pow(dx2, k) * pow(dx3, l) * pow(dx4, m);
											}

											if(i == 0 || k == 0)
											{
												A[row+ 32 * 7][col] = 0.0;
											}
											else
											{
												A[row+ 32 * 7][col] = double(i) * double(k) * pow(dx0, i - 1) * pow(dx1, j) * pow(dx2, k - 1) * pow(dx3, l) * pow(dx4, m);
											}

											if(i == 0 || l == 0)
											{
												A[row + 32 * 8][col] = 0.0;
											}
											else
											{
												A[row + 32 * 8][col] = double(i) * double(l) * pow(dx0, i - 1) * pow(dx1, j) * pow(dx2, k) * pow(dx3, l - 1) * pow(dx4, m);
											}

											if(i == 0 || m == 0)
											{
												A[row + 32 * 9][col] = 0.0;
											}
											else
											{
												A[row + 32 * 9][col] = double(i) * double(m) * pow(dx0, i - 1) * pow(dx1, j) * pow(dx2, k) * pow(dx3, l) * pow(dx4, m - 1);
											}

											if(j == 0 || k == 0)
											{
												A[row + 32 * 10][col] = 0.0;
											}
											else
											{
												A[row + 32 * 10][col] = double(j) * double(k) * pow(dx0, i) * pow(dx1, j - 1) * pow(dx2, k - 1) * pow(dx3, l) * pow(dx4, m);
											}

											if(j == 0 || l == 0)
											{
												A[row + 32 * 11][col] = 0.0;
											}
											else
											{
												A[row + 32 * 11][col] = double(j) * double(l) * pow(dx0, i) * pow(dx1, j - 1) * pow(dx2, k) * pow(dx3, l - 1) * pow(dx4, m);
											}

											if(j == 0 || m == 0)
											{
												A[row + 32 * 12][col] = 0.0;
											}
											else
											{
												A[row + 32 * 12][col] = double(j) * double(m) * pow(dx0, i) * pow(dx1, j - 1) * pow(dx2, k) * pow(dx3, l) * pow(dx4, m - 1);
											}

											if(k == 0 || l == 0)
											{
												A[row + 32 * 13][col] = 0.0;
											}
											else
											{
												A[row + 32 * 13][col] = double(k) * double(l) * pow(dx0, i) * pow(dx1, j) * pow(dx2, k - 1) * pow(dx3, l - 1) * pow(dx4, m);
											}

											if(k == 0 || m == 0)
											{
												A[row + 32 * 14][col] = 0.0;
											}
											else
											{
												A[row + 32 * 14][col] = double(k) * double(m) * pow(dx0, i) * pow(dx1, j) * pow(dx2, k - 1) * pow(dx3, l) * pow(dx4, m - 1);
											}

											if(l == 0 || m == 0)
											{
												A[row + 32 * 15][col] = 0.0;
											}
											else
											{
												A[row + 32 * 15][col] = double(l) * double(m) * pow(dx0, i) * pow(dx1, j) * pow(dx2, k) * pow(dx3, l - 1) * pow(dx4, m - 1);
											}

											//fxxx
											if(i == 0 || j == 0 || k == 0)
											{
												A[row + 32 * 16][col] = 0.0;
											}
											else
											{
												A[row + 32 * 16][col] = double(i) * double(j) * double(k) * pow(dx0, i - 1) * pow(dx1, j - 1) * pow(dx2, k - 1) * pow(dx3, l) * pow(dx4, m);
											}

											if(i == 0 || j == 0 || l == 0)
											{
												A[row + 32 * 17][col] = 0.0;
											}
											else
											{
												A[row + 32 * 17][col] = double(i) * double(j) * double(l) * pow(dx0, i - 1) * pow(dx1, j - 1) * pow(dx2, k) * pow(dx3, l - 1) * pow(dx4, m);
											}

											if(i == 0 || j == 0 || m == 0)
											{
												A[row + 32 * 18][col] = 0.0;
											}
											else
											{
												A[row + 32 * 18][col] = double(i) * double(j) * double(m) * pow(dx0, i - 1) * pow(dx1, j - 1) * pow(dx2, k) * pow(dx3, l) * pow(dx4, m - 1);
											}

											if(i == 0 || k == 0 || l == 0)
											{
												A[row + 32 * 19][col] = 0.0;
											}
											else
											{
												A[row + 32 * 19][col] = double(i) * double(k) * double(l) * pow(dx0, i - 1) * pow(dx1, j) * pow(dx2, k - 1) * pow(dx3, l - 1) * pow(dx4, m);
											}

											if(i == 0 || k == 0 || m == 0)
											{
												A[row + 32 * 20][col] = 0.0;
											}
											else
											{
												A[row + 32 * 20][col] = double(i) * double(k) * double(m) * pow(dx0, i - 1) * pow(dx1, j) * pow(dx2, k - 1) * pow(dx3, l) * pow(dx4, m - 1);
											}

											if(i == 0 || l == 0 || m == 0)
											{
												A[row + 32 * 21][col] = 0.0;
											}
											else
											{
												A[row + 32 * 21][col] = double(i) * double(l) * double(m) * pow(dx0, i - 1) * pow(dx1, j) * pow(dx2, k) * pow(dx3, l - 1) * pow(dx4, m - 1);
											}

											if(j == 0 || k == 0 || l == 0)
											{
												A[row + 32 * 22][col] = 0.0;
											}
											else
											{
												A[row + 32 * 22][col] = double(j) * double(k) * double(l) * pow(dx0, i) * pow(dx1, j - 1) * pow(dx2, k - 1) * pow(dx3, l - 1) * pow(dx4, m);
											}

											if(j == 0 || k == 0 || m == 0)
											{
												A[row + 32 * 23][col] = 0.0;
											}
											else
											{
												A[row + 32 * 23][col] = double(j) * double(k) * double(m) * pow(dx0, i) * pow(dx1, j - 1) * pow(dx2, k - 1) * pow(dx3, l) * pow(dx4, m - 1);
											}

											if(j == 0 || l == 0 || m == 0)
											{
												A[row + 32 * 24][col] = 0.0;
											}
											else
											{
												A[row + 32 * 24][col] = double(j) * double(l) * double(m) * pow(dx0, i) * pow(dx1, j - 1) * pow(dx2, k) * pow(dx3, l - 1) * pow(dx4, m - 1);
											}

											if(k == 0 || l == 0 || m == 0)
											{
												A[row + 32 * 25][col] = 0.0;
											}
											else
											{
												A[row + 32 * 25][col] = double(k) * double(l) * double(m) * pow(dx0, i) * pow(dx1, j) * pow(dx2, k - 1) * pow(dx3, l - 1) * pow(dx4, m - 1);
											}

											//fxxxx
											if(i == 0 || j == 0 || k == 0 || l == 0)
											{
												A[row + 32 * 26][col] = 0.0;
											}
											else
											{
												A[row + 32 * 26][col] = double(i) * double(j) * double(k) * double(l) * pow(dx0, i - 1) * pow(dx1, j - 1) * pow(dx2, k - 1) * pow(dx3, l - 1) * pow(dx4, m);
											}

											if(i == 0 || j == 0 || k == 0 || m == 0)
											{
												A[row + 32 * 27][col] = 0.0;
											}
											else
											{
												A[row + 32 * 27][col] = double(i) * double(j) * double(k) * double(m) * pow(dx0, i - 1) * pow(dx1, j - 1) * pow(dx2, k - 1) * pow(dx3, l) * pow(dx4, m - 1);
											}

											if(i == 0 || j == 0 || l == 0 || m == 0)
											{
												A[row + 32 * 28][col] = 0.0;
											}
											else
											{
												A[row + 32 * 28][col] = double(i) * double(j) * double(l) * double(m) * pow(dx0, i - 1) * pow(dx1, j - 1) * pow(dx2, k) * pow(dx3, l - 1) * pow(dx4, m - 1);
											}

											if(i == 0 || k == 0 || l == 0 || m == 0)
											{
												A[row + 32 * 29][col] = 0.0;
											}
											else
											{
												A[row + 32 * 29][col] = double(i) * double(k) * double(l) * double(m) * pow(dx0, i - 1) * pow(dx1, j) * pow(dx2, k - 1) * pow(dx3, l - 1) * pow(dx4, m - 1);
											}

											if(j == 0 || k == 0 || l == 0 || m == 0)
											{
												A[row + 32 * 30][col] = 0.0;
											}
											else
											{
												A[row + 32 * 30][col] = double(j) * double(k) * double(l) * double(m) * pow(dx0, i) * pow(dx1, j - 1) * pow(dx2, k - 1) * pow(dx3, l - 1) * pow(dx4, m - 1);
											}

											//fxxxxx
											if(i == 0 || j == 0 || k == 0 || l == 0 || m == 0)
											{
												A[row + 32 * 31][col] = 0.0;
											}
											else
											{
												A[row + 32 * 31][col] = double(i) * double(j) * double(k) * double(l) * double(m) * pow(dx0, i - 1) * pow(dx1, j - 1) * pow(dx2, k - 1) * pow(dx3, l - 1) * pow(dx4, m - 1);
											}
										}
									}
								}
							}
						}
					
						rhs[row] = f[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 1] = fx0[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 2] = fx1[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 3] = fx2[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 4] = fx3[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 5] = fx4[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 6] = fx0x1[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 7] = fx0x2[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 8] = fx0x3[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 9] = fx0x4[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 10] = fx1x2[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 11] = fx1x3[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 12] = fx1x4[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 13] = fx2x3[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 14] = fx2x4[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 15] = fx3x4[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 16] = fx0x1x2[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 17] = fx0x1x3[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 18] = fx0x1x4[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 19] = fx0x2x3[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 20] = fx0x2x4[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 21] = fx0x3x4[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 22] = fx1x2x3[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 23] = fx1x2x4[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 24] = fx1x3x4[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 25] = fx2x3x4[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 26] = fx0x1x2x3[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 27] = fx0x1x2x4[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 28] = fx0x1x3x4[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 29] = fx0x2x3x4[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 30] = fx1x2x3x4[nx0][nx1][nx2][nx3][nx4];
						rhs[row + 32 * 31] = fx0x1x2x3x4[nx0][nx1][nx2][nx3][nx4];
					}
				}
			}
		}
	}

	invertMatrix(A, rhs);

	a = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(4, std::vector<std::vector<std::vector<std::vector<double>>>>(4, std::vector<std::vector<std::vector<double>>>(4, std::vector<std::vector<double>>(4, std::vector<double>(4)))));

	for(int nx4 = 0; nx4 < 4; nx4 ++)
	{
		for(int nx3 = 0; nx3 < 4; nx3 ++)
		{
			for(int nx2 = 0; nx2 < 4; nx2 ++)
			{
				for(int nx1 = 0; nx1 < 4; nx1 ++)
				{
					for(int nx0 = 0; nx0 < 4; nx0 ++)
					{
						int idx = nx4 * 256 + nx3 * 64 + nx2 * 16 + nx1 * 4 + nx0;
						a[nx0][nx1][nx2][nx3][nx4] = rhs[idx];
					}
				}
			}
		}
	}

	return;
}

inline double PentaCubicInterpolator::interpolation(double x00, double x10, double x20, double x30, double x40)
{
	double result = 0.0;

	int nx0 = 0;
	int nx1 = 0;
	int nx2 = 0;
	int nx3 = 0;
	int nx4 = 0;

	for(int i = 0; i < x0.size() - 1; i ++)
	{
		if(x0[i] <= x00 && x00 <= x0[i + 1])
		{
			nx0 = i;
			break;
		}
	}
	for(int i = 0; i < x1.size() - 1; i ++)
	{
		if(x1[i] <= x10 && x10 <= x1[i + 1])
		{
			nx1 = i;
			break;
		}
	}
	for(int i = 0; i < x2.size() - 1; i ++)
	{
		if(x2[i] <= x20 && x20 <= x2[i + 1])
		{
			nx2 = i;
			break;
		}
	}
	for(int i = 0; i < x3.size() - 1; i ++)
	{
		if(x3[i] <= x30 && x30 <= x3[i + 1])
		{
			nx3 = i;
			break;
		}
	}
	for(int i = 0; i < x4.size() - 1; i ++)
	{
		if(x4[i] <= x40 && x40 <= x4[i + 1])
		{
			nx4 = i;
			break;
		}
	}

	// std::cout << nx0 << ", " << nx1 << ", " << nx2 << ", " << nx3 << ", " << nx4 << std::endl << std::flush;
	// std::cout << interval.size() << std::flush;
	// std::cout << ", " << interval[nx0].size() << std::flush;
	// std::cout << ", " << interval[nx0][nx1].size() << std::flush;
	// std::cout << ", " << interval[nx0][nx1][nx2].size() << std::flush;
	// std::cout << ", " << interval[nx0][nx1][nx2][nx3].size() << std::endl << std::flush;

	result = interval[nx0][nx1][nx2][nx3][nx4].interpolation(x00 - x0[nx0], x10 - x1[nx1], x20 - x2[nx2], x30 - x3[nx3], x40 - x4[nx4]);

	return result;
}

inline double PentaCubicInterpolator::interpolation(std::vector<double> x0)
{
	return interpolation(x0[0], x0[1], x0[2], x0[3], x0[4]);
}

inline void PentaCubicInterpolator::initialization(void)
{
	f = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(x0.size(), std::vector<std::vector<std::vector<std::vector<double>>>>(x1.size(), std::vector<std::vector<std::vector<double>>>(x2.size(), std::vector<std::vector<double>>(x3.size(), std::vector<double>(x4.size())))));

	return;
}

inline void PentaCubicInterpolator::exportInterpolator(std::string filename)
{
	std::ofstream output(filename);

	//std::cout << x0.size() << ", " << x1.size() << ", " << x2.size() << ", " << x3.size() << ", " << x4.size() << std::endl;

	output << std::fixed << std::setprecision(20) << std::scientific << Double2Hex(x0[0]);
	for(int nx = 1; nx < x0.size(); nx ++)
	{
		output << std::fixed << std::setprecision(20) << std::scientific << ", " << Double2Hex(x0[nx]);
	}
	output << std::endl;
	output << std::fixed << std::setprecision(20) << std::scientific << Double2Hex(x1[0]);
	for(int nx = 1; nx < x1.size(); nx ++)
	{
		output << std::fixed << std::setprecision(20) << std::scientific << ", " << Double2Hex(x1[nx]);
	}
	output << std::endl;
	output << std::fixed << std::setprecision(20) << std::scientific << Double2Hex(x2[0]);
	for(int nx = 1; nx < x2.size(); nx ++)
	{
		output << std::fixed << std::setprecision(20) << std::scientific << ", " << Double2Hex(x2[nx]);
	}
	output << std::endl;
	output << std::fixed << std::setprecision(20) << std::scientific << Double2Hex(x3[0]);
	for(int nx = 1; nx < x3.size(); nx ++)
	{
		output << std::fixed << std::setprecision(20) << std::scientific << ", " << Double2Hex(x3[nx]);
	}
	output << std::endl;
	output << std::fixed << std::setprecision(20) << std::scientific << Double2Hex(x4[0]);
	for(int nx = 1; nx < x4.size(); nx ++)
	{
		output << std::fixed << std::setprecision(20) << std::scientific << ", " << Double2Hex(x4[nx]);
	}
	output << std::endl;

	for(int nx0 = 0; nx0 < x0.size() - 1; nx0 ++)
	{
		for(int nx1 = 0; nx1 < x1.size() - 1; nx1 ++)
		{
			for(int nx2 = 0; nx2 < x2.size() - 1; nx2 ++)
			{
				for(int nx3 = 0; nx3 < x3.size() - 1; nx3 ++)
				{
					for(int nx4 = 0; nx4 < x4.size() - 1; nx4 ++)
					{
						output << std::dec << nx0 << ", " << nx1 << ", " << nx2 << ", " << nx3 << ", " << nx4 << std::flush;

						for(int i = 0; i < 4; i ++)
						{
							for(int j = 0; j < 4; j ++)
							{
								for(int k = 0; k < 4; k ++)
								{
									for(int l = 0; l < 4; l ++)
									{
										for(int m = 0; m < 4; m ++)
										{
											//std::cout << std::dec << nx0 << ", " << nx1 << ", " << nx2 << ", " << nx3 << ", " << nx4 << ", " << i << ", " << j << ", " << k << ", " << l << ", " << m << std::endl;
											output << std::fixed << std::setprecision(20) << std::scientific << ", " << Double2Hex(interval[nx0][nx1][nx2][nx3][nx4].a[i][j][k][l][m]) << std::flush;
										}
									}
								}
							}
						}

						output << std::endl << std::flush;
					}
				}
			}
		}
	}

	return;
}

inline void PentaCubicInterpolator::importInterpolator(std::string filename)
{
	std::ifstream input(filename);

	std::string str;
	std::vector<double> x0in, x1in, x2in, x3in, x4in;
	
	{
		std::getline(input, str);
		if(str[0] != '#' && str.size() > 0)
		{
			auto data = spritString(str, ',');
			for(int i = 0; i < data.size(); i ++)
			{
				x0in.push_back(Hex2Double(data[i]));
			}
		}
		std::getline(input, str);
		if(str[0] != '#' && str.size() > 0)
		{
			auto data = spritString(str, ',');
			for(int i = 0; i < data.size(); i ++)
			{
				x1in.push_back(Hex2Double(data[i]));
			}
		}
		std::getline(input, str);
		if(str[0] != '#' && str.size() > 0)
		{
			auto data = spritString(str, ',');
			for(int i = 0; i < data.size(); i ++)
			{
				x2in.push_back(Hex2Double(data[i]));
			}
		}
		std::getline(input, str);
		if(str[0] != '#' && str.size() > 0)
		{
			auto data = spritString(str, ',');
			for(int i = 0; i < data.size(); i ++)
			{
				x3in.push_back(Hex2Double(data[i]));
			}
		}
		std::getline(input, str);
		if(str[0] != '#' && str.size() > 0)
		{
			auto data = spritString(str, ',');
			for(int i = 0; i < data.size(); i ++)
			{
				x4in.push_back(Hex2Double(data[i]));
			}
		}
	}

	x0 = x0in;
	x1 = x1in;
	x2 = x2in;
	x3 = x3in;
	x4 = x4in;

	interval = std::vector<std::vector<std::vector<std::vector<std::vector<PentaCubicSpline>>>>>(x0.size() - 1, std::vector<std::vector<std::vector<std::vector<PentaCubicSpline>>>>(x1.size() - 1, std::vector<std::vector<std::vector<PentaCubicSpline>>>(x2.size() - 1, std::vector<std::vector<PentaCubicSpline>>(x3.size() - 1, std::vector<PentaCubicSpline>(x4.size() - 1)))));

	while(std::getline(input, str))
	{
		if(str[0] != '#' && str.size() > 0)
		{
			auto data = spritString(str, ',');
			
			int nx0 = std::stoi(data[0]);
			int nx1 = std::stoi(data[1]);
			int nx2 = std::stoi(data[2]);
			int nx3 = std::stoi(data[3]);
			int nx4 = std::stoi(data[4]);

			interval[nx0][nx1][nx2][nx3][nx4].a = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(4, std::vector<std::vector<std::vector<std::vector<double>>>>(4, std::vector<std::vector<std::vector<double>>>(4, std::vector<std::vector<double>>(4, std::vector<double>(4)))));
			for(int i = 0; i < 4; i ++)
			{
				for(int j = 0; j < 4; j ++)
				{
					for(int k = 0; k < 4; k ++)
					{
						for(int l = 0; l < 4; l ++)
						{
							for(int m = 0; m < 4; m ++)
							{
								int idx = 5 + i * 256 + j * 64 + k * 16 + l * 4 + m;
								//std::cout << nx0 << ", " << nx1 << ", " << nx2 << ", " << nx3 << ", " << nx4 << ", " << idx << "/" << data.size() << ", " << data[idx] << std::endl;
								interval[nx0][nx1][nx2][nx3][nx4].a[i][j][k][l][m] = Hex2Double(data[idx]);
							}
						}
					}
				}
			}
			interval[nx0][nx1][nx2][nx3][nx4].p = std::vector<std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>>(2, std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>(2, std::vector<std::vector<std::vector<std::vector<double>>>>(2, std::vector<std::vector<std::vector<double>>>(2, std::vector<std::vector<double>>(2, std::vector<double>(5))))));
			for(int i = 0; i < 2; i ++)
			{
				for(int j = 0; j < 2; j ++)
				{
					for(int k = 0; k < 2; k ++)
					{
						for(int l = 0; l < 2; l ++)
						{
							for(int m = 0; m < 2; m ++)
							{
								interval[nx0][nx1][nx2][nx3][nx4].p[i][j][k][l][m] = {x0[nx0 + i], x1[nx1 + j], x2[nx2 + k], x3[nx3 + l], x4[nx4 + m]};
							}
						}
					}
				}
			}
		}
	}

	return;
}

inline void PentaCubicInterpolator::clear(void)
{
	f.clear();
	fx0.clear();
	fx1.clear();
	fx2.clear();
	fx3.clear();
	fx4.clear();
	fx0x1.clear();
	fx0x2.clear();
	fx0x3.clear();
	fx0x4.clear();
	fx1x2.clear();
	fx1x3.clear();
	fx1x4.clear();
	fx2x3.clear();
	fx2x4.clear();
	fx3x4.clear();
	fx0x1x2.clear();
	fx0x1x3.clear();
	fx0x1x4.clear();
	fx0x2x3.clear();
	fx0x2x4.clear();
	fx0x3x4.clear();
	fx1x2x3.clear();
	fx1x2x4.clear();
	fx1x3x4.clear();
	fx2x3x4.clear();
	fx0x1x2x3.clear();
	fx0x1x2x4.clear();
	fx0x1x3x4.clear();
	fx0x2x3x4.clear();
	fx1x2x3x4.clear();
	fx0x1x2x3x4.clear();

	interval.clear();
	A.clear();

	return;
}

inline void PentaCubicInterpolator::clearData(void)
{
	f.clear();
	fx0.clear();
	fx1.clear();
	fx2.clear();
	fx3.clear();
	fx4.clear();
	fx0x1.clear();
	fx0x2.clear();
	fx0x3.clear();
	fx0x4.clear();
	fx1x2.clear();
	fx1x3.clear();
	fx1x4.clear();
	fx2x3.clear();
	fx2x4.clear();
	fx3x4.clear();
	fx0x1x2.clear();
	fx0x1x3.clear();
	fx0x1x4.clear();
	fx0x2x3.clear();
	fx0x2x4.clear();
	fx0x3x4.clear();
	fx1x2x3.clear();
	fx1x2x4.clear();
	fx1x3x4.clear();
	fx2x3x4.clear();
	fx0x1x2x3.clear();
	fx0x1x2x4.clear();
	fx0x1x3x4.clear();
	fx0x2x3x4.clear();
	fx1x2x3x4.clear();
	fx0x1x2x3x4.clear();

	for(int nx0 = 0; nx0 < interval.size(); nx0 ++)
	{
		for(int nx1 = 0; nx1 < interval[nx0].size(); nx1 ++)
		{
			for(int nx2 = 0; nx2 < interval[nx0][nx1].size(); nx2 ++)
			{
				for(int nx3 = 0; nx3 < interval[nx0][nx1][nx2].size(); nx3 ++)
				{
					for(int nx4 = 0; nx4 < interval[nx0][nx1][nx2][nx3].size(); nx4 ++)
					{
						interval[nx0][nx1][nx2][nx3][nx4].clearData();
					}
				}
			}
		}
	}

	A.clear();

	return;
}

inline void PentaCubicInterpolator::PentaCubicSpline::clearData(void)
{
	f.clear();
	p.clear();
	fx0.clear();
	fx1.clear();
	fx2.clear();
	fx3.clear();
	fx4.clear();
	fx0x1.clear();
	fx0x2.clear();
	fx0x3.clear();
	fx0x4.clear();
	fx1x2.clear();
	fx1x3.clear();
	fx1x4.clear();
	fx2x3.clear();
	fx2x4.clear();
	fx3x4.clear();
	fx0x1x2.clear();
	fx0x1x3.clear();
	fx0x1x4.clear();
	fx0x2x3.clear();
	fx0x2x4.clear();
	fx0x3x4.clear();
	fx1x2x3.clear();
	fx1x2x4.clear();
	fx1x3x4.clear();
	fx2x3x4.clear();
	fx0x1x2x3.clear();
	fx0x1x2x4.clear();
	fx0x1x3x4.clear();
	fx0x2x3x4.clear();
	fx1x2x3x4.clear();
	fx0x1x2x3x4.clear();

	return;
}

}
#endif