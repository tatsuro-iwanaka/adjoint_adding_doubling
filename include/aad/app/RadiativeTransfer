#pragma once

#include "../Core"
#include "../physics/Types"
#include "../physics/Atmosphere"
#include "../physics/HITRAN"
#include "../physics/VIRA"
#include "../physics/Constants"
#include "../physics/CrossSection"
#include "../physics/Scattering"
#include "../physics/Units"
#include "../physics/Spectral"
#include "../io/Config"
#include "../io/Import"
#include "../io/Export"
#include "../utils/Math"
#include "../utils/String"

#include "Solver"
#include "Builder"

namespace aad
{

class RadiativeTransfer
{
	private:
		physics::Configuration configuration_;
		physics::SimulationInformation simulation_;
		physics::AtmosphereModel atmosphere_model_;
		RadiativeTransferSolver radiative_transfer_solver_;
		physics::SpectralInformation spectral_;
		core::Geometry geometry_;
		physics::DeltaApproximation delta_approximation_;
		physics::RadiativeTransferResult result_;
		physics::RadiativeTransferAjointResult result_adjoint_;

		std::string config_filename_;

		// logger::Log log;
		
	public:
		RadiativeTransfer();
		RadiativeTransfer(const std::string&);
		void loadConfiguration(void);
		void run(void);
		void run_adjoint(const std::vector<aad::core::RadiativeLayer>&);
		void exportResultNetCDF(void);

		physics::RadiativeTransferResult result(void);
		physics::RadiativeTransferAjointResult result_adjoint(void);

		core::Geometry geometry(void);
};

inline core::Geometry RadiativeTransfer::geometry(void)
{
	return geometry_;
}

inline RadiativeTransfer::RadiativeTransfer()
{
	return;
}

inline RadiativeTransfer::RadiativeTransfer(const std::string& config_filename)
{
	config_filename_ = config_filename;

	loadConfiguration();
}

inline void RadiativeTransfer::loadConfiguration(void)
{
	configuration_ = io::ConfigurationLoader::load(config_filename_);
	configuration_.validateConfiguration();
	simulation_ = ModelBuilder::buildSimulation(configuration_);
	io::global().info("RadiativeTransfer::RadiativeTransfer") << "Radiative transfer calculation started.";
	spectral_ = ModelBuilder::buildSpectral(configuration_);
	geometry_ = ModelBuilder::buildGeometry(configuration_);
	atmosphere_model_ = ModelBuilder::buildAtmosphereModel(configuration_, spectral_);
	delta_approximation_ = ModelBuilder::buildDeltaApproximation(configuration_);
	result_.Ntheta = geometry_.Ntheta;
	result_.Nphi = geometry_.Nphi;
	result_.Nmode = geometry_.M;

	result_.theta_e.resize(geometry_.Ntheta);
	result_.theta_i.resize(geometry_.Ntheta);
	result_.phi.resize(geometry_.Nphi);

	for(int i = 0; i < geometry_.Ntheta; ++i)
	{
		result_.theta_e[i] = geometry_.theta_uh(i);
		result_.theta_i[i] = std::numbers::pi - geometry_.theta_lh(i);
	}

	for(int i = 0; i < geometry_.Nphi; ++i)
	{
		result_.phi[i] = geometry_.phi(i);
	}

	result_.altitude = atmosphere_model_.altitude;
	result_.altitude_top = atmosphere_model_.altitude_top;
	result_.altitude_bottom = atmosphere_model_.altitude_bottom;
	result_.physical_thickness.resize(result_.altitude.size());
	result_.temperature = atmosphere_model_.temperature;
	result_.pressure = atmosphere_model_.pressure;
	result_.number_density = atmosphere_model_.number_density;

	for(int i = 0; i < result_.altitude.size(); ++i)
	{
		result_.physical_thickness[i] = result_.altitude_top[i] - result_.altitude_bottom[i];
	}

	return;
}

inline void RadiativeTransfer::run(void)
{
	radiative_transfer_solver_.geometry(geometry_);
	radiative_transfer_solver_.delta_approximation(delta_approximation_);
	double initial_layer = configuration_.simulation.tau_initial_layer.value();
	
	int n_spectral = spectral_.spectral_grid.size();
	result_.spectral_data.resize(n_spectral);

	#pragma omp parallel for num_threads(simulation_.n_parallel)
	for(int i = 0; i < n_spectral; ++i)
	{
		double spectral = spectral_.spectral_grid[i];
		
		io::global().info("RadiativeTransfer::run") << "Computing " << spectral << (spectral_.spectral_dimension == physics::SpectralCoordinateDimension::Wavelength ? " m" : " m-1");

		result_.spectral_data[i] = radiative_transfer_solver_.computeMonochrome(atmosphere_model_, spectral, spectral_.spectral_dimension, initial_layer, simulation_.n_scattering_angle);
	}

	io::global().info("RadiativeTransfer::run") << "Spectral calculation finished.";

	if(spectral_.spectral_coordinate_type == physics::SpectralCoordinateType::Monochrome)
	{
		;
	}
	else if(spectral_.spectral_coordinate_type == physics::SpectralCoordinateType::Spectrum)
	{
		size_t n_kernel = spectral_.convolution_kernel.size();
		int n_pad = (n_kernel - 1) / 2;
		
		size_t n_total = result_.spectral_data.size();
		size_t n_output = n_total - 2 * n_pad;

		std::vector<physics::MonochromeData> convolved_data;
		convolved_data.reserve(n_output);

		std::vector<double> new_grid;
		new_grid.reserve(n_output);

		for(size_t i = 0; i < n_output; ++i)
		{
			size_t center_idx = i + n_pad;

			physics::MonochromeData data = result_.spectral_data[center_idx];

			data.source_up.setZero();

			for(auto& mat : data.reflectance_m_top_cos)
			{
				mat.setZero();
			}

			for(auto& mat : data.reflectance_m_top_sin)
			{
				mat.setZero();
			}

			for(size_t k = 0; k < n_kernel; ++k)
			{
				size_t src_idx = i + k;
				
				double w = spectral_.convolution_kernel[k];
				const auto& src_data = result_.spectral_data[src_idx];

				data.source_up += src_data.source_up * w;

				for(int m = 0; m <= result_.Nmode; ++m)
				{
					data.reflectance_m_top_cos[m] += src_data.reflectance_m_top_cos[m] * w;
					data.reflectance_m_top_sin[m] += src_data.reflectance_m_top_sin[m] * w;
				}
			}

			convolved_data.push_back(std::move(data));
			new_grid.push_back(spectral_.spectral_grid[center_idx]);
		}

		result_.spectral_data = convolved_data;
		result_.spectral_grid = new_grid;
		result_.spectral_dimension = spectral_.spectral_dimension;
		spectral_.spectral_grid = new_grid;
	}
	else if(spectral_.spectral_coordinate_type == physics::SpectralCoordinateType::Bandpass)
	{
		int n_spectral = spectral_.spectral_grid.size();
		int n_layer = atmosphere_model_.altitude.size();

		double denom = 0.0;

		for(int i = 0; i < n_spectral; ++i)
		{
			denom += spectral_.filter_weight[i];
		}

		double spectral = 0.0;

		physics::MonochromeData data;
		data.source_up = Eigen::VectorXd::Zero(geometry_.Ntheta);
		data.absorption_coefficient.resize(n_layer, 0.0);
		data.scattering_coefficient.resize(n_layer, 0.0);
		data.single_scattering_albedo.resize(n_layer, 0.0);
		data.optical_thickness.resize(n_layer, 0.0);
		data.asymmetry_parameter.resize(n_layer, 0.0);
		data.reflectance_m_top_cos.resize(geometry_.M + 1, Eigen::MatrixXd::Zero(geometry_.Ntheta, geometry_.Ntheta));
		data.reflectance_m_top_sin.resize(geometry_.M + 1, Eigen::MatrixXd::Zero(geometry_.Ntheta, geometry_.Ntheta));

		// newly added
		data.scattering_phase_function = result_.spectral_data[0].scattering_phase_function;
		data.is_scattering_species = result_.spectral_data[0].is_scattering_species;
		data.species_scattering_phase_function = result_.spectral_data[0].species_scattering_phase_function;
		for(int i = 0; i < data.species_scattering_phase_function.size(); ++i) // altitude
		{
			for(int j = 0; j < data.species_scattering_phase_function[i].size(); ++j) // speceis
			{
				for(int k = 0; k < data.species_scattering_phase_function[i][j].size(); ++k) // scattering angle
				{
					data.species_scattering_phase_function[i][j][k][1] = 0.0;
				}
			}

			for(int j = 0; j < data.scattering_phase_function[i].size(); ++j) // scattering angle
			{
				data.scattering_phase_function[i][j][1] = 0.0;
			}
		}
		data.species_absorption_cross_section.resize(n_layer, std::vector<double>(data.is_scattering_species.size(), 0.0));
		data.species_scattering_cross_section.resize(n_layer, std::vector<double>(data.is_scattering_species.size(), 0.0));

		for(int i = 0; i < n_spectral; ++i)
		{
			spectral += spectral_.spectral_grid[i] * spectral_.filter_weight[i];

			data.source_up += result_.spectral_data[i].source_up * spectral_.filter_weight[i];
			
			for(int j = 0; j < n_layer; ++j)
			{
				data.absorption_coefficient[j] += result_.spectral_data[i].absorption_coefficient[j] * spectral_.filter_weight[i];
				data.scattering_coefficient[j] += result_.spectral_data[i].scattering_coefficient[j] * spectral_.filter_weight[i];

				for(int k = 0; k < data.is_scattering_species.size(); ++k)
				{
					data.species_absorption_cross_section[j][k] += result_.spectral_data[i].species_absorption_cross_section[j][k] * spectral_.filter_weight[i];
					data.species_scattering_cross_section[j][k] += result_.spectral_data[i].species_scattering_cross_section[j][k] * spectral_.filter_weight[i];

					if(data.is_scattering_species[k] == true)
					{
						for(int l = 0; l < data.species_scattering_phase_function[j][k].size(); ++l)
						{
							data.species_scattering_phase_function[j][k][l][1] += result_.spectral_data[i].species_scattering_phase_function[j][k][l][1] * result_.spectral_data[i].species_scattering_cross_section[j][k] * spectral_.filter_weight[i];
						}
					}
				}

				for(int k = 0; k < data.scattering_phase_function[j].size(); ++k)
				{
					data.scattering_phase_function[j][k][1] += result_.spectral_data[i].scattering_phase_function[j][k][1] * result_.spectral_data[i].scattering_coefficient[j] * spectral_.filter_weight[i];
				}

				data.asymmetry_parameter[j] += result_.spectral_data[i].asymmetry_parameter[j] * result_.spectral_data[i].scattering_coefficient[j] * spectral_.filter_weight[i];
			}

			for(int j = 0; j <= geometry_.M; ++j)
			{
				data.reflectance_m_top_cos[j] += result_.spectral_data[i].reflectance_m_top_cos[j] * spectral_.filter_weight[i];
				data.reflectance_m_top_sin[j] += result_.spectral_data[i].reflectance_m_top_sin[j] * spectral_.filter_weight[i];
			}
		}

		for(int i = 0; i < n_layer; ++i)
		{
			data.asymmetry_parameter[i] /= data.scattering_coefficient[i];

			data.absorption_coefficient[i] /= denom;
			data.scattering_coefficient[i] /= denom;

			for(int j = 0; j < data.is_scattering_species.size(); ++j)
			{
				data.species_absorption_cross_section[i][j] /= denom;
				data.species_scattering_cross_section[i][j] /= denom;
				
				if(data.is_scattering_species[j] == true)
				{
					physics::normalizeScatteringPhaseFunction(data.species_scattering_phase_function[i][j]);
				}
			}

			physics::normalizeScatteringPhaseFunction(data.scattering_phase_function[i]);

			data.single_scattering_albedo[i] = data.scattering_coefficient[i] / (data.scattering_coefficient[i] + data.absorption_coefficient[i]);
			data.optical_thickness[i] = (data.scattering_coefficient[i] + data.absorption_coefficient[i]) * (atmosphere_model_.altitude_top[i] - atmosphere_model_.altitude_bottom[i]);
		}

		data.source_up /= denom;
		spectral /= denom;

		for(int i = 0; i <= geometry_.M; ++i)
		{
			data.reflectance_m_top_cos[i] /= denom;
			data.reflectance_m_top_sin[i] /= denom;
		}

		result_.spectral_data = {data};
		result_.spectral_grid = {spectral};
		result_.spectral_dimension = spectral_.spectral_dimension;
		spectral_.spectral_grid = {spectral};
	}

	return;
}

inline void RadiativeTransfer::run_adjoint(const std::vector<aad::core::RadiativeLayer>& adj_source)
{
	radiative_transfer_solver_.geometry(geometry_);
	radiative_transfer_solver_.delta_approximation(delta_approximation_);

	auto scale_layer = [](aad::core::RadiativeLayer& layer, double w)
	{
		layer.source_up *= w;
		layer.source_down *= w;

		for(auto& mat : layer.reflectance_m_top_cos) mat *= w;
		for(auto& mat : layer.reflectance_m_top_sin) mat *= w;
		for(auto& mat : layer.reflectance_m_bottom_cos) mat *= w;
		for(auto& mat : layer.reflectance_m_bottom_sin) mat *= w;
		for(auto& mat : layer.transmittance_m_top_cos) mat *= w;
		for(auto& mat : layer.transmittance_m_top_sin) mat *= w;
		for(auto& mat : layer.transmittance_m_bottom_cos) mat *= w;
		for(auto& mat : layer.transmittance_m_bottom_sin) mat *= w;

		return;
	};

	auto accumulate_result = [&](physics::RadiativeTransferAjointResult& dest, const physics::RadiativeTransferAjointResult& src)
	{
		if (dest.layers.empty())
		{
			dest = src;
			return;
		}

		int n_layer = dest.layers.size();

		for(int i = 0; i < n_layer; ++i)
		{
			int n_species = dest.layers[i].species.size();
			for(int s = 0; s < n_species; ++s)
			{
				dest.layers[i].species[s].number_density += src.layers[i].species[s].number_density;
				dest.layers[i].species[s].mixing_ratio += src.layers[i].species[s].mixing_ratio;
			}
		}
	};

	int n_layer = atmosphere_model_.altitude.size();
	result_adjoint_.layers.resize(n_layer);

	if(spectral_.spectral_coordinate_type == physics::SpectralCoordinateType::Monochrome)
	{
		result_adjoint_ = radiative_transfer_solver_.computeMonochrome_adjoint(atmosphere_model_, spectral_.spectral_grid[0], spectral_.spectral_dimension, adj_source[0], configuration_.simulation.tau_initial_layer.value(), simulation_.n_scattering_angle);
	}
	else if(spectral_.spectral_coordinate_type == physics::SpectralCoordinateType::Bandpass)
	{
		int n_spectral = spectral_.spectral_grid.size();
		std::vector<aad::physics::RadiativeTransferAjointResult> results_ajd(n_spectral);
		
		#pragma omp parallel for num_threads(simulation_.n_parallel)
		for(int i = 0; i < n_spectral; ++i)
		{
			double spectral = spectral_.spectral_grid[i];
			double weight = spectral_.filter_weight[i];

			aad::core::RadiativeLayer weighted_source = adj_source[0];
			
			scale_layer(weighted_source, weight);

			io::global().info("RadiativeTransfer::run_adjoint") << "Computing for " << spectral << (spectral_.spectral_dimension == physics::SpectralCoordinateDimension::Wavenumber ? " m-1" : " m") << ".";
			results_ajd[i] = radiative_transfer_solver_.computeMonochrome_adjoint(atmosphere_model_, spectral, spectral_.spectral_dimension, weighted_source, configuration_.simulation.tau_initial_layer.value(), simulation_.n_scattering_angle);
			io::global().info("RadiativeTransfer::run_adjoint") << "Finished computing for " << spectral << (spectral_.spectral_dimension == physics::SpectralCoordinateDimension::Wavenumber ? " m-1" : " m") << ".";
		}

		result_adjoint_ = results_ajd[0];

		for(int i = 1; i < n_spectral; ++i)
		{
			for(int j = 0; j < n_layer; ++j)
			{
				int n_species = results_ajd[i].layers[j].species.size();

				for(int s = 0; s < n_species; ++s)
				{
					result_adjoint_.layers[j].species[s].number_density += results_ajd[i].layers[j].species[s].number_density;
					result_adjoint_.layers[j].species[s].mixing_ratio += results_ajd[i].layers[j].species[s].mixing_ratio;
					result_adjoint_.layers[j].species[s].log_mixing_ratio += results_ajd[i].layers[j].species[s].mixing_ratio * atmosphere_model_.species[s].vertical_mixing_ratio_profile[j];
				}
			}
		}

	}
	else if(spectral_.spectral_coordinate_type == physics::SpectralCoordinateType::Spectrum)
	{
		io::global().fatal("RadiativeTransfer::run_adjoint") << "Spectral adjoint is not yet implemented.";
		throw std::runtime_error("[RadiativeTransfer::run_adjoint] Spectral adjoint is not yet implemented.");
	}

	result_adjoint_.altitude = atmosphere_model_.altitude;

	return;
}

inline physics::RadiativeTransferResult RadiativeTransfer::result(void)
{
	return result_;
}

inline physics::RadiativeTransferAjointResult RadiativeTransfer::result_adjoint(void)
{
	return result_adjoint_;
}

inline void RadiativeTransfer::exportResultNetCDF()
{
	io::exportResultNetCDF(result_, simulation_, atmosphere_model_, geometry_, spectral_);

	return;
}

}