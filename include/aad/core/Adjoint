#pragma once

#include <Eigen/Dense>
#include <cmath>
#include <algorithm>
// #include <algorithm>

#include "Types"
// #include"constants"
#include "Geometry"

// namespace radiative_transfer
namespace aad::core
{

// Return adj_layer
inline RadiativeLayer doubleLayer_adjoint(const RadiativeLayer &layer, const Geometry &geometry, const RadiativeLayer &adj_result)
{
	RadiativeLayer adj_layer = layer;
	adj_layer.optical_thickness = 0.0;
	adj_layer.source_up.setZero();
	adj_layer.source_down.setZero();
	for(int m = 0; m <= geometry.M; m++)
	{
		adj_layer.reflectance_m_top_cos[m].setZero();
		adj_layer.reflectance_m_top_sin[m].setZero();
		adj_layer.reflectance_m_bottom_cos[m].setZero();
		adj_layer.reflectance_m_bottom_sin[m].setZero();
		adj_layer.transmittance_m_top_cos[m].setZero();
		adj_layer.transmittance_m_top_sin[m].setZero();
		adj_layer.transmittance_m_bottom_cos[m].setZero();
		adj_layer.transmittance_m_bottom_sin[m].setZero();
	}

	Eigen::VectorXd exp_tau = Eigen::VectorXd::Zero(geometry.Ntheta);
	Eigen::VectorXd adj_exp_tau = Eigen::VectorXd::Zero(geometry.Ntheta);

	for(int i = 0; i < geometry.Ntheta; i ++)
	{
		exp_tau(i) = std::exp(-layer.optical_thickness / geometry.mu(i));
	}

	Eigen::MatrixXd E = exp_tau.asDiagonal();

	adj_layer.optical_thickness += adj_result.optical_thickness * 2.0;

	for(int m = 0; m <= geometry.M; m ++)
	{
		double factor = (m == 0 ? 2.0 : 1.0);

		Eigen::MatrixXd Q1_c = factor * layer.reflectance_m_bottom_cos[m] * geometry.WMU * layer.reflectance_m_top_cos[m];
		// Eigen::MatrixXd Q1_s = factor * layer.reflectance_m_bottom_sin[m] * geometry.WMU * layer.reflectance_m_top_sin[m];
		
		Eigen::MatrixXd Q2_c = factor * Q1_c * geometry.WMU;
		// Eigen::MatrixXd Q2_s = factor * Q1_s * geometry.WMU;

		Eigen::MatrixXd I = Eigen::MatrixXd::Identity(geometry.Ntheta, geometry.Ntheta);
		Eigen::MatrixXd IQ_c = I - Q2_c;
		// Eigen::MatrixXd IQ_s = I - Q2_s;

		Eigen::PartialPivLU<Eigen::MatrixXd> lu_c(IQ_c);
		// Eigen::PartialPivLU<Eigen::MatrixXd> lu_s(IQ_s);
		Eigen::MatrixXd S_c = lu_c.solve(Q1_c);
		// Eigen::MatrixXd S_s = lu_s.solve(Q1_s);

		Eigen::MatrixXd Sexp_c = S_c * E;
		// Eigen::MatrixXd Sexp_s = S_s * E;

		Eigen::MatrixXd D_c_term1 = factor * S_c * geometry.WMU * layer.transmittance_m_top_cos[m];
		// Eigen::MatrixXd D_s_term1 = factor * S_s * geometry.WMU * layer.transmittance_m_top_sin[m];

		Eigen::MatrixXd D_c = D_c_term1 + layer.transmittance_m_top_cos[m] + Sexp_c;
		// Eigen::MatrixXd D_s = D_s_term1 + layer.transmittance_m_top_sin[m] + Sexp_s;

		Eigen::MatrixXd R2exp_c = layer.reflectance_m_top_cos[m] * E;
		// Eigen::MatrixXd R2exp_s = layer.reflectance_m_top_sin[m] * E;

		Eigen::MatrixXd U_c_term1 = factor * layer.reflectance_m_top_cos[m] * geometry.WMU * D_c;
		// Eigen::MatrixXd U_s_term1 = factor * layer.reflectance_m_top_sin[m] * geometry.WMU * D_s;

		Eigen::MatrixXd U_c = U_c_term1 + R2exp_c;
		// Eigen::MatrixXd U_s = U_s_term1 + R2exp_s;


		// adjoint
		Eigen::MatrixXd adj_ref_top_cos = adj_result.reflectance_m_top_cos[m] + adj_result.reflectance_m_bottom_cos[m];
		// Eigen::MatrixXd adj_ref_top_sin = adj_result.reflectance_m_top_sin[m] + adj_result.reflectance_m_bottom_sin[m];
		Eigen::MatrixXd adj_trans_top_cos = adj_result.transmittance_m_top_cos[m] + adj_result.transmittance_m_bottom_cos[m];
		// Eigen::MatrixXd adj_trans_top_sin = adj_result.transmittance_m_top_sin[m] + adj_result.transmittance_m_bottom_sin[m];

		Eigen::MatrixXd adj_S_c = Eigen::MatrixXd::Zero(geometry.Ntheta, geometry.Ntheta);
		// Eigen::MatrixXd adj_S_s = Eigen::MatrixXd::Zero(geometry.Ntheta, geometry.Ntheta);

		if(m == 0 && layer.enable_atmospheric_emission)
		{
			Eigen::VectorXd adj_total_src = adj_result.source_up + adj_result.source_down;

			adj_layer.source_up += adj_total_src;

			Eigen::MatrixXd T_bot_W = layer.transmittance_m_bottom_cos[m] * geometry.WMU;
			
			adj_layer.source_up += T_bot_W.transpose() * adj_total_src;
			adj_layer.source_up += E * adj_total_src;
			adj_exp_tau += adj_total_src.cwiseProduct(layer.source_up);

			Eigen::VectorXd W_src_up = geometry.WMU * layer.source_up;
			adj_layer.transmittance_m_bottom_cos[m] += adj_total_src * W_src_up.transpose();

			Eigen::VectorXd V = layer.reflectance_m_top_cos[m] * geometry.WMU * layer.source_down;
			
			Eigen::VectorXd adj_V = T_bot_W.transpose() * adj_total_src;
			adj_V += E * adj_total_src;
			adj_exp_tau += adj_total_src.cwiseProduct(V);

			Eigen::VectorXd W_V = geometry.WMU * V;
			adj_layer.transmittance_m_bottom_cos[m] += adj_total_src * W_V.transpose();

			Eigen::VectorXd W_src_down = geometry.WMU * layer.source_down;
			adj_layer.reflectance_m_top_cos[m] += adj_V * W_src_down.transpose();
			adj_layer.source_down += (layer.reflectance_m_top_cos[m] * geometry.WMU).transpose() * adj_V;

			Eigen::VectorXd V2 = layer.reflectance_m_top_cos[m] * geometry.WMU * S_c * geometry.WMU * layer.source_down;
			
			Eigen::VectorXd adj_V2 = T_bot_W.transpose() * adj_total_src;
			adj_V2 += E * adj_total_src;
			adj_exp_tau += adj_total_src.cwiseProduct(V2);

			Eigen::VectorXd W_V2 = geometry.WMU * V2;
			adj_layer.transmittance_m_bottom_cos[m] += adj_total_src * W_V2.transpose();
			
			Eigen::VectorXd X = S_c * geometry.WMU * layer.source_down;
			adj_layer.reflectance_m_top_cos[m] += adj_V2 * (geometry.WMU * X).transpose();
			
			Eigen::VectorXd adj_X = geometry.WMU.transpose() * layer.reflectance_m_top_cos[m].transpose() * adj_V2;

			adj_S_c += adj_X * W_src_down.transpose();
			
			adj_layer.source_down += (S_c * geometry.WMU).transpose() * adj_X;
		}

		// cosine
		Eigen::MatrixXd adj_T_res_c = adj_trans_top_cos;
		adj_layer.transmittance_m_top_cos[m] += adj_T_res_c * E;
		adj_exp_tau += (layer.transmittance_m_top_cos[m].transpose() * adj_T_res_c).diagonal();
		Eigen::MatrixXd adj_D_c = E * adj_T_res_c;
		adj_exp_tau += (adj_T_res_c * D_c.transpose()).diagonal();
		adj_layer.transmittance_m_top_cos[m] += factor * adj_T_res_c * (geometry.WMU * D_c).transpose();
		adj_D_c += factor * (layer.transmittance_m_top_cos[m] * geometry.WMU).transpose() * adj_T_res_c;
		// sine
		// Eigen::MatrixXd adj_T_res_s = adj_trans_top_sin;
		// adj_layer.transmittance_m_top_sin[m] += adj_T_res_s * E;
		// adj_exp_tau += (layer.transmittance_m_top_sin[m].transpose() * adj_T_res_s).diagonal();
		// Eigen::MatrixXd adj_D_s = E * adj_T_res_s;
		// adj_exp_tau += (adj_T_res_s * D_s.transpose()).diagonal();
		// adj_layer.transmittance_m_top_sin[m] += factor * adj_T_res_s * (geometry.WMU * D_s).transpose();
		// adj_D_s += factor * (layer.transmittance_m_top_sin[m] * geometry.WMU).transpose() * adj_T_res_s;


		// cosine
		Eigen::MatrixXd adj_R_res_c = adj_ref_top_cos;
		adj_layer.reflectance_m_top_cos[m] += adj_R_res_c;
		Eigen::MatrixXd adj_U_c = E * adj_R_res_c;
		adj_exp_tau += (adj_R_res_c * U_c.transpose()).diagonal();
		adj_layer.transmittance_m_bottom_cos[m] += factor * adj_R_res_c * (geometry.WMU * U_c).transpose();
		adj_U_c += factor * (layer.transmittance_m_bottom_cos[m] * geometry.WMU).transpose() * adj_R_res_c;
		// sine
		// Eigen::MatrixXd adj_R_res_s = adj_ref_top_sin;
		// adj_layer.reflectance_m_top_sin[m] += adj_R_res_s;
		// Eigen::MatrixXd adj_U_s = E * adj_R_res_s;
		// adj_exp_tau += (adj_R_res_s * U_s.transpose()).diagonal();
		// adj_layer.transmittance_m_bottom_sin[m] += factor * adj_R_res_s * (geometry.WMU * U_s).transpose();
		// adj_U_s += factor * (layer.transmittance_m_bottom_sin[m] * geometry.WMU).transpose() * adj_R_res_s;


		//cosine
		adj_layer.reflectance_m_top_cos[m] += factor * adj_U_c * (geometry.WMU * D_c).transpose();
		adj_D_c += factor * (layer.reflectance_m_top_cos[m] * geometry.WMU).transpose() * adj_U_c;
		adj_layer.reflectance_m_top_cos[m] += adj_U_c * E;
		adj_exp_tau += (layer.reflectance_m_top_cos[m].transpose() * adj_U_c).diagonal();
		// sine
		// adj_layer.reflectance_m_top_sin[m] += factor * adj_U_s * (geometry.WMU * D_s).transpose();
		// adj_D_s += factor * (layer.reflectance_m_top_sin[m] * geometry.WMU).transpose() * adj_U_s;
		// adj_layer.reflectance_m_top_sin[m] += adj_U_s * E;
		// adj_exp_tau += (layer.reflectance_m_top_sin[m].transpose() * adj_U_s).diagonal();


		// cosine
		adj_layer.transmittance_m_top_cos[m] += adj_D_c;
		adj_S_c += adj_D_c * E;
		adj_exp_tau += (S_c.transpose() * adj_D_c).diagonal();
		adj_S_c += factor * adj_D_c * (geometry.WMU * layer.transmittance_m_top_cos[m]).transpose();
		adj_layer.transmittance_m_top_cos[m] += factor * (S_c * geometry.WMU).transpose() * adj_D_c;
		// sine
		// adj_layer.transmittance_m_top_sin[m] += adj_D_s;
		// adj_S_s += adj_D_s * E;
		// adj_exp_tau += (S_s.transpose() * adj_D_s).diagonal();
		// adj_S_s += factor * adj_D_s * (geometry.WMU * layer.transmittance_m_top_sin[m]).transpose();
		// adj_layer.transmittance_m_top_sin[m] += factor * (S_s * geometry.WMU).transpose() * adj_D_s;

		// cosine
		Eigen::MatrixXd adj_Q1_c = lu_c.transpose().solve(adj_S_c);
		Eigen::MatrixXd adj_Q2_c = adj_Q1_c * S_c.transpose();
		//sine
		// Eigen::MatrixXd adj_Q1_s = lu_s.transpose().solve(adj_S_s);
		// Eigen::MatrixXd adj_Q2_s = adj_Q1_s * S_s.transpose();

		adj_Q1_c += factor * adj_Q2_c * geometry.WMU.transpose();
		// adj_Q1_s += factor * adj_Q2_s * geometry.WMU.transpose();

		adj_layer.reflectance_m_bottom_cos[m] += factor * adj_Q1_c * (geometry.WMU * layer.reflectance_m_top_cos[m]).transpose();
		adj_layer.reflectance_m_top_cos[m] += factor * (layer.reflectance_m_bottom_cos[m] * geometry.WMU).transpose() * adj_Q1_c;
		// adj_layer.reflectance_m_bottom_sin[m] += factor * adj_Q1_s * (geometry.WMU * layer.reflectance_m_top_sin[m]).transpose();
		// adj_layer.reflectance_m_top_sin[m] += factor * (layer.reflectance_m_bottom_sin[m] * geometry.WMU).transpose() * adj_Q1_s;
	}

	for(int i = 0; i < geometry.Ntheta; i++)
	{
		adj_layer.optical_thickness += adj_exp_tau(i) * (-1.0 / geometry.mu(i)) * exp_tau(i);
	}

	return adj_layer;
}

// Return adj_layer_bottom, adj_layer_top
inline std::vector<RadiativeLayer> addLayer_adjoint(const RadiativeLayer &layer_bottom, const RadiativeLayer &layer_top, const Geometry &geometry, const RadiativeLayer &adj_result)
{
	RadiativeLayer adj_bot = layer_bottom;
	RadiativeLayer adj_top = layer_top;

	adj_bot.optical_thickness = 0.0;
	adj_top.optical_thickness = 0.0;
	adj_bot.source_up.setZero(); adj_bot.source_down.setZero();
	adj_top.source_up.setZero(); adj_top.source_down.setZero();

	for(int m = 0; m <= geometry.M; m++)
	{
		// Bottom
		adj_bot.reflectance_m_top_cos[m].setZero();
		adj_bot.reflectance_m_top_sin[m].setZero();
		adj_bot.reflectance_m_bottom_cos[m].setZero();
		adj_bot.reflectance_m_bottom_sin[m].setZero();
		adj_bot.transmittance_m_top_cos[m].setZero();
		adj_bot.transmittance_m_top_sin[m].setZero();
		adj_bot.transmittance_m_bottom_cos[m].setZero();
		adj_bot.transmittance_m_bottom_sin[m].setZero();
		// Top
		adj_top.reflectance_m_top_cos[m].setZero();
		adj_top.reflectance_m_top_sin[m].setZero();
		adj_top.reflectance_m_bottom_cos[m].setZero();
		adj_top.reflectance_m_bottom_sin[m].setZero();
		adj_top.transmittance_m_top_cos[m].setZero();
		adj_top.transmittance_m_top_sin[m].setZero();
		adj_top.transmittance_m_bottom_cos[m].setZero();
		adj_top.transmittance_m_bottom_sin[m].setZero();
	}

	adj_bot.source_down += adj_result.source_down;

	for(int m = 0; m <= geometry.M; m ++) 
	{
		adj_bot.reflectance_m_bottom_cos[m] += adj_result.reflectance_m_bottom_cos[m];
		adj_bot.transmittance_m_bottom_cos[m] += adj_result.transmittance_m_bottom_cos[m];
		// adj_bot.reflectance_m_bottom_sin[m] += adj_result.reflectance_m_bottom_sin[m];
		// adj_bot.transmittance_m_bottom_sin[m] += adj_result.transmittance_m_bottom_sin[m];
	}

	Eigen::VectorXd exp_tau_top = Eigen::VectorXd::Zero(geometry.Ntheta);
	Eigen::VectorXd exp_tau_bottom = Eigen::VectorXd::Zero(geometry.Ntheta);
	Eigen::VectorXd adj_exp_tau_top = Eigen::VectorXd::Zero(geometry.Ntheta);
	Eigen::VectorXd adj_exp_tau_bottom = Eigen::VectorXd::Zero(geometry.Ntheta);

	for(int i = 0; i < geometry.Ntheta; i ++)
	{
		exp_tau_top(i) = std::exp(-layer_top.optical_thickness / geometry.mu(i));
		exp_tau_bottom(i) = std::exp(-layer_bottom.optical_thickness / geometry.mu(i));
	}

	Eigen::MatrixXd E_top = exp_tau_top.asDiagonal();
	Eigen::MatrixXd E_bottom = exp_tau_bottom.asDiagonal();

	adj_bot.optical_thickness += adj_result.optical_thickness;
	adj_top.optical_thickness += adj_result.optical_thickness;

	for(int m = 0; m <= geometry.M; m ++)
	{
		double factor = (m == 0 ? 2.0 : 1.0);

		Eigen::MatrixXd Q1_c = factor * layer_top.reflectance_m_bottom_cos[m] * geometry.WMU * layer_bottom.reflectance_m_top_cos[m];
		// Eigen::MatrixXd Q1_s = factor * layer_top.reflectance_m_bottom_sin[m] * geometry.WMU * layer_bottom.reflectance_m_top_sin[m];

		Eigen::MatrixXd Q2_c = factor * Q1_c * geometry.WMU;
		// Eigen::MatrixXd Q2_s = factor * Q1_s * geometry.WMU;

		Eigen::MatrixXd I = Eigen::MatrixXd::Identity(geometry.Ntheta, geometry.Ntheta);
		Eigen::MatrixXd IQ_c = I - Q2_c;
		// Eigen::MatrixXd IQ_s = I - Q2_s;

		Eigen::PartialPivLU<Eigen::MatrixXd> lu_c(IQ_c);
		// Eigen::PartialPivLU<Eigen::MatrixXd> lu_s(IQ_s);
		Eigen::MatrixXd S_c = lu_c.solve(Q1_c);
		// Eigen::MatrixXd S_s = lu_s.solve(Q1_s);

		Eigen::MatrixXd Sexp_c = S_c * E_top;
		// Eigen::MatrixXd Sexp_s = S_s * E_top;

		// D = c * S * W * T_top_top + T_top_top + S * E_top
		Eigen::MatrixXd D_c = factor * S_c * geometry.WMU * layer_top.transmittance_m_top_cos[m];
		// Eigen::MatrixXd D_s = factor * S_s * geometry.WMU * layer_top.transmittance_m_top_sin[m];
		
		D_c = D_c + layer_top.transmittance_m_top_cos[m] + Sexp_c;
		// D_s = D_s + layer_top.transmittance_m_top_sin[m] + Sexp_s;

		// U = c * R_bot_top * W * D + R_bot_top * E_top
		Eigen::MatrixXd R2exp_c = layer_bottom.reflectance_m_top_cos[m] * E_top;
		// Eigen::MatrixXd R2exp_s = layer_bottom.reflectance_m_top_sin[m] * E_top;
		
		Eigen::MatrixXd U_c = factor * layer_bottom.reflectance_m_top_cos[m] * geometry.WMU * D_c;
		// Eigen::MatrixXd U_s = factor * layer_bottom.reflectance_m_top_sin[m] * geometry.WMU * D_s;
		
		U_c = U_c + R2exp_c;
		// U_s = U_s + R2exp_s;

		// Adjoint

		Eigen::MatrixXd adj_S_c = Eigen::MatrixXd::Zero(geometry.Ntheta, geometry.Ntheta);
		// Eigen::MatrixXd adj_S_s = Eigen::MatrixXd::Zero(geometry.Ntheta, geometry.Ntheta);

		if(m == 0 && adj_result.enable_atmospheric_emission)
		{
			Eigen::VectorXd adj_src_up_res = adj_result.source_up;
			
			adj_top.source_up += adj_src_up_res;

			Eigen::MatrixXd T_top_bot_W = layer_top.transmittance_m_bottom_cos[m] * geometry.WMU;
			
			adj_bot.source_up += T_top_bot_W.transpose() * adj_src_up_res;
			adj_bot.source_up += E_top * adj_src_up_res;
			adj_exp_tau_top += adj_src_up_res.cwiseProduct(layer_bottom.source_up);

			Eigen::VectorXd W_src_up_bot = geometry.WMU * layer_bottom.source_up;
			adj_top.transmittance_m_bottom_cos[m] += adj_src_up_res * W_src_up_bot.transpose();

			Eigen::VectorXd adj_TRE = adj_src_up_res;
			
			Eigen::VectorXd adj_VecA = T_top_bot_W.transpose() * adj_TRE;
			adj_VecA += E_top * adj_TRE;
			Eigen::VectorXd R_bot_W_S_down = layer_bottom.reflectance_m_top_cos[m] * geometry.WMU * layer_top.source_down;
			adj_exp_tau_top += adj_TRE.cwiseProduct(R_bot_W_S_down);
			
			Eigen::VectorXd W_VecA = geometry.WMU * layer_bottom.reflectance_m_top_cos[m] * geometry.WMU * layer_top.source_down;
			adj_top.transmittance_m_bottom_cos[m] += adj_TRE * W_VecA.transpose();

			Eigen::VectorXd W_S_down_top = geometry.WMU * layer_top.source_down;
			adj_bot.reflectance_m_top_cos[m] += adj_VecA * W_S_down_top.transpose();
			adj_top.source_down += (layer_bottom.reflectance_m_top_cos[m] * geometry.WMU).transpose() * adj_VecA;

			Eigen::VectorXd VecB = S_c * geometry.WMU * layer_top.source_down;
			Eigen::VectorXd R_W_VecB = layer_bottom.reflectance_m_top_cos[m] * geometry.WMU * VecB;

			adj_exp_tau_top += adj_src_up_res.cwiseProduct(R_W_VecB);
			adj_top.transmittance_m_bottom_cos[m] += adj_src_up_res * (geometry.WMU * R_W_VecB).transpose();
			
			Eigen::VectorXd adj_R_W_VecB = T_top_bot_W.transpose() * adj_src_up_res + E_top * adj_src_up_res;
			
			adj_bot.reflectance_m_top_cos[m] += adj_R_W_VecB * (geometry.WMU * VecB).transpose();

			Eigen::VectorXd adj_VecB = (layer_bottom.reflectance_m_top_cos[m] * geometry.WMU).transpose() * adj_R_W_VecB;
			adj_S_c += adj_VecB * W_S_down_top.transpose();
			adj_top.source_down += (S_c * geometry.WMU).transpose() * adj_VecB;
		}

		// Cosine
		Eigen::MatrixXd adj_T_res_c = adj_result.transmittance_m_top_cos[m];
		adj_exp_tau_bottom += (adj_T_res_c * D_c.transpose()).diagonal();
		Eigen::MatrixXd adj_D_c = E_bottom * adj_T_res_c;
		adj_bot.transmittance_m_top_cos[m] += adj_T_res_c * E_top;
		adj_exp_tau_top += (layer_bottom.transmittance_m_top_cos[m].transpose() * adj_T_res_c).diagonal();
		adj_bot.transmittance_m_top_cos[m] += factor * adj_T_res_c * (geometry.WMU * D_c).transpose();
		adj_D_c += factor * (layer_bottom.transmittance_m_top_cos[m] * geometry.WMU).transpose() * adj_T_res_c;
		// Sine
		// Eigen::MatrixXd adj_T_res_s = adj_result.transmittance_m_top_sin[m];
		// adj_exp_tau_bottom += (adj_T_res_s * D_s.transpose()).diagonal();
		// Eigen::MatrixXd adj_D_s = E_bottom * adj_T_res_s;
		// adj_bot.transmittance_m_top_sin[m] += adj_T_res_s * E_top;
		// adj_exp_tau_top += (layer_bottom.transmittance_m_top_sin[m].transpose() * adj_T_res_s).diagonal();
		// adj_bot.transmittance_m_top_sin[m] += factor * adj_T_res_s * (geometry.WMU * D_s).transpose();
		// adj_D_s += factor * (layer_bottom.transmittance_m_top_sin[m] * geometry.WMU).transpose() * adj_T_res_s;

		// Cosine
		Eigen::MatrixXd adj_R_res_c = adj_result.reflectance_m_top_cos[m];
		adj_exp_tau_top += (adj_R_res_c * U_c.transpose()).diagonal();
		Eigen::MatrixXd adj_U_c = E_top * adj_R_res_c;
		adj_top.reflectance_m_top_cos[m] += adj_R_res_c;
		adj_top.transmittance_m_bottom_cos[m] += factor * adj_R_res_c * (geometry.WMU * U_c).transpose();
		adj_U_c += factor * (layer_top.transmittance_m_bottom_cos[m] * geometry.WMU).transpose() * adj_R_res_c;
		// Sine
		// Eigen::MatrixXd adj_R_res_s = adj_result.reflectance_m_top_sin[m];
		// adj_exp_tau_top += (adj_R_res_s * U_s.transpose()).diagonal();
		// Eigen::MatrixXd adj_U_s = E_top * adj_R_res_s;
		// adj_top.reflectance_m_top_sin[m] += adj_R_res_s;
		// adj_top.transmittance_m_bottom_sin[m] += factor * adj_R_res_s * (geometry.WMU * U_s).transpose();
		// adj_U_s += factor * (layer_top.transmittance_m_bottom_sin[m] * geometry.WMU).transpose() * adj_R_res_s;

		// Cosine
		adj_bot.reflectance_m_top_cos[m] += adj_U_c * E_top;
		adj_exp_tau_top += (layer_bottom.reflectance_m_top_cos[m].transpose() * adj_U_c).diagonal();
		adj_bot.reflectance_m_top_cos[m] += factor * adj_U_c * (geometry.WMU * D_c).transpose();
		adj_D_c += factor * (layer_bottom.reflectance_m_top_cos[m] * geometry.WMU).transpose() * adj_U_c;
		// Sine
		// adj_bot.reflectance_m_top_sin[m] += adj_U_s * E_top;
		// adj_exp_tau_top += (layer_bottom.reflectance_m_top_sin[m].transpose() * adj_U_s).diagonal();
		// adj_bot.reflectance_m_top_sin[m] += factor * adj_U_s * (geometry.WMU * D_s).transpose();
		// adj_D_s += factor * (layer_bottom.reflectance_m_top_sin[m] * geometry.WMU).transpose() * adj_U_s;

		// Cosine
		adj_S_c += adj_D_c * E_top;
		adj_exp_tau_top += (S_c.transpose() * adj_D_c).diagonal();
		adj_top.transmittance_m_top_cos[m] += adj_D_c;
		adj_S_c += factor * adj_D_c * (geometry.WMU * layer_top.transmittance_m_top_cos[m]).transpose();
		adj_top.transmittance_m_top_cos[m] += factor * (S_c * geometry.WMU).transpose() * adj_D_c;
		// Sine
		// adj_S_s += adj_D_s * E_top;
		// adj_exp_tau_top += (S_s.transpose() * adj_D_s).diagonal();
		// adj_top.transmittance_m_top_sin[m] += adj_D_s;
		// adj_S_s += factor * adj_D_s * (geometry.WMU * layer_top.transmittance_m_top_sin[m]).transpose();
		// adj_top.transmittance_m_top_sin[m] += factor * (S_s * geometry.WMU).transpose() * adj_D_s;

		// Cosine
		Eigen::MatrixXd adj_Q1_c = lu_c.transpose().solve(adj_S_c);
		Eigen::MatrixXd adj_Q2_c = adj_Q1_c * S_c.transpose();
		adj_Q1_c += factor * adj_Q2_c * geometry.WMU.transpose();
		// Sine
		// Eigen::MatrixXd adj_Q1_s = lu_s.transpose().solve(adj_S_s);
		// Eigen::MatrixXd adj_Q2_s = adj_Q1_s * S_s.transpose();
		// adj_Q1_s += factor * adj_Q2_s * geometry.WMU.transpose();

		// Cosine
		adj_top.reflectance_m_bottom_cos[m] += factor * adj_Q1_c * (geometry.WMU * layer_bottom.reflectance_m_top_cos[m]).transpose();
		adj_bot.reflectance_m_top_cos[m] += factor * (layer_top.reflectance_m_bottom_cos[m] * geometry.WMU).transpose() * adj_Q1_c;
		// Sine
		// adj_top.reflectance_m_bottom_sin[m] += factor * adj_Q1_s * (geometry.WMU * layer_bottom.reflectance_m_top_sin[m]).transpose();
		// adj_bot.reflectance_m_top_sin[m] += factor * (layer_top.reflectance_m_bottom_sin[m] * geometry.WMU).transpose() * adj_Q1_s;
	}

	for(int i = 0; i < geometry.Ntheta; i++)
	{
		adj_top.optical_thickness += adj_exp_tau_top(i) * (-1.0 / geometry.mu(i)) * exp_tau_top(i);
		adj_bot.optical_thickness += adj_exp_tau_bottom(i) * (-1.0 / geometry.mu(i)) * exp_tau_bottom(i);
	}

	return {adj_bot, adj_top};
}

// 線形補間のアジョイントコード
void accumulate_gradient_to_grid(double theta_val, double grad_val, const std::vector<double>& theta_grid, std::vector<double>& grad_P_array)
{
	if (theta_val <= theta_grid.front())
	{
		grad_P_array[0] += grad_val;
		return;
	}
	if (theta_val >= theta_grid.back())
	{
		grad_P_array.back() += grad_val;
		return;
	}

	auto it = std::lower_bound(theta_grid.begin(), theta_grid.end(), theta_val);
	size_t idx = std::distance(theta_grid.begin(), it);
	size_t idx_prev = idx - 1;

	double w_next = (theta_val - theta_grid[idx_prev]) / (theta_grid[idx] - theta_grid[idx_prev]);
	double w_prev = 1.0 - w_next;

	grad_P_array[idx_prev] += grad_val * w_prev;
	grad_P_array[idx] += grad_val * w_next;

	return;
}

inline void computeInitializationSensitivities(const RadiativeLayer& adj_layer, const RadiativeLayer& fwd_matrix_layer, double single_scattering_albedo, const Geometry& geo, const std::vector<double>& theta_grid, double& grad_tau, double& grad_omega, std::vector<double>& grad_P)
{
	double tau = fwd_matrix_layer.optical_thickness;
	double omega = single_scattering_albedo;

	if (tau <= 1e-15 || omega <= 1e-15)
	{
		return;
	}

	double inv_tau = 1.0 / tau;
	double inv_omega = 1.0 / omega;
	double base_coeff = omega * tau / 4.0;

	grad_tau += adj_layer.optical_thickness;

	double sum_inner_product = 0.0;

	for (int m = 0; m <= geo.M; ++m)
	{
		sum_inner_product += (adj_layer.reflectance_m_top_cos[m].array() * fwd_matrix_layer.reflectance_m_top_cos[m].array()).sum();
		sum_inner_product += (adj_layer.transmittance_m_top_cos[m].array() * fwd_matrix_layer.transmittance_m_top_cos[m].array()).sum();
	}

	grad_tau += sum_inner_product * inv_tau;
	grad_omega += sum_inner_product * inv_omega;

	for (int i = 0; i < geo.Ntheta; ++i) 
	{
		for (int j = 0; j < geo.Ntheta; ++j) 
		{
			double mu_i = geo.mu(i);
			double mu_j = geo.mu(j);
			double geom_factor = base_coeff / (mu_i * mu_j);

			for (int k = 0; k < geo.Nphi; ++k) 
			{
				double phi = geo.phi(k);
				
				double weight_phi = geo.d_phi;
				
				double cos_phi = std::cos(phi);

				double grad_R_val = 0.0;
				double grad_T_val = 0.0;

				for (int m = 0; m <= geo.M; ++m) 
				{
					double cos_m_phi = std::cos(m * phi);
					// double factor = (m == 0) ? 1.0 : 2.0;
					double factor = 1.0;

					grad_R_val += factor * adj_layer.reflectance_m_top_cos[m](i, j) * cos_m_phi;
					grad_T_val += factor * adj_layer.transmittance_m_top_cos[m](i, j) * cos_m_phi;
				}

				double sin_i = std::sqrt(std::max(0.0, 1.0 - mu_i * mu_i));
				double sin_j = std::sqrt(std::max(0.0, 1.0 - mu_j * mu_j));

				double cos_theta_refl = -mu_i * mu_j + sin_i * sin_j * cos_phi;
				double theta_refl = std::acos(std::clamp(cos_theta_refl, -1.0, 1.0));

				double cos_theta_tran =  mu_i * mu_j + sin_i * sin_j * cos_phi;
				double theta_tran = std::acos(std::clamp(cos_theta_tran, -1.0, 1.0));
				
				double common_grad_factor = geom_factor * (geo.d_phi / (2.0 * std::numbers::pi));

				#pragma omp critical
				{
					accumulate_gradient_to_grid(theta_refl, grad_R_val * common_grad_factor, theta_grid, grad_P);
					accumulate_gradient_to_grid(theta_tran, grad_T_val * common_grad_factor, theta_grid, grad_P);
				}
			}
		}
	}
}

inline OpticalSensitivity computeInitializationSensitivities(const RadiativeLayer& adj_layer, const RadiativeLayer& fwd_matrix_layer, double single_scattering_albedo, const Geometry& geo, int n_theta)
{
	OpticalSensitivity result;
	result.optical_thickness = 0.0;
	result.single_scattering_albedo = 0.0;

	double tau = fwd_matrix_layer.optical_thickness;
	double omega = single_scattering_albedo;

	// if (tau <= 1e-15 || omega <= 1e-15)
	// {
	// 	return result;
	// }

	double inv_tau = 1.0 / tau;
	double inv_omega = 1.0 / omega;
	double base_coeff = omega * tau / 4.0;

	result.optical_thickness += adj_layer.optical_thickness;

	double sum_inner_product = 0.0;

	for (int m = 0; m <= geo.M; ++m)
	{
		sum_inner_product += (adj_layer.reflectance_m_top_cos[m].array() * fwd_matrix_layer.reflectance_m_top_cos[m].array()).sum();
		sum_inner_product += (adj_layer.transmittance_m_top_cos[m].array() * fwd_matrix_layer.transmittance_m_top_cos[m].array()).sum();
	}

	result.optical_thickness += sum_inner_product * inv_tau;
	result.single_scattering_albedo += sum_inner_product * inv_omega;

	std::vector<double> theta_grid(n_theta);
	std::vector<double> grad_P(n_theta, 0.0);
	for(int i = 0; i < n_theta; ++i)
	{
		theta_grid[i] = std::numbers::pi / double(n_theta - 1) * double(i);
	}

	for (int i = 0; i < geo.Ntheta; ++i) 
	{
		for (int j = 0; j < geo.Ntheta; ++j) 
		{
			double mu_i = geo.mu(i);
			double mu_j = geo.mu(j);
			double geom_factor = base_coeff / (mu_i * mu_j);

			for (int k = 0; k < geo.Nphi; ++k) 
			{
				double phi = geo.phi(k);
				
				double weight_phi = geo.d_phi;
				
				double cos_phi = std::cos(phi);

				double grad_R_val = 0.0;
				double grad_T_val = 0.0;

				for (int m = 0; m <= geo.M; ++m) 
				{
					double cos_m_phi = std::cos(m * phi);
					// double factor = (m == 0) ? 1.0 : 2.0;
					double factor = 1.0;

					grad_R_val += factor * adj_layer.reflectance_m_top_cos[m](i, j) * cos_m_phi;
					grad_T_val += factor * adj_layer.transmittance_m_top_cos[m](i, j) * cos_m_phi;
				}

				double sin_i = std::sqrt(std::max(0.0, 1.0 - mu_i * mu_i));
				double sin_j = std::sqrt(std::max(0.0, 1.0 - mu_j * mu_j));

				double cos_theta_refl = -mu_i * mu_j + sin_i * sin_j * cos_phi;
				double theta_refl = std::acos(std::clamp(cos_theta_refl, -1.0, 1.0));

				double cos_theta_tran =  mu_i * mu_j + sin_i * sin_j * cos_phi;
				double theta_tran = std::acos(std::clamp(cos_theta_tran, -1.0, 1.0));
				
				double common_grad_factor = geom_factor * (geo.d_phi / (2.0 * std::numbers::pi));

				#pragma omp critical
				{
					accumulate_gradient_to_grid(theta_refl, grad_R_val * common_grad_factor, theta_grid, grad_P);
					accumulate_gradient_to_grid(theta_tran, grad_T_val * common_grad_factor, theta_grid, grad_P);
				}
			}
		}
	}

	result.scattering_phase_function.resize(n_theta);
	for(int i = 0; i < n_theta; ++i)
	{
		result.scattering_phase_function[i] = {theta_grid[i], grad_P[i]};
	}

	return result;
}


}