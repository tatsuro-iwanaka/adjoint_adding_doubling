#pragma once

#include<filesystem>
#include<fstream>
#include<vector>
#include<string>
#include<iomanip>
#include<cmath>

#include<Eigen/Dense>
#include<netcdf>

#include"types"
#include"constants"
#include"spline"

namespace radiative_transfer
{

inline void RadiativeTransfer::exportResultNetCDF(void)
{
	std::cout << "[RadiativeTransfer::exportResultNetCDF] Exporting result." << std::endl;

	std::string filename = simulation_.directory_name + simulation_.result_name;

	netCDF::NcFile outputFile(filename, netCDF::NcFile::replace);

	//Simulation configuration
	outputFile.putAtt("simulation_name", simulation_.simulation_name);

	// 次元の定義
	int Ntheta = geometry_.Ntheta;
	int Nphi = geometry_.Nphi;
	int Nmode = geometry_.M;
	int Nlayer = result_.altitude.size();
	int Nspectral = spectral_.spectral_grid.size();
	int Nscattering_angle = result_.spectral_data[0].scattering_phase_function[0].size();

	netCDF::NcDim dim_theta_e = outputFile.addDim("theta_e", Ntheta);
	netCDF::NcDim dim_theta_i = outputFile.addDim("theta_i", Ntheta);
	netCDF::NcDim dim_phi = outputFile.addDim("delta_phi", Nphi);
	netCDF::NcDim dim_M = outputFile.addDim("M", Nmode + 1);
	netCDF::NcDim dim_layer = outputFile.addDim("layer", Nlayer);
	netCDF::NcDim dim_scattering_angle = outputFile.addDim("scattering_angle", Nscattering_angle);
	netCDF::NcDim dim_spectral;
	
	if(spectral_.spectral_dimension == SpectralCoordinateDimension::Wavenumber)
	{
		dim_spectral = outputFile.addDim("wavenumber", Nspectral);
	}
	else if(spectral_.spectral_dimension == SpectralCoordinateDimension::Wavelength)
	{
		dim_spectral = outputFile.addDim("wavelength", Nspectral);
	}

	std::vector<double> phi;
	std::vector<int> _M;
	
	for(int i = 0; i < Nphi; i ++)
	{
		phi.push_back(PI / double(Nphi - 1) * double(i));
	}

	for(int i = 0; i < Nmode + 1; i ++)
	{
		_M.push_back(i);
	}

	netCDF::NcVar var_theta_e = outputFile.addVar("theta_e", netCDF::ncDouble, dim_theta_e);
	var_theta_e.setCompression(true, true, 5);
	var_theta_e.putAtt("long_name", "emission zenith angle");
	var_theta_e.putAtt("units", "radian");
	var_theta_e.putVar(result_.theta_e.data());
	netCDF::NcVar var_theta_i = outputFile.addVar("theta_i", netCDF::ncDouble, dim_theta_i);
	var_theta_i.setCompression(true, true, 5);
	var_theta_i.putAtt("long_name", "incidence zenith angle");
	var_theta_i.putAtt("units", "radian");
	var_theta_i.putVar(result_.theta_i.data());
	netCDF::NcVar var_phi = outputFile.addVar("delta_phi", netCDF::ncDouble, dim_phi);
	var_phi.setCompression(true, true, 5);
	var_phi.putAtt("long_name", "azimuthal difference");
	var_phi.putAtt("units", "radian");
	var_phi.putVar(phi.data());
	netCDF::NcVar var_M = outputFile.addVar("M", netCDF::ncInt, dim_M);
	var_M.setCompression(true, true, 5);
	var_M.putAtt("long_name", "Fourier modes");
	var_M.putAtt("units", "dimensionless");
	var_M.putVar(_M.data());
	netCDF::NcVar var_spectral;
	if(spectral_.spectral_dimension == SpectralCoordinateDimension::Wavenumber)
	{
		var_spectral = outputFile.addVar("wavenumber", netCDF::ncDouble, dim_spectral);
		var_spectral.setCompression(true, true, 5);
		var_spectral.putAtt("long_name", "wavenumber");
		var_spectral.putAtt("units", "m-1");
		var_spectral.putVar(spectral_.spectral_grid.data());
	}
	else if(spectral_.spectral_dimension == SpectralCoordinateDimension::Wavelength)
	{
		var_spectral = outputFile.addVar("wavelength", netCDF::ncDouble, dim_spectral);
		var_spectral.setCompression(true, true, 5);
		var_spectral.putAtt("long_name", "wavelength");
		var_spectral.putAtt("units", "m");
		var_spectral.putVar(spectral_.spectral_grid.data());
	}
	
	std::vector<double> reflectance_flat(Nspectral * Ntheta * Ntheta * Nphi);

	for(int l = 0; l < Nspectral; l ++)
	{
		for(int e = 0; e < Ntheta; e ++)
		{
			for(int i = 0; i < Ntheta; i ++)
			{
				for(int p = 0; p < Nphi; p ++)
				{
					int idx = l * (Ntheta * Ntheta * Nphi) + e * (Ntheta * Nphi) + i * Nphi + p;

					double r = result_.spectral_data[l].reflectance_m_top_cos[0](e, i);

					for(int m = 1; m <= geometry_.M; m ++)
					{
						double rcos = result_.spectral_data[l].reflectance_m_top_cos[m](e, i);
						double rsin = result_.spectral_data[l].reflectance_m_top_sin[m](e, i);

						r += 2.0 * (rcos * std::cos(double(m) * phi[p]) + rsin * std::sin(double(m) * phi[p]));
					}

					reflectance_flat[idx] = r;
				}
			}
		}
	}

	netCDF::NcVar var_reflectance = outputFile.addVar("reflectance", netCDF::ncDouble, {dim_spectral, dim_theta_e, dim_theta_i, dim_phi});
	var_reflectance.setCompression(true, true, 5);
	if(spectral_.spectral_dimension == SpectralCoordinateDimension::Wavenumber)
	{
		var_reflectance.putAtt("long_name", "reflectance (wavenumber, emission zenith angle, incidence zenith angle, azimuthal difference)");
	}
	else if(spectral_.spectral_dimension == SpectralCoordinateDimension::Wavelength)
	{
		var_reflectance.putAtt("long_name", "reflectance (wavelength, emission zenith angle, incidence zenith angle, azimuthal difference)");
	}
	var_reflectance.putAtt("units", "dimensionless");
	var_reflectance.putVar(reflectance_flat.data());

	netCDF::NcVar var_scattering_angle = outputFile.addVar("scattering_angle", netCDF::ncDouble, dim_scattering_angle);
	var_scattering_angle.putAtt("long_name", "scattering angle");
	var_scattering_angle.putAtt("units", "radian");
	std::vector<double> scattering_angle(Nscattering_angle);
	for(int i = 0; i < Nscattering_angle; ++i)
	{
		scattering_angle[i] = result_.spectral_data[0].scattering_phase_function[0][i][0];
	}
	var_scattering_angle.putVar(scattering_angle.data());

	std::vector<double> reflectance_am(Nspectral * (Nmode + 1) * Ntheta * Ntheta);
	std::vector<double> reflectance_bm(Nspectral * (Nmode + 1) * Ntheta * Ntheta);

	for(int l = 0; l < Nspectral; l ++)
	{
		for(int m = 0; m < Nmode + 1; m ++)
		{
			for(int e = 0; e < Ntheta; e ++)
			{
				for(int i = 0; i < Ntheta; i ++)
				{
					int idx = l * ((Nmode + 1) * Ntheta * Ntheta) + m * (Ntheta * Ntheta) + e * Ntheta + i;

					reflectance_am[idx] = result_.spectral_data[l].reflectance_m_top_cos[m](e, i);
					reflectance_bm[idx] = result_.spectral_data[l].reflectance_m_top_sin[m](e, i);
				}
			}
		}
	}

	netCDF::NcVar var_reflectance_am = outputFile.addVar("reflectance_am", netCDF::ncDouble, {dim_spectral, dim_M, dim_theta_e, dim_theta_i});
	var_reflectance_am.setCompression(true, true, 5);
	var_reflectance_am.putAtt("long_name", "Fourier cosine coefficients a_m for azimuthal expansion of reflectance.");
	var_reflectance_am.putAtt("units", "dimensionless");
	var_reflectance_am.putVar(reflectance_am.data());

	netCDF::NcVar var_reflectance_bm = outputFile.addVar("reflectance_bm", netCDF::ncDouble, {dim_spectral, dim_M, dim_theta_e, dim_theta_i});
	var_reflectance_bm.setCompression(true, true, 5);
	var_reflectance_bm.putAtt("long_name", "Fourier sine coefficients b_m for azimuthal expansion of reflectance.");
	var_reflectance_bm.putAtt("units", "dimensionless");
	var_reflectance_bm.putVar(reflectance_bm.data());

	std::vector<double> tau(Nlayer * Nspectral);
	std::vector<double> ka(Nlayer * Nspectral);
	std::vector<double> ks(Nlayer * Nspectral);
	std::vector<double> omega(Nlayer * Nspectral);
	std::vector<double> g(Nlayer * Nspectral);
	
	for(int l = 0; l < Nlayer; l ++)
	{
		for(int i = 0; i < Nspectral; i ++)
		{
			tau[l * Nspectral + i] = result_.spectral_data[i].optical_thickness[l];
			ka[l * Nspectral + i] = result_.spectral_data[i].absorption_coefficient[l];
			ks[l * Nspectral + i] = result_.spectral_data[i].scattering_coefficient[l];
			omega[l * Nspectral + i] = result_.spectral_data[i].single_scattering_albedo[l];
			g[l * Nspectral + i] = result_.spectral_data[i].asymmetry_parameter[l];
		}
	}

	

	netCDF::NcVar var_z = outputFile.addVar("altitude", netCDF::ncDouble, dim_layer);
	var_z.putAtt("long_name", "altitude of center of layer");
	var_z.putAtt("units", "m");
	var_z.putVar(result_.altitude.data());
	netCDF::NcVar var_z_top = outputFile.addVar("altitude_top", netCDF::ncDouble, dim_layer);
	var_z_top.putAtt("long_name", "altitude of top of layer");
	var_z_top.putAtt("units", "m");
	var_z_top.putVar(result_.altitude_top.data());
	netCDF::NcVar var_z_bottom = outputFile.addVar("altitude_bottom", netCDF::ncDouble, dim_layer);
	var_z_bottom.putAtt("long_name", "altitude of bottom of layer");
	var_z_bottom.putAtt("units", "m");
	var_z_bottom.putVar(result_.altitude_bottom.data());
	netCDF::NcVar var_physical_thickness = outputFile.addVar("physical_thickness", netCDF::ncDouble, dim_layer);
	var_physical_thickness.putAtt("long_name", "physical thickness of layer");
	var_physical_thickness.putAtt("units", "m");
	var_physical_thickness.putVar(result_.physical_thickness.data());
	netCDF::NcVar var_T = outputFile.addVar("temperature", netCDF::ncDouble, dim_layer);
	var_T.putAtt("long_name", "temperature");
	var_T.putAtt("units", "K");
	var_T.putVar(result_.temperature.data());
	netCDF::NcVar var_P = outputFile.addVar("pressure", netCDF::ncDouble, dim_layer);
	var_P.putAtt("long_name", "pressure");
	var_P.putAtt("units", "Pa");
	var_P.putVar(result_.pressure.data());
	netCDF::NcVar var_ND = outputFile.addVar("number_density", netCDF::ncDouble, dim_layer);
	var_ND.putAtt("long_name", "number density");
	var_ND.putAtt("units", "molecule/m^3");
	var_ND.putVar(result_.number_density.data());

	if(atmosphere_model_.enable_atmospheric_emission)
	{
		netCDF::NcVar var_emission = outputFile.addVar("thermal_emission", netCDF::ncDouble, {dim_spectral, dim_theta_e});
		var_emission.setCompression(true, true, 5);
		if(spectral_.spectral_dimension == SpectralCoordinateDimension::Wavenumber)
		{
			var_emission.putAtt("long_name", "atmospheric emission (wavenumber, emission direction)");
			var_emission.putAtt("units", "W/m2/sr/m-1");
		}
		else if(spectral_.spectral_dimension == SpectralCoordinateDimension::Wavelength)
		{
			var_emission.putAtt("long_name", "atmospheric emission (wavelength, emission direction)");
			var_emission.putAtt("units", "W/m2/sr/m");
		}

		std::vector<double> source_up;
		for(int l = 0; l < Nspectral; l ++)
		{
			for(int e = 0; e < Ntheta; e ++)
			{
				source_up.push_back(result_.spectral_data[l].source_up(e));
			}
		}

		var_emission.putVar(source_up.data());
	}

	netCDF::NcVar var_ka = outputFile.addVar("absorption_coefficient", netCDF::ncDouble, {dim_layer, dim_spectral});
	var_ka.putAtt("long_name", "absorption coefficient ka (layer, spectral)");
	var_ka.putAtt("units", "1/m");
	var_ka.putVar(ka.data());
	netCDF::NcVar var_ks = outputFile.addVar("scattering_coefficient", netCDF::ncDouble, {dim_layer, dim_spectral});
	var_ks.putAtt("long_name", "scattering coefficient ks (layer, spectral)");
	var_ks.putAtt("units", "1/m");
	var_ks.putVar(ks.data());
	netCDF::NcVar var_dtau = outputFile.addVar("optical_thickness", netCDF::ncDouble, {dim_layer, dim_spectral});
	var_dtau.putAtt("long_name", "optical thickness: dz * (ks + ka) (layer, spectral)");
	var_dtau.putAtt("units", "dimensionless");
	var_dtau.putVar(tau.data());

	// newly added
	std::vector<double> tau_top(Nlayer * Nspectral);
	std::vector<double> tau_bottom(Nlayer * Nspectral);
	std::vector<double> tau_center(Nlayer * Nspectral);

	for(int i = 0; i < Nlayer; ++i)
	{
		for(int j = 0; j < Nspectral; ++j)
		{
			double depth_top = 0.0;
			for(int k = i + 1; k < Nlayer; ++k)
			{
				depth_top += tau[k * Nspectral + j];
			}
			tau_top[i * Nspectral + j] = depth_top;
			tau_bottom[i * Nspectral + j] = depth_top + tau[i * Nspectral + j];
			tau_center[i * Nspectral + j] = (tau_top[i * Nspectral + j] + tau_bottom[i * Nspectral + j]) * 0.5;
		}
	}

	netCDF::NcVar var_tau_top = outputFile.addVar("optical_depth_top", netCDF::ncDouble, {dim_layer, dim_spectral});
	var_tau_top.putAtt("long_name", "optical depth at the top of the layer (layer, spectral)");
	var_tau_top.putAtt("units", "dimensionless");
	var_tau_top.putVar(tau_top.data());
	netCDF::NcVar var_tau_center = outputFile.addVar("optical_depth_center", netCDF::ncDouble, {dim_layer, dim_spectral});
	var_tau_center.putAtt("long_name", "optical depth at the center of the layer (layer, spectral)");
	var_tau_center.putAtt("units", "dimensionless");
	var_tau_center.putVar(tau_center.data());
	netCDF::NcVar var_tau_bottom = outputFile.addVar("optical_depth_bottom", netCDF::ncDouble, {dim_layer, dim_spectral});
	var_tau_bottom.putAtt("long_name", "optical depth at the bottom of the layer (layer, spectral)");
	var_tau_bottom.putAtt("units", "dimensionless");
	var_tau_bottom.putVar(tau_bottom.data());


	netCDF::NcVar var_omega = outputFile.addVar("single_scattering_albedo", netCDF::ncDouble, {dim_layer, dim_spectral});
	var_omega.putAtt("long_name", "single scattering albedo: ks/(ks + ka) (layer, spectral)");
	var_omega.putAtt("units", "dimensionless");
	var_omega.putVar(omega.data());
	// newly added
	netCDF::NcVar var_pf = outputFile.addVar("scattering_phase_function", netCDF::ncDouble, {dim_layer, dim_spectral, dim_scattering_angle});
	var_pf.putAtt("long_name", "scattering phase function (layer, spectral, scattering_angle)");
	var_pf.putAtt("units", "dimensionless");
	std::vector<double> pf_flat(Nlayer * Nspectral * Nscattering_angle);
	for(int i = 0; i < Nlayer; ++i)
	{
		for(int j = 0; j < Nspectral; ++j)
		{
			for(int k = 0; k < Nscattering_angle; ++k)
			{
				pf_flat[i * (Nspectral * Nscattering_angle) + j * (Nscattering_angle) + k] = result_.spectral_data[j].scattering_phase_function[i][k][1];
			}
		}
	}
	var_pf.putVar(pf_flat.data());
	// var_pf.putVar(omega.data());

	netCDF::NcVar var_g = outputFile.addVar("asymmetry_parameter", netCDF::ncDouble, {dim_layer, dim_spectral});
	var_g.putAtt("long_name", "asymmetry parameter (layer, spectral)");
	var_g.putAtt("units", "dimensionless");
	var_g.putVar(g.data());
	
	int n_species = atmosphere_model_.species.size();
	netCDF::NcVar var_n_species = outputFile.addVar("n_species", netCDF::ncInt);
	var_n_species.putAtt("long_name", "number of species");
	var_n_species.putVar(&n_species);


	//group for species
	for(int i = 0; i < atmosphere_model_.species.size(); i ++)
	{
		netCDF::NcGroup group = outputFile.addGroup("species_" + std::to_string(i + 1));

		group.putAtt("name", atmosphere_model_.species[i].name);		

		netCDF::NcVar var_mixing_ratio = group.addVar("mixing_ratio", netCDF::ncDouble, dim_layer);
		var_mixing_ratio.putAtt("long_name", "mixing ratio (layer)");
		var_mixing_ratio.putAtt("units", "dimensionless");
		netCDF::NcVar var_species_number_density = group.addVar("number_density", netCDF::ncDouble, dim_layer);
		var_species_number_density.putAtt("long_name", "number density (layer)");
		var_species_number_density.putAtt("units", "molecule/m^3");

		std::vector<double> mixing_ratio, nd;

		for(int nz = 0; nz < Nlayer; nz ++)
		{
			mixing_ratio.push_back(atmosphere_model_.species[i].vertical_mixing_ratio_profile[nz]);
			nd.push_back(atmosphere_model_.species[i].vertical_number_density_profile[nz]);
		}
		var_mixing_ratio.putVar(mixing_ratio.data());		
		var_species_number_density.putVar(nd.data());

		std::vector<double> scs(Nlayer * Nspectral);
		std::vector<double> acs(Nlayer * Nspectral);
		
		for(int j = 0; j < Nlayer; ++j)
		{
			for(int k = 0; k < Nspectral; ++k)
			{
				scs[j * Nspectral + k] = result_.spectral_data[k].species_scattering_cross_section[j][i];
				acs[j * Nspectral + k] = result_.spectral_data[k].species_absorption_cross_section[j][i];
			}
		}
		netCDF::NcVar var_absorption_cross_section = group.addVar("absorption_cross_section", netCDF::ncDouble, {dim_layer, dim_spectral});
		var_absorption_cross_section.putAtt("long_name", "absorption cross section (layer, spectral)");
		var_absorption_cross_section.putAtt("units", "m2");
		var_absorption_cross_section.putVar(acs.data());
		
		netCDF::NcVar var_scattering_cross_section = group.addVar("scattering_cross_section", netCDF::ncDouble, {dim_layer, dim_spectral});
		var_scattering_cross_section.putAtt("long_name", "scattering cross section (layer, spectral)");
		var_scattering_cross_section.putAtt("units", "m2");
		var_scattering_cross_section.putVar(scs.data());

		if(result_.spectral_data[0].is_scattering_species[i] == true)
		{
			std::vector<double> spf(Nlayer * Nspectral * Nscattering_angle);

			for(int j = 0; j < Nlayer; ++j)
			{
				for(int k = 0; k < Nspectral; ++k)
				{
					for(int l = 0; l < Nscattering_angle; ++l)
					{
						spf[j * Nspectral * Nscattering_angle + k * Nscattering_angle + l] = result_.spectral_data[k].species_scattering_phase_function[j][i][l][1];
					}
				}
			}

			netCDF::NcVar var_species_scattering_phase_angle = group.addVar("scattering_phase_angle", netCDF::ncDouble, {dim_layer, dim_spectral, dim_scattering_angle});
			var_species_scattering_phase_angle.putAtt("long_name", "species scattering phase angle (layer, spectral)");
			var_species_scattering_phase_angle.putAtt("units", "dimensionless");
			var_species_scattering_phase_angle.putVar(spf.data());
		}
	}

	
	return;
}

}