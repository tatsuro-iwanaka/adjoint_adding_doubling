#pragma once

#include<fstream>
#include<iostream>
#include<map>
#include<sstream>
#include<string>
#include<vector>
#include<algorithm>

#include"types"
#include"constants"
#include"utilities"
#include"hitran"

namespace radiative_transfer
{

inline Configuration ConfigurationLoader::load(const std::string& filename)
{
	Configuration configuration;
	auto kv = importYaml_(filename);

	configuration.simulation = loadSimulation_(kv);
	configuration.spectral_coordinate = loadSpectralCoordinate_(kv);
	configuration.geometry = loadGeometry_(kv);
	configuration.delta_m = loadDeltaM_(kv);
	configuration.surface = loadSurface_(kv);
	configuration.atmosphere = loadAtmosphere_(kv);
	configuration.instrument = loadInstrument_(kv);

	return configuration;
}


inline std::map<std::string, std::string> ConfigurationLoader::importYaml_(const std::string& filename)
{
	std::ifstream ifs(filename);
	if (!ifs) throw std::runtime_error("Cannot open " + filename);

	auto trim = [](std::string s) -> std::string
	{
		const auto ws = " \t\r\n";
		auto b = s.find_first_not_of(ws);

		if (b == std::string::npos)
		{
			return "";
		}

		auto e = s.find_last_not_of(ws);

		return s.substr(b, e - b + 1);
	};

	// splitFlow ラムダ（深さ depth によってカンマを分割）
	auto splitFlow = [&trim](std::string s) -> std::vector<std::string>
	{
		std::vector<std::string> elems;
		std::string cur;
		int depth = 0;
		
		for (size_t i = 0; i < s.size(); ++i)
		{
			char c = s[i];
			if(c == '[')
			{
				depth++;
				cur += c;
			}
			else if(c == ']')
			{
				depth--;
				cur += c;
			}
			else if(c == ',' && depth == 0)
			{
				elems.push_back(trim(cur));
				cur.clear();
			}
			else
			{
				cur += c;
			}
		}

		if (!cur.empty()) elems.push_back(trim(cur));

		return elems;
	};

	constexpr int INDENT = 2;
	int prev_depth = 0, line_no = 0;
	std::vector<std::string> stack;
	std::map<std::string,int> seqCount;
	std::map<std::string,std::string> kv;

	std::string line;
	while (std::getline(ifs, line))
	{
		++line_no;
		// コメント削除
		auto ph = line.find('#');
		std::string raw = (ph == std::string::npos ? line : line.substr(0,ph));
		if (trim(raw).empty()) continue;

		// インデント数カウント
		int nsp = 0;
		while (nsp < (int)raw.size() && raw[nsp]==' ') ++nsp;
		if (nsp % INDENT != 0)
			throw std::runtime_error("Indent error at line " + std::to_string(line_no));
		int depth = nsp / INDENT;
		if (depth > prev_depth + 1)
			throw std::runtime_error("Nesting error at line " + std::to_string(line_no));
		prev_depth = depth;

		// 本文
		std::string body = trim(raw.substr(nsp));

		// ブロックシーケンス（- item）優先処理
		if (!body.empty() && body[0]=='-')
		{
			if (stack.empty())
			{
				throw std::runtime_error("Sequence item without parent at line " + std::to_string(line_no));
			}
		
			// prefix を組み立て（例: "species.2.vertical_profile.table"）
			std::string prefix = stack[0];
			for (int i = 1; i < (int)stack.size(); ++i)
			{
				prefix += "." + stack[i];
			}
		
			// "- " のあと、raw に "[1.0, 2e-13]" を取得
			std::string raw = trim(body.substr(1));
			int row = seqCount[prefix]++;
		
			// もし flow‐sequence なら "[" と "]" を外して splitFlow で分割
			if (raw.size() >= 2 && raw.front() == '[' && raw.back() == ']')
			{
				auto cols = splitFlow(raw.substr(1, raw.size()-2));
				for (size_t col = 0; col < cols.size(); ++col)
				{
					// species.2.vertical_profile.table.0.0 = "1.0"
					// species.2.vertical_profile.table.0.1 = "2.7576e-13"
					kv[prefix + "." 
					   + std::to_string(row) + "." 
					   + std::to_string(col)] = cols[col];
				}
			}
			else
			{
				// 通常の単一要素シーケンスはそのまま
				kv[prefix + "." + std::to_string(row)] = raw;
			}
			continue;
		}

		// key: ... 解析
		auto pc = body.find(':');
		if (pc == std::string::npos)
			throw std::runtime_error("Syntax error at line " + std::to_string(line_no));
		std::string key = trim(body.substr(0,pc));
		std::string val = trim(body.substr(pc+1));

		if (val.empty())
		{
			// ネスト開始行
			if ((int)stack.size() > depth) stack.resize(depth);
			if ((int)stack.size() == depth) stack.push_back(key);
			else                         stack[depth] = key;
		}
		else
		{
			// 値付き行
			// クオート除去
			if ((val.front()=='"'&&val.back()=='"')||(val.front()=='\''&&val.back()=='\''))
				val = val.substr(1,val.size()-2);

			// フルパスキー
			std::string full = (depth==0 ? key : stack[0]);
			for (int i=1; i<depth; ++i) full += "." + stack[i];
			if (depth>0) full += "." + key;

			// フローシーケンスかどうか
			if (val.size()>=2 && val.front()=='[' && val.back()==']')
			{
				// 内部を切り出して、深さ0 のカンマで分割
				std::string inside = val.substr(1,val.size()-2);
				auto items = splitFlow(inside);

				for (size_t j=0; j<items.size(); ++j)
				{
					kv[full + "." + std::to_string(j)] = items[j];
				}
			}
			else 
			{
				// 通常のスカラー値
				kv[full] = val;
			}
		}
	}

	return kv;
}


inline Configuration::Simulation ConfigurationLoader::loadSimulation_(const std::map<std::string, std::string>& kv)
{
	Configuration::Simulation simulation;

	std::string prefix = "simulation.";

	simulation.simulation_name = getOptionalString_(kv, prefix + "name");
	simulation.n_parallel = getOptionalInt_(kv, prefix + "n_parallel");
	simulation.directory_name = getOptionalString_(kv, prefix + "directory");
	simulation.logfile_name = getOptionalString_(kv, prefix + "logfile");
	simulation.result_name = getOptionalString_(kv, prefix + "result");
	simulation.n_scattering_angle = getOptionalInt_(kv, prefix + "n_scattering_angle");
	simulation.tau_initial_layer = getOptionalDouble_(kv, prefix + "tau_initial_layer");
	simulation.enable_atmospheric_emission = getOptionalBool_(kv, prefix + "enable_atmospheric_emission");	

	return simulation;
}

inline Configuration::SpectralCoordinate ConfigurationLoader::loadSpectralCoordinate_(const std::map<std::string, std::string>& kv)
{
	Configuration::SpectralCoordinate spectral_coordinate;

	std::string prefix = "simulation.spectral_coordinate.";

	spectral_coordinate.spectral_coordinate_dimension = parseEnum_(getOptionalString_(kv, prefix + "dimension"), map_spectral_coordinate_dimension);
	spectral_coordinate.spectral_coordinate_type = parseEnum_(getOptionalString_(kv, prefix + "type"), map_spectral_coordinate_type);
	spectral_coordinate.unit = getOptionalString_(kv, prefix + "unit");

	spectral_coordinate.mono = getOptionalDouble_(kv, prefix + "value");

	// int n_lambda = countArrayEntries_(kv, prefix + "tics");
	// for(int i = 0; i < n_lambda; i ++)
	// {
	// 	spectral_coordinate.spectral_grid.push_back(getRequiredDouble_(kv, prefix + "tics." + std::to_string(i)));
	// }

	spectral_coordinate.min = getOptionalDouble_(kv, prefix + "min");
	spectral_coordinate.max = getOptionalDouble_(kv, prefix + "max");
	spectral_coordinate.increment = getOptionalDouble_(kv, prefix + "increment");
	spectral_coordinate.n_spectral = getOptionalInt_(kv, prefix + "count");

	return spectral_coordinate;
}

inline Configuration::GeometryConfiguration ConfigurationLoader::loadGeometry_(const std::map<std::string, std::string>& kv)
{
	Configuration::GeometryConfiguration geometry;

	std::string prefix = "simulation.grid.";

	geometry.grid_type = parseEnum_(getOptionalString_(kv, prefix + "type", "Gauss_Radau"), map_grid_type);

	geometry.n_theta = getOptionalInt_(kv, prefix + "n_zenith_angle");
	geometry.n_phi = getOptionalInt_(kv, prefix + "n_azimuth_angle");
	geometry.n_mode = getOptionalInt_(kv, prefix + "n_fourier_mode");

	return geometry;
}

inline Configuration::DeltaM ConfigurationLoader::loadDeltaM_(const std::map<std::string, std::string>& kv)
{
	Configuration::DeltaM delta_m;

	std::string prefix = "simulation.grid.delta_approximation.";

	delta_m.delta_approximation_type = parseEnum_(getOptionalString_(kv, prefix + "type"), map_delta_approximation_type);
	delta_m.f_target = getOptionalDouble_(kv, prefix + "f_target");
	delta_m.fwhm_ratio = getOptionalDouble_(kv, prefix + "fwhm_ratio");
	delta_m.icss_type = parseEnum_(getOptionalString_(kv, prefix + "in_cell_supersampling.type"), map_in_cell_super_sampling_type);
	delta_m.n_icss_sample = getOptionalInt_(kv, prefix + "in_cell_supersampling.n_sample");

	return delta_m;
}

inline Configuration::Surface ConfigurationLoader::loadSurface_(const std::map<std::string, std::string>& kv)
{
	Configuration::Surface surface;

	std::string prefix = "surface.";
	
	surface.type = parseEnum_(getOptionalString_(kv, prefix + "type"), map_surface_type);
	surface.albedo = getOptionalDouble_(kv, prefix + "albedo");
	surface.temperature = getOptionalDouble_(kv, prefix + "temperature");
	surface.unit = getOptionalString_(kv, prefix + "unit");

	return surface;
}

// 要修正：netcdf対応
inline Configuration::Atmosphere ConfigurationLoader::loadAtmosphere_(const std::map<std::string, std::string>& kv)
{
	Configuration::Atmosphere atmosphere;

	std::string prefix = "atmosphere.";
	// layering
	{
		std::string base = prefix + "layering.";

		int n_edge = countArrayEntries_(kv, base + "z_edge");
		for(int i = 0; i < n_edge; i ++)
		{
			atmosphere.z_edge.push_back(getRequiredDouble_(kv, base + "z_edge." + std::to_string(i)));
		}

		int n_center = countArrayEntries_(kv, base + "z_center");
		for(int i = 0; i < n_center; i ++)
		{
			atmosphere.z_center.push_back(getRequiredDouble_(kv, base + "z_center." + std::to_string(i)));
		}

		atmosphere.z_unit = getOptionalString_(kv, base + "unit");
	}
	// temperature
	{
		std::string base = prefix + "temperature.";

		atmosphere.is_same_temperature_layering_atmosphere = !hasKey_(kv, base + "table.0.1"); // tableがlayer*2でなければzのレイヤリングとは異なる
		atmosphere.vertical_temperature_profile = parseEnum_(getOptionalString_(kv, base + "vertical_profile"), map_vertical_temperature_profile);
		atmosphere.vertical_temperature_interpolation = parseEnum_(getOptionalString_(kv, base + "interpolation"), map_vertical_profile_interpolation);
		
		int n_tics = countArrayEntries_(kv, base + "table");

		if(atmosphere.is_same_temperature_layering_atmosphere)
		{
			atmosphere.temperature_unit = {getOptionalString_(kv, base + "unit")};
			
			for(int i = 0; i < n_tics; i ++)
			{
				atmosphere.temperature_profile.push_back({getRequiredDouble_(kv, base + "table." + std::to_string(i))});
			}

		}
		else
		{
			atmosphere.temperature_unit = {getOptionalString_(kv, base + "unit.0"), getOptionalString_(kv, base + "unit.1")};
			
			for(int i = 0; i < n_tics; i ++)
			{
				atmosphere.temperature_profile.push_back({getRequiredDouble_(kv, base + "table." + std::to_string(i) + ".0"), getRequiredDouble_(kv, base + "table." + std::to_string(i) + ".1")});
			}
		}
	}
	// pressure
	{
		std::string base = prefix + "pressure.";

		atmosphere.is_same_pressure_layering_atmosphere = !hasKey_(kv, base + "table.0.1"); // tableがlayer*2でなければzのレイヤリングとは異なる
		atmosphere.vertical_pressure_profile = parseEnum_(getOptionalString_(kv, base + "vertical_profile"), map_vertical_pressure_profile);
		atmosphere.vertical_pressure_interpolation = parseEnum_(getOptionalString_(kv, base + "interpolation"), map_vertical_profile_interpolation);
		
		int n_tics = countArrayEntries_(kv, base + "table");

		if(atmosphere.is_same_pressure_layering_atmosphere)
		{
			atmosphere.pressure_unit = {getOptionalString_(kv, base + "unit")};
			
			for(int i = 0; i < n_tics; i ++)
			{
				atmosphere.pressure_profile.push_back({getRequiredDouble_(kv, base + "table." + std::to_string(i))});
			}

		}
		else
		{
			atmosphere.pressure_unit = {getOptionalString_(kv, base + "unit.0"), getOptionalString_(kv, base + "unit.1")};
			
			for(int i = 0; i < n_tics; i ++)
			{
				atmosphere.pressure_profile.push_back({getRequiredDouble_(kv, base + "table." + std::to_string(i) + ".0"), getRequiredDouble_(kv, base + "table." + std::to_string(i) + ".1")});
			}
		}
	}
	// number density
	{
		std::string base = prefix + "number_density.";

		atmosphere.is_same_number_density_layering_atmosphere = !hasKey_(kv, base + "table.0.1"); // tableがlayer*2でなければzのレイヤリングとは異なる
		atmosphere.vertical_number_density_profile = parseEnum_(getOptionalString_(kv, base + "vertical_profile"), map_vertical_number_density_profile);
		atmosphere.vertical_number_density_interpolation = parseEnum_(getOptionalString_(kv, base + "interpolation"), map_vertical_profile_interpolation);
		
		int n_tics = countArrayEntries_(kv, base + "table");

		if(atmosphere.is_same_number_density_layering_atmosphere)
		{
			atmosphere.number_density_unit = {getOptionalString_(kv, base + "unit")};
			
			for(int i = 0; i < n_tics; i ++)
			{
				atmosphere.number_density_profile.push_back({getRequiredDouble_(kv, base + "table." + std::to_string(i))});
			}

		}
		else
		{
			atmosphere.number_density_unit = {getOptionalString_(kv, base + "unit.0"), getOptionalString_(kv, base + "unit.1")};
			
			for(int i = 0; i < n_tics; i ++)
			{
				atmosphere.number_density_profile.push_back({getRequiredDouble_(kv, base + "table." + std::to_string(i) + ".0"), getRequiredDouble_(kv, base + "table." + std::to_string(i) + ".1")});
			}
		}
	}
	// hitran file
	{
		atmosphere.filename_hitran = getOptionalString_(kv, prefix + "hitran_file");
	}
	// diluent
	{
		int n_diluent = countArrayEntries_(kv, prefix + "diluent.table");
		for(int i = 0; i < n_diluent; i ++)
		{
			atmosphere.diluent_species.push_back(getRequiredString_(kv, prefix + "diluent.table." + std::to_string(i) + ".0"));
			atmosphere.diluent_ratio.push_back(getRequiredDouble_(kv, prefix + "diluent.table." + std::to_string(i) + ".1"));
		}
	}
	// species
	{
		int n_species = countArrayEntries_(kv, prefix + "species");
		
		atmosphere.species_configuration.clear();

		for(int i = 0; i < n_species; i ++)
		{
			std::string base = prefix + "species." + std::to_string(i) + ".";

			Configuration::SpeciesConfiguration s;
			s.name = getOptionalString_(kv, base + "name");

			s.is_same_layering_atmosphere = !hasKey_(kv, base + "vertical_profile.table.0.1");
			s.vertical_profile_interpolation = parseEnum_(getOptionalString_(kv, base + "vertical_profile.interpolation"), map_vertical_profile_interpolation);

			if(s.is_same_layering_atmosphere)
			{
				s.unit_vertical_profile = {getOptionalString_(kv, base + "vertical_profile.unit")};
				
				int n_tics = countArrayEntries_(kv, base + "vertical_profile.table");

				for(int j = 0; j < n_tics; j ++)
				{
					s.vertical_profile.push_back({getRequiredDouble_(kv, base + "vertical_profile.table." + std::to_string(j))});
				}
			}
			else
			{
				s.unit_vertical_profile = {getOptionalString_(kv, base + "vertical_profile.unit.0"), getOptionalString_(kv, base + "vertical_profile.unit.1")};
				
				int n_tics = countArrayEntries_(kv, base + "vertical_profile.table");

				for(int j = 0; j < n_tics; j ++)
				{
					s.vertical_profile.push_back({getRequiredDouble_(kv, base + "vertical_profile.table." + std::to_string(j) + ".0"), getRequiredDouble_(kv, base + "vertical_profile.table." + std::to_string(j) + ".1")});
				}
			}
		
			s.species_state = parseEnum_(getOptionalString_(kv, base + "state"), map_species_state);
			s.species_type = parseEnum_(getOptionalString_(kv, base + "type"), map_species_type);
			s.scatter_type = parseEnum_(getOptionalString_(kv, base + "scatter_type"), map_scatter_type);
			s.scattering_cross_section_type = parseEnum_(getOptionalString_(kv, base + "scattering_cross_section.type"), map_cross_section_type);
			s.absorption_cross_section_type = parseEnum_(getOptionalString_(kv, base + "absorption_cross_section.type"), map_cross_section_type);

			// scattering_cross_section:
			//   type: external
			//   file:
			//     filename: filename
			//     varname: [wavenumber, scattering_cross_section]
			
			s.scattering_cross_section = getOptionalDouble_(kv, base + "scattering_cross_section.value");
			s.scattering_cross_section_unit = getOptionalString_(kv, base + "scattering_cross_section.unit");
			s.absorption_cross_section = getOptionalDouble_(kv, base + "absorption_cross_section.value");
			s.absorption_cross_section_unit = getOptionalString_(kv, base + "absorption_cross_section.unit");

			s.filename_scattering_cross_section = getOptionalString_(kv, base + "scattering_cross_section.file.filename");
			s.varname_scattering_cross_section_spectral = getOptionalString_(kv, base + "scattering_cross_section.file.varname.0");
			s.varname_scattering_cross_section = getOptionalString_(kv, base + "scattering_cross_section.file.varname.1");
			// s.unit_input_scattering_spectral = getOptionalString_(kv, base + "scattering_cross_section.unit.0");
			// s.unit_input_scattering_cross_section = getOptionalString_(kv, base + "scattering_cross_section.unit.1");
			s.filename_absorption_cross_section = getOptionalString_(kv, base + "absorption_cross_section.file");
			s.varname_absorption_cross_section_spectral = getOptionalString_(kv, base + "absorption_cross_section.file.varname.0");
			s.varname_absorption_cross_section = getOptionalString_(kv, base + "absorption_cross_section.file.varname.1");
			// s.unit_input_absorption_spectral = getOptionalString_(kv, base + "absorption_cross_section.unit.0");
			// s.unit_input_absorption_cross_section = getOptionalString_(kv, base + "absorption_cross_section.unit.1");

			s.g_factor = getOptionalDouble_(kv, base + "g_factor");

			// hitran
			s.molecule_id = getOptionalInt_(kv, base + "molecule_id");
			s.isotopologue_type = parseEnum_(getOptionalString_(kv, base + "isotopologue.type"), map_isotopologue_type);
			s.isotopologue_abundance_type = parseEnum_(getOptionalString_(kv, base + "isotopologue.abundance"), map_isotopologue_abundance_type);
			int n_iso = countArrayEntries_(kv, base + "isotopologues.local_id");
			for(int j = 0; j < n_iso; j ++)
			{
				s.local_isotopologue_id.push_back(getRequiredInt_(kv, base + "isotopologues.local_id." + std::to_string(j)));
			}

			n_iso = countArrayEntries_(kv, base + "isotopologues.abundance");
			for(int j = 0; j < n_iso; j ++)
			{
				s.abundance.push_back(getRequiredDouble_(kv, base + "isotopologues.abundance." + std::to_string(j)));
			}

			n_iso = countArrayEntries_(kv, base + "isotopologues.scalar");
			for(int j = 0; j < n_iso; j ++)
			{
				s.scalar.push_back(getRequiredDouble_(kv, base + "isotopologues.scalar." + std::to_string(j)));
			}

			s.is_normalize = getOptionalBool_(kv, base + "isotopologues.normalize");
			//ここまでhitran

			// 粒径分布の型と一般的な設定
			s.size_distribution = parseEnum_(getOptionalString_(kv, base + "size_distribution.function"), map_particle_size_distribution);
			s.unit_input_radius = getOptionalString_(kv, base + "size_distribution.unit");
			s.count_radius = getOptionalInt_(kv, base + "size_distribution.n_sampling");

			// --- 1. Delta (r0) ---
			s.delta_r = getOptionalDouble_(kv, base + "size_distribution.r"); // r (単一半径)

			// --- 2. Rectangular ---
			s.rect_r_mean = getOptionalDouble_(kv, base + "size_distribution.r_mean");
			s.rect_width = getOptionalDouble_(kv, base + "size_distribution.width");

			// --- 3. Log-Normal (D.7: r_g, sigma_g) ---
			s.lnd_r_g = getOptionalDouble_(kv, base + "size_distribution.r_g");
			s.lnd_sigma_g = getOptionalDouble_(kv, base + "size_distribution.sigma_g");

			// --- 4. Gamma (D.5: a, b) ---
			s.gd_a = getOptionalDouble_(kv, base + "size_distribution.a");
			s.gd_b = getOptionalDouble_(kv, base + "size_distribution.b");

			// --- 5. Modified Gamma (D.6: r_c, alpha, gamma) ---
			s.mgd_r_c = getOptionalDouble_(kv, base + "size_distribution.r_c");
			s.mgd_alpha = getOptionalDouble_(kv, base + "size_distribution.alpha");
			s.mgd_gamma = getOptionalDouble_(kv, base + "size_distribution.gamma");

			// --- 6. Power Law (D.8: delta, r1, r2) ---
			s.pl_delta = getOptionalDouble_(kv, base + "size_distribution.delta");
			s.pl_r1 = getOptionalDouble_(kv, base + "size_distribution.r_1");
			s.pl_r2 = getOptionalDouble_(kv, base + "size_distribution.r_2");

			// ここまで粒径分布関数

			// ここから複素屈折率
			// 読み込みの例
			// refractive_index:
			//   type: constant
			//   value: [1.5014, 1.0E-3]

			// refractive_index:
			//   type: spectral
			//   file:
			//     filename: filename
			//     varname: [wavenumber, nr, ni]

			// refractive_index:
			//   type: vertical
			//   interpolation: linear
			//   unit: km
			//   table:
			//     - [0.0, 1.5, 1.0E-3]
			//     - [20.0, 1.5, 1.0E-3]
			//     - [100.0, 1.5, 1.0E-3]

			// refractive_index:
			//   type: spectral_vertical
			//   interpolation: linear
			//   file:
			//     filename: filename
			//     varname: [altitude, wavenumber, nr, ni]

			s.refractive_index_type = parseEnum_(getOptionalString_(kv, base + "refractive_index.type"), map_refractive_index_type);

			// constant用
			s.nr = getOptionalDouble_(kv, base + "refractive_index.value.0");
			s.ni = getOptionalDouble_(kv, base + "refractive_index.value.1");

			// spectral用
			s.filename_refractive_index_spectral = getOptionalString_(kv, base + "refractive_index.file.filename");
			s.varname_refractive_index_spectral_spectral = getOptionalString_(kv, base + "refractive_index.file.varname.0");
			s.varname_refractive_index_spectral_nr = getOptionalString_(kv, base + "refractive_index.file.varname.1");
			s.varname_refractive_index_spectral_ni = getOptionalString_(kv, base + "refractive_index.file.varname.2");

			// vertical用
			s.refractive_index_vertical_profile_interpolation  = parseEnum_(getOptionalString_(kv, base + "refractive_index.interpolation"), map_vertical_profile_interpolation);

			s.unit_refractive_index_vertical_profile = getOptionalString_(kv, base + "refractive_index.unit");
			if(hasKey_(kv, base + "refractive_index.table.0.2") == false)
			{
				s.is_refractive_index_same_layering_atmosphere = true;
			}
			int n_tics = countArrayEntries_(kv, base + "refractive_index.table");
			for(int j = 0; j < n_tics; j ++)
			{
				if(s.is_refractive_index_same_layering_atmosphere)
				{
					double nr = getRequiredDouble_(kv, base + "refractive_index.table." + std::to_string(j) + ".0");
					double ni = getRequiredDouble_(kv, base + "refractive_index.table." + std::to_string(j) + ".1");
					
					s.refractive_index_vertical_profile.push_back({nr, ni});
				}
				else
				{
					double alt = getRequiredDouble_(kv, base + "refractive_index.table." + std::to_string(j) + ".0");
					double nr = getRequiredDouble_(kv, base + "refractive_index.table." + std::to_string(j) + ".1");
					double ni = getRequiredDouble_(kv, base + "refractive_index.table." + std::to_string(j) + ".2");
					
					s.refractive_index_vertical_profile.push_back({alt, nr, ni});
				}
			}

			// spectral_vertical用
			s.filename_refractive_index_spectral_vertical = getOptionalString_(kv, base + "refractive_index.file");
			s.varname_refractive_index_spectral_vertical_altitude = getOptionalString_(kv, base + "refractive_index.file.varname.0");
			s.varname_refractive_index_spectral_vertical_spectral = getOptionalString_(kv, base + "refractive_index.file.varname.1");
			s.varname_refractive_index_spectral_vertical_nr = getOptionalString_(kv, base + "refractive_index.file.varname.2");
			s.varname_refractive_index_spectral_vertical_ni = getOptionalString_(kv, base + "refractive_index.file.varname.3");

			atmosphere.species_configuration.push_back(s);
		}
	}

	return atmosphere;
}

// 要修正：netcdf対応
inline Configuration::Instrument ConfigurationLoader::loadInstrument_(const std::map<std::string, std::string>& kv)
{
	Configuration::Instrument instrument;

	// spectral_coordinate:
    //   dimension: wavenumber
    //   type: Spectrum
    //   min: 7.67
    //   max: 7.71
    //   increment: 100
    //   count: 1001
    //   unit: cm-1
	// bandpass_filter:
	//   type: gauss, rectangle, external
	//   file: filename
	//   sigma:
	//   width:
	//   center:
	//   cutoff_sigma:
	//   n_sample:
	//   file:
	//     filename: 
	//     varname: [wavenumber, transmittance]
	// convolution_kernel:
	//   type: gauss, rectangle
	//   sigma: 0.1
	//   width: 0.1
	//   cutoff_sigma: 4.0
	//   n_sample: 5
	//   

	std::string prefix = "simulation.bandpass_filter.";

	instrument.convolution_kernel_type = parseEnum_(getOptionalString_(kv, prefix + "type"), map_instrument_function_type);
	instrument.kernel_sigma = getOptionalDouble_(kv, prefix + "sigma");
	instrument.kernel_width = getOptionalDouble_(kv, prefix + "width");
	instrument.over_sampling_count = getOptionalInt_(kv, prefix + "n_sample");
	instrument.kernel_cut_off_sigma = getOptionalDouble_(kv, prefix + "cutoff_sigma");

	prefix = "simulation.convolution_kernel";

	instrument.filter_function_type = parseEnum_(getOptionalString_(kv, prefix + "type"), map_instrument_function_type);
	instrument.filter_sigma = getOptionalDouble_(kv, prefix + "sigma");
	instrument.filter_width = getOptionalDouble_(kv, prefix + "width");
	instrument.filter_center = getOptionalDouble_(kv, prefix + "center");
	instrument.sampling_count = getOptionalInt_(kv, prefix + "n_sample");
	instrument.filter_cut_off_sigma = getOptionalDouble_(kv, prefix + "cutoff_sigma");
	instrument.filename_filter_function = getOptionalString_(kv, prefix + "file.filename");
	instrument.varname_spectral = getOptionalString_(kv, prefix + "file.varname.0");
	instrument.varname_transmittance = getOptionalString_(kv, prefix + "file.varname.1");

	return instrument;
}

inline std::string ConfigurationLoader::getRequiredString_(const std::map<std::string, std::string>& kv, const std::string& key)
{
	auto it = kv.find(key);

	if (it == kv.end())
	{
		throw std::runtime_error("Missing key: " + key);
	}

	return it -> second;
}

inline int ConfigurationLoader::getRequiredInt_(const std::map<std::string, std::string>& kv, const std::string& key)
{
	auto it = kv.find(key);

	if (it == kv.end())
	{
		throw std::runtime_error("Missing key: " + key);
	}

	return std::stoi(it -> second);
}

inline double ConfigurationLoader::getRequiredDouble_(const std::map<std::string, std::string>& kv, const std::string& key)
{
	auto it = kv.find(key);

	if (it == kv.end())
	{
		throw std::runtime_error("Missing key: " + key);
	}

	return std::stod(it -> second);
}

inline bool ConfigurationLoader::getRequiredBool_(const std::map<std::string, std::string>& kv, const std::string& key)
{
	auto it = kv.find(key);

	if (it == kv.end())
	{
		throw std::runtime_error("Missing key: " + key);
	}

	std::string s = toLower(it->second);

	if (s == "true"  || s == "yes" || s == "on")  return true;
	if (s == "false" || s == "no"  || s == "off") return false;

	// ここまで来たら値は存在するが真偽値として解釈不能
	throw std::runtime_error("Invalid boolean value for key '" + key + "': '" + it->second + "'");
}


inline std::string ConfigurationLoader::getOptionalString_(const std::map<std::string, std::string>& kv, const std::string& key, const std::string& def)
{
	auto it = kv.find(key);

	return (it == kv.end() ? def : it->second);
}

inline int ConfigurationLoader::getOptionalInt_(const std::map<std::string, std::string>& kv, const std::string& key, int def)
{
	auto it = kv.find(key);

	return (it == kv.end() ? def : std::stoi(it->second));
}

inline double ConfigurationLoader::getOptionalDouble_(const std::map<std::string, std::string>& kv, const std::string& key, double def)
{
	auto it = kv.find(key);

	return (it == kv.end() ? def : std::stod(it->second));
}

inline bool ConfigurationLoader::getOptionalBool_(const std::map<std::string, std::string>& kv, const std::string& key, bool def)
{
	auto it = kv.find(key);

	if (it == kv.end())
	{
		return def;
	}

	std::string s = toLower(it->second);

	if (s == "true"  || s == "yes" || s == "on")  return true;
	if (s == "false" || s == "no"  || s == "off") return false;

	// ここまで来たら値は存在するが真偽値として解釈不能
	throw std::runtime_error("Invalid boolean value for key '" + key + "': '" + it->second + "'");
}


inline std::optional<std::string> ConfigurationLoader::getOptionalString_(const std::map<std::string, std::string>& kv, const std::string& key)
{
	std::optional<std::string> result;

	auto it = kv.find(key);

	if(it == kv.end())
	{
		result.reset();
	}
	else
	{
		result = it->second;
	}

	return result;
}

inline std::optional<int> ConfigurationLoader::getOptionalInt_(const std::map<std::string, std::string>& kv, const std::string& key)
{
	std::optional<int> result;

	auto it = kv.find(key);

	if(it == kv.end())
	{
		result.reset();
	}
	else
	{
		result = std::stoi(it->second);
	}

	return result;
}

inline std::optional<double> ConfigurationLoader::getOptionalDouble_(const std::map<std::string, std::string>& kv, const std::string& key)
{
	std::optional<double> result;

	auto it = kv.find(key);

	if(it == kv.end())
	{
		result.reset();
	}
	else
	{
		result = std::stod(it->second);
	}

	return result;
}

inline std::optional<bool> ConfigurationLoader::getOptionalBool_(const std::map<std::string, std::string>& kv, const std::string& key)
{
	std::optional<bool> result;

	auto it = kv.find(key);

	if(it == kv.end())
	{
		result.reset();
	}
	else
	{
		std::string s = toLower(it->second);

		if (s == "true"  || s == "yes" || s == "on")
		{
			result = true;
		}
		else if (s == "false" || s == "no"  || s == "off")
		{
			result = false;
		}
		else
		{
			throw std::runtime_error("Invalid boolean value for key '" + key + "': '" + it->second + "'");
		}
	}

	return result;
}


inline bool ConfigurationLoader::hasKey_(const std::map<std::string, std::string>& kv, const std::string& key)
{
    return kv.contains(key); // C++20
    // return kv.find(key) != kv.end(); // C++17でもOK
}

inline int ConfigurationLoader::countArrayEntries_(const std::map<std::string, std::string>& kv, const std::string& prefix)
{
	const std::string pfx = prefix + ".";
	std::vector<char> seen;  // seen[i] が 1 なら index=i が存在

	for (auto& [key,val] : kv)
	{
		// "prefix." で始まらないものはスキップ
		if (key.rfind(pfx, 0) != 0) continue;

		// pfx の直後から、次の '.' まで or 末尾までを番号文字列として抜き出す
		size_t pos1 = pfx.size();
		size_t pos2 = key.find('.', pos1);
		std::string idxstr = (pos2 == std::string::npos) ? key.substr(pos1) : key.substr(pos1, pos2 - pos1);
		if (idxstr.empty())
		{
			continue;
		}

		// 純粋に数字だけかチェック
		bool ok = true;
		for (char c : idxstr)
		{
			if (!std::isdigit(static_cast<unsigned char>(c)))
			{
				ok = false;
				break;
			}
		}

		if (!ok)
		{
			continue;
		}

		int idx = std::stoi(idxstr);
		if (idx < 0)
		{
			continue;
		}

		// seen を必要な長さまで拡張してマーク
		if ((size_t)idx >= seen.size())
		{
			seen.resize(idx + 1, 0);
		}

		seen[idx] = 1;
	}

	// true (1) になっているものを数える
	return std::count(seen.begin(), seen.end(), 1);
}

template<typename EnumT> inline std::optional<EnumT> ConfigurationLoader::parseEnum_(const std::optional<std::string>& s, const std::map<std::string, EnumT>& mapping)
{
	if (!s.has_value())
	{
		return std::nullopt;
	}

	// 2. 値を取り出して大文字に
	std::string s_u = toUpper(s.value());

	// 3. マップから探す
	auto it = mapping.find(s_u);
	if (it != mapping.end())
	{
		// 4. 見つかったらEnum値を返す
		return it->second;
	}

	// 5. 見つからなければ例外を投げる
	throw std::runtime_error("Unknown TypeName: " + s.value());
}

inline void Configuration::validateConfiguration(void)
{
	// Simulation
	if(!simulation.simulation_name.has_value())
	{
		simulation.simulation_name = "untitiled";
		std::cout << "[Configuration::validateConfiguration] Simulation name was not specified. Automatically set to 'untitled'." << std::endl;
	}
	if(!simulation.directory_name.has_value())
	{
		simulation.directory_name = "./";
		if(simulation.directory_name.value()[simulation.directory_name.value().size() - 1] != '/')
		{
			simulation.directory_name = simulation.directory_name.value() + "/";
		}
		std::cout << "[Configuration::validateConfiguration] Working directroy was not specified. Automatically set to current directory." << std::endl;
	}
	if(!simulation.logfile_name.has_value())
	{
		simulation.logfile_name = "log.txt";
		std::cout << "[Configuration::validateConfiguration] Log file name was not specified. Automatically set to 'log.txt'." << std::endl;
	}
	if(!simulation.result_name.has_value())
	{
		simulation.result_name = simulation.simulation_name.value() + ".nc";
		std::cout << "[Configuration::validateConfiguration] Result file name was not specified. Automatically set to '" << simulation.simulation_name.value() << ".nc'." << std::endl;
	}
	if(!simulation.n_parallel.has_value())
	{
		simulation.n_parallel = 1;
		std::cout << "[Configuration::validateConfiguration] n_parallel was not specified. Automatically set to 1." << std::endl;
	}
	if(!simulation.n_scattering_angle.has_value())
	{
		simulation.n_scattering_angle = 1001;
		std::cout << "[Configuration::validateConfiguration] n_scattering_angle was not specified. Automatically set to 1001." << std::endl;
	}
	if(!simulation.tau_initial_layer.has_value())
	{
		simulation.tau_initial_layer = 1.0E-8;
		std::cout << "[Configuration::validateConfiguration] tau_initial_layer was not specified. Automatically set to 1.0E-8." << std::endl;
	}
	if(!simulation.enable_atmospheric_emission.has_value())
	{
		simulation.enable_atmospheric_emission = false;
		std::cout << "[Configuration::validateConfiguration] enable_atmospheric_emission was not specified. Automatically set to false." << std::endl;
	}

	//Geometry
	if(!geometry.grid_type.has_value())
	{
		geometry.grid_type = GridType::GaussRadau;
		std::cout << "[Configuration::validateConfiguration] grid_type was not specified. Automatically set to Gauss-Radau." << std::endl;
	}
	if(!geometry.n_theta.has_value())
	{
		throw std::runtime_error("[Configuration::validateConfiguration] n_theta was not specified.");
	}
	if(!geometry.n_phi.has_value() && !geometry.n_mode.has_value())
	{
		std::cout << "[Configuration::validateConfiguration] n_phi and n_mode were not specified. Automatically set." << std::endl;
	}

	//DeltaM
	if(!delta_m.delta_approximation_type.has_value())
	{
		delta_m.delta_approximation_type = DeltaApproximationType::Disable;
		std::cout << "[Configuration::validateConfiguration] delta_approximation_type was not specified. Automatically set to disable." << std::endl;
	}
	else 
	{
		// to be fixed
		if(!delta_m.n_icss_sample.has_value())
		{
			delta_m.n_icss_sample = 3;
			std::cout << "[Configuration::validateConfiguration] n_icss_sample was not specified. Automatically set to 3." << std::endl;
		}
	}

	// SpectralCoordinate
	// 有効な組み合わせ
	// monochrome
	// spectrum
	// table (あまり使わないほうが良い)
	// bandpass + instrument (bandpass filter)
	// spectrum + instrument
	if(!spectral_coordinate.spectral_coordinate_dimension.has_value() && !spectral_coordinate.unit.has_value())
	{
		throw std::runtime_error("[Configuration::validateConfiguration] Spectral dimension not automatically determined. Specify at least dimension or unit.");
	}
	else if(!spectral_coordinate.spectral_coordinate_dimension.has_value() && spectral_coordinate.unit.has_value())
	{
		if(getUnitInfo(spectral_coordinate.unit.value()).dim == UnitDim::Length)
		{
			spectral_coordinate.spectral_coordinate_dimension = SpectralCoordinateDimension::Wavelength;
			std::cout << "[Configuration::validateConfiguration] Spectral dimension was not specified. Automatically set to wavelength." << std::endl;
		}
		else if(getUnitInfo(spectral_coordinate.unit.value()).dim == UnitDim::Wavenumber)
		{
			spectral_coordinate.spectral_coordinate_dimension = SpectralCoordinateDimension::Wavenumber;
			std::cout << "[Configuration::validateConfiguration] Spectral dimension was not specified. Automatically set to wavenumber." << std::endl;
		}
	}
	else if(spectral_coordinate.spectral_coordinate_dimension.has_value() && !spectral_coordinate.unit.has_value())
	{
		if(spectral_coordinate.spectral_coordinate_dimension == SpectralCoordinateDimension::Wavenumber)
		{
			spectral_coordinate.unit = "m-1";
			std::cout << "[Configuration::validateConfiguration] Spectral unit was not specified. Automatically set to m-1." << std::endl;
		}
		if(spectral_coordinate.spectral_coordinate_dimension == SpectralCoordinateDimension::Wavelength)
		{
			spectral_coordinate.unit = "m";
			std::cout << "[Configuration::validateConfiguration] Spectral unit was not specified. Automatically set to m." << std::endl;
		}
	}
	if(!spectral_coordinate.spectral_coordinate_type.has_value())
	{
		throw std::runtime_error("[Configuration::validateConfiguration] Spectral coordinate type was not specified.");
	}
	else if(spectral_coordinate.spectral_coordinate_type.value() == SpectralCoordinateType::Monochrome)
	{
		if(!spectral_coordinate.mono.has_value())
		{
			throw std::runtime_error("[Configuration::validateConfiguration] Wavenumber or wavelength were not specified for monochrome calculation.");
		}
	}
	else if(spectral_coordinate.spectral_coordinate_type.value() == SpectralCoordinateType::Spectrum)
	{
		if(!spectral_coordinate.min.has_value() || !spectral_coordinate.max.has_value())
		{
			throw std::runtime_error("[Configuration::validateConfiguration] Spectral range was not specified.");
		}

		if(spectral_coordinate.min.value() >= spectral_coordinate.max.value())
		{
			throw std::runtime_error("[Configuration::validateConfiguration] Spectral range error (min >= max).");
		}
		
		if(!instrument.convolution_kernel_type.has_value() || instrument.convolution_kernel_type == InstrumentFunctionType::Delta)
		{
			instrument.convolution_kernel_type = InstrumentFunctionType::Delta;

			if(!spectral_coordinate.n_spectral.has_value() && !spectral_coordinate.increment.has_value())
			{
				throw std::runtime_error("[Configuration::validateConfiguration] Spectral increment was not specified.");
			}
			else if(spectral_coordinate.n_spectral.has_value() && spectral_coordinate.increment.has_value())
			{
				throw std::runtime_error("[Configuration::validateConfiguration] Spectral increment was over specified.");
			}
			else
			{
				if(!spectral_coordinate.n_spectral.has_value())
				{
					if(spectral_coordinate.max.value() - spectral_coordinate.min.value() < spectral_coordinate.increment.value())
					{
						throw std::runtime_error("[Configuration::validateConfiguration] Spectral range error (width < increment).");
					}
				}
				else if(!spectral_coordinate.increment.has_value())
				{
					if(spectral_coordinate.n_spectral < 2)
					{
						spectral_coordinate.n_spectral = 2;
						std::cout << "[Configuration::validateConfiguration] n_spectral is too few. Automatically set to 2 (min and max)." << std::endl;
					}
				}
			}
		}
		else
		{
			if(!instrument.over_sampling_count.has_value())
			{
				instrument.over_sampling_count = 3;
				std::cout << "[Configuration::validateConfiguration] over_sampling_count was not specified. Automatically set to " << instrument.over_sampling_count.value() << "." << std::endl;
			}

			if(instrument.convolution_kernel_type.value() == InstrumentFunctionType::Gauss)
			{
				if(!instrument.kernel_sigma.has_value())
				{
					throw std::runtime_error("[Configuration::validateConfiguration] Gaussian sigma was not specified for convolution kernel.");
				}
				if(instrument.kernel_width.has_value())
				{
					instrument.kernel_width.reset();
					std::cout << "[Configuration::validateConfiguration] Rectangular width was ignored for gaussian spectrum convolution kernel." << std::endl;
				}
			}
			else if(instrument.convolution_kernel_type.value() == InstrumentFunctionType::Rectangle)
			{
				if(!instrument.kernel_width.has_value())
				{
					throw std::runtime_error("[Configuration::validateConfiguration] Rectangular width was not specified for convolution kernel.");
				}
				if(instrument.kernel_sigma.has_value())
				{
					instrument.kernel_width.reset();
					std::cout << "[Configuration::validateConfiguration] Gaussian sigma was ignored for rectangular spectrum convolution kernel." << std::endl;
				}
			}
			else if(instrument.convolution_kernel_type.value() == InstrumentFunctionType::External)
			{
				throw std::runtime_error("[Configuration::validateConfiguration] External was not currently supported for spectrum convolution kernel.");
			} 
		}
	}
	else if(spectral_coordinate.spectral_coordinate_type.value() == SpectralCoordinateType::Bandpass)
	{
		if(!instrument.filter_function_type.has_value())
		{
			throw std::runtime_error("[Configuration::validateConfiguration] Bandpass filter was not specified for bandpass calculation.");
		}
		else 
		{
			if(instrument.filter_function_type.value() == InstrumentFunctionType::Delta)
			{
				if(!instrument.filter_center.has_value())
				{
					throw std::runtime_error("[Configuration::validateConfiguration] Delta center was not specified for filter function.");
				}
			}
			else if(instrument.filter_function_type.value() == InstrumentFunctionType::Gauss)
			{
				if(!instrument.filter_sigma.has_value())
				{
					throw std::runtime_error("[Configuration::validateConfiguration] Gaussian sigma was not specified for filter function.");
				}
				if(!instrument.filter_center.has_value())
				{
					throw std::runtime_error("[Configuration::validateConfiguration] Gaussian center was not specified for filter function.");
				}
			}
			else if(instrument.filter_function_type.value() == InstrumentFunctionType::Rectangle)
			{
				if(!instrument.filter_width.has_value())
				{
					throw std::runtime_error("[Configuration::validateConfiguration] Rectangular width was not specified for filter function.");
				}
				if(!instrument.filter_center.has_value())
				{
					throw std::runtime_error("[Configuration::validateConfiguration] Rectangular center was not specified for filter function.");
				}
			}
			else if(instrument.filter_function_type.value() == InstrumentFunctionType::External)
			{
				if(!instrument.filename_filter_function.has_value())
				{
					throw std::runtime_error("[Configuration::validateConfiguration] Filename of filter function was not specified.");
				}
				else if(!instrument.varname_spectral.has_value() || !instrument.varname_transmittance.has_value())
				{
					throw std::runtime_error("[Configuration::validateConfiguration] Variable name of filter function file was not specified.");
				}
			}
		}
	}

	// Surface
	if(!surface.type.has_value())
	{
		surface.type = SurfaceType::NoSurface;
		std::cout << "[Configuration::validateConfiguration] surface_type was not specified. Automatically set to no_surface." << std::endl;
	}
	else if(surface.type.value() == SurfaceType::Lambert)
	{
		if(!surface.albedo.has_value())
		{
			throw std::runtime_error("[Configuration::validateConfiguration] surface_albedo was not specified.");
		}
		if(!surface.temperature.has_value())
		{
			throw std::runtime_error("[Configuration::validateConfiguration] surface_temperature was not specified.");
		}
		if(!surface.unit.has_value())
		{
			surface.unit = "K";
			std::cout << "[Configuration::validateConfiguration] surface_temperature unit was not specified. Automatically set to K." << std::endl;
		}
	}

	// Atmosphere-layering
	if(atmosphere.z_center.empty() && atmosphere.z_edge.empty())
	{
		throw std::runtime_error("[Configuration::validateConfiguration] Layering was not specified.");
	}
	else if(!atmosphere.z_center.empty() && !atmosphere.z_edge.empty())
	{
		throw std::runtime_error("[Configuration::validateConfiguration] Layering was overspecified.");
	}
	if(!atmosphere.z_unit.has_value())
	{
		atmosphere.z_unit = "m";
		std::cout << "[Configuration::validateConfiguration] z_unit was not specified. Automatically set to m." << std::endl;
	}
	// Atmosphere-temperature
	if(!atmosphere.vertical_temperature_profile.has_value())
	{
		throw std::runtime_error("[Configuration::validateConfiguration] Temperature profile was not specified.");
	}
	else if(atmosphere.vertical_temperature_profile.value() == VerticalTemperatureProfile::Table)
	{
		if(atmosphere.temperature_profile.empty())
		{
			throw std::runtime_error("[Configuration::validateConfiguration] Temperature profile was not specified.");
		}
				
		if(atmosphere.is_same_temperature_layering_atmosphere == true)
		{
			if(atmosphere.temperature_unit.size() == 0)
			{
				atmosphere.temperature_unit = {atmosphere.z_unit.value(), "K"};
				std::cout << "[Configuration::validateConfiguration] Temperature unit was not specified. Automatically set to K." << std::endl;
			}
			else if(atmosphere.temperature_unit.size() == 1)
			{
				if(getUnitInfo(atmosphere.temperature_unit[0].value()).dim != UnitDim::Temperature)
				{
					throw std::runtime_error("[Configuration::validateConfiguration] Invalid temperature unit dimension.");
				}
			}
			else
			{
				throw std::runtime_error("[Configuration::validateConfiguration] Temperature profile unit was overspecified.");
			}
			if(!atmosphere.z_center.empty())
			{
				if(atmosphere.z_center.size() != atmosphere.temperature_profile.size())
				{
					throw std::runtime_error("[Configuration::validateConfiguration] Temperature layering does not match to atmosphere.");
				}
			}
			else if(!atmosphere.z_edge.empty())
			{
				if(atmosphere.z_edge.size() - 1 != atmosphere.temperature_profile.size())
				{
					throw std::runtime_error("[Configuration::validateConfiguration] Temperature layering does not match to atmosphere.");
				}
			}
		}
		else
		{
			if(!atmosphere.vertical_temperature_interpolation.has_value())
			{
				atmosphere.vertical_temperature_interpolation = VerticalProfileInterpolation::Linear;
				std::cout << "[Configuration::validateConfiguration] Temperature interpolation was not specified. Automatically set to linear." << std::endl;
			}
			if(atmosphere.temperature_unit.size() == 0)
			{
				atmosphere.temperature_unit = {atmosphere.z_unit.value(), "K"};
				std::cout << "[Configuration::validateConfiguration] (z, temperature) unit was not specified. Automatically set to (" << atmosphere.z_unit.value() << ", K)." << std::endl;
			}
			else if(atmosphere.temperature_unit.size() == 1)
			{
				if(getUnitInfo(atmosphere.temperature_unit[0].value()).dim == UnitDim::Length)
				{
					atmosphere.temperature_unit.push_back(std::optional<std::string>("K"));
					std::cout << "[Configuration::validateConfiguration] Temperature unit was not specified. Automatically set to K." << std::endl;
				}
				else if(getUnitInfo(atmosphere.temperature_unit[0].value()).dim == UnitDim::Temperature)
				{
					atmosphere.temperature_unit.insert(atmosphere.temperature_unit.begin(), atmosphere.z_unit);
					std::cout << "[Configuration::validateConfiguration] z_unit for temperature was not specified. Automatically set to m." << std::endl;
				}
			}
		}
	}
	else if(atmosphere.vertical_temperature_profile.value() == VerticalTemperatureProfile::VIRA_EQUATOR || atmosphere.vertical_temperature_profile.value() == VerticalTemperatureProfile::VIRA_45 || atmosphere.vertical_temperature_profile.value() == VerticalTemperatureProfile::VIRA_60)
	{
		atmosphere.temperature_unit = {"km", "K"};
		std::cout << "[Configuration::validateConfiguration] (z, temperature) unit automatically set (km, K) for VIRA." << std::endl;

		if(!atmosphere.vertical_temperature_interpolation.has_value())
		{
			atmosphere.vertical_temperature_interpolation = VerticalProfileInterpolation::Linear;
			std::cout << "[Configuration::validateConfiguration] Temperature interpolation was not specified. Automatically set to linear." << std::endl;
		}
	}
	else if(atmosphere.vertical_temperature_profile.value() == VerticalTemperatureProfile::External)
	{
		throw std::runtime_error("[Configuration::validateConfiguration] Temperature profile 'External' is not supported currently.");
	}
	// Atmosphere-pressure
	if(!atmosphere.vertical_pressure_profile.has_value())
	{
		throw std::runtime_error("[Configuration::validateConfiguration] Pressure profile was not specified.");
	}
	else if(atmosphere.vertical_pressure_profile.value() == VerticalPressureProfile::Table)
	{
		if(atmosphere.pressure_profile.empty())
		{
			throw std::runtime_error("[Configuration::validateConfiguration] Pressure profile was not specified.");
		}

		if(atmosphere.is_same_pressure_layering_atmosphere == true)
		{
			if(atmosphere.pressure_unit.size() == 0)
			{
				atmosphere.pressure_unit = {atmosphere.z_unit.value(), "Pa"};
				std::cout << "[Configuration::validateConfiguration] Pressure unit was not specified. Automatically set to Pa." << std::endl;
			}
			else if(atmosphere.pressure_unit.size() == 1)
			{
				if(getUnitInfo(atmosphere.pressure_unit[0].value()).dim != UnitDim::Pressure)
				{
					throw std::runtime_error("[Configuration::validateConfiguration] Invalid pressure unit dimension.");
				}
			}
			else
			{
				throw std::runtime_error("[Configuration::validateConfiguration] Pressure profile unit was overspecified.");
			}
			if(!atmosphere.z_center.empty())
			{
				if(atmosphere.z_center.size() != atmosphere.pressure_profile.size())
				{
					throw std::runtime_error("[Configuration::validateConfiguration] Pressure layering does not match to atmosphere.");
				}
			}
			else if(!atmosphere.z_edge.empty())
			{
				if(atmosphere.z_edge.size() - 1 != atmosphere.pressure_profile.size())
				{
					throw std::runtime_error("[Configuration::validateConfiguration] Pressure layering does not match to atmosphere.");
				}
			}
		}
		else
		{
			if(!atmosphere.vertical_pressure_interpolation.has_value())
			{
				atmosphere.vertical_pressure_interpolation = VerticalProfileInterpolation::Exponential;
				std::cout << "[Configuration::validateConfiguration] Pressure interpolation was not specified. Automatically set to exponential." << std::endl;
			}
			
			if(atmosphere.pressure_unit.size() == 0)
			{
				atmosphere.pressure_unit = {atmosphere.z_unit.value(), "Pa"};
				std::cout << "[Configuration::validateConfiguration] (z, pressure) unit was not specified. Automatically set to (" << atmosphere.z_unit.value() << ", Pa)." << std::endl;
			}
			else if(atmosphere.pressure_unit.size() == 1)
			{
				if(getUnitInfo(atmosphere.pressure_unit[0].value()).dim == UnitDim::Length)
				{
					atmosphere.pressure_unit.push_back(std::optional<std::string>("Pa"));
					std::cout << "[Configuration::validateConfiguration] Pressure unit was not specified. Automatically set to Pa." << std::endl;
				}
				else if(getUnitInfo(atmosphere.pressure_unit[0].value()).dim == UnitDim::Pressure)
				{
					atmosphere.pressure_unit.insert(atmosphere.pressure_unit.begin(), atmosphere.z_unit);
					std::cout << "[Configuration::validateConfiguration] z_unit for pressure was not specified. Automatically set to m." << std::endl;
				}
			}
		}
	}
	else if(atmosphere.vertical_pressure_profile.value() == VerticalPressureProfile::VIRA_EQUATOR || atmosphere.vertical_pressure_profile.value() == VerticalPressureProfile::VIRA_45 || atmosphere.vertical_pressure_profile.value() == VerticalPressureProfile::VIRA_60)
	{
		atmosphere.pressure_unit = {"km", "bar"};
		std::cout << "[Configuration::validateConfiguration] (z, pressure) unit automatically set (km, bar) for VIRA." << std::endl;

		if(!atmosphere.vertical_pressure_interpolation.has_value())
		{
			atmosphere.vertical_pressure_interpolation = VerticalProfileInterpolation::Exponential;
			std::cout << "[Configuration::validateConfiguration] Pressure interpolation was not specified. Automatically set to exponential." << std::endl;
		}
	}
	else if(atmosphere.vertical_pressure_profile.value() == VerticalPressureProfile::Hydrostatic)
	{
		throw std::runtime_error("[Configuration::validateConfiguration] Pressure profile 'Hydrostatic' is not supported currently.");
	}
	else if(atmosphere.vertical_pressure_profile.value() == VerticalPressureProfile::External)
	{
		throw std::runtime_error("[Configuration::validateConfiguration] Pressure profile 'External' is not supported currently.");
	}
	// Atmosphere-number_density
	if(!atmosphere.vertical_number_density_profile.has_value())
	{
		throw std::runtime_error("[Configuration::validateConfiguration] Number density profile was not specified.");
	}
	else if(atmosphere.vertical_number_density_profile.value() == VerticalNumberDensityProfile::Table)
	{
		if(atmosphere.number_density_profile.empty())
		{
			throw std::runtime_error("[Configuration::validateConfiguration] Number density profile was not specified.");
		}

		if(atmosphere.is_same_number_density_layering_atmosphere == true)
		{
			if(atmosphere.number_density_unit.size() == 0)
			{
				atmosphere.number_density_unit = {atmosphere.z_unit.value(), "m-3"};
				std::cout << "[Configuration::validateConfiguration] NumberDensity unit was not specified. Automatically set to m-3." << std::endl;
			}
			else if(atmosphere.number_density_unit.size() == 1)
			{
				if(getUnitInfo(atmosphere.number_density_unit[0].value()).dim != UnitDim::NumberDensity && getUnitInfo(atmosphere.number_density_unit[0].value()).dim != UnitDim::ColumnNumberDensity)
				{
					throw std::runtime_error("[Configuration::validateConfiguration] Invalid number_density unit dimension.");
				}
			}
			else
			{
				throw std::runtime_error("[Configuration::validateConfiguration] NumberDensity profile unit was overspecified.");
			}
			if(!atmosphere.z_center.empty())
			{
				if(atmosphere.z_center.size() != atmosphere.number_density_profile.size())
				{
					throw std::runtime_error("[Configuration::validateConfiguration] NumberDensity layering does not match to atmosphere.");
				}
			}
			else if(!atmosphere.z_edge.empty())
			{
				if(atmosphere.z_edge.size() - 1 != atmosphere.number_density_profile.size())
				{
					throw std::runtime_error("[Configuration::validateConfiguration] NumberDensity layering does not match to atmosphere.");
				}
			}
		}
		else
		{
			if(!atmosphere.vertical_number_density_interpolation.has_value())
			{
				atmosphere.vertical_number_density_interpolation = VerticalProfileInterpolation::Exponential;
				std::cout << "[Configuration::validateConfiguration] Number density interpolation was not specified. Automatically set to exponential." << std::endl;
			}
			
			if(atmosphere.number_density_unit.size() == 0)
			{
				atmosphere.number_density_unit = {atmosphere.z_unit.value(), "m-3"};
				std::cout << "[Configuration::validateConfiguration] (z, number_density) unit was not specified. Automatically set to (" << atmosphere.z_unit.value() << ", m-3)." << std::endl;
			}
			else if(atmosphere.number_density_unit.size() == 1)
			{
				if(getUnitInfo(atmosphere.number_density_unit[0].value()).dim == UnitDim::Length)
				{
					atmosphere.number_density_unit.push_back(std::optional<std::string>("m-3"));
					std::cout << "[Configuration::validateConfiguration] Number density unit was not specified. Automatically set to m-3." << std::endl;
				}
				else if(getUnitInfo(atmosphere.number_density_unit[0].value()).dim == UnitDim::NumberDensity)
				{
					atmosphere.number_density_unit.insert(atmosphere.number_density_unit.begin(), atmosphere.z_unit);
					std::cout << "[Configuration::validateConfiguration] z_unit for number_density was not specified. Automatically set to m." << std::endl;
				}
			}
		}
	}
	else if(atmosphere.vertical_number_density_profile.value() == VerticalNumberDensityProfile::VIRA_EQUATOR || atmosphere.vertical_number_density_profile.value() == VerticalNumberDensityProfile::VIRA_45 || atmosphere.vertical_number_density_profile.value() == VerticalNumberDensityProfile::VIRA_60)
	{
		atmosphere.number_density_unit = {"km", "m-3"};
		std::cout << "[Configuration::validateConfiguration] (z, number_density) unit automatically set (km, m-3) for VIRA." << std::endl;

		if(!atmosphere.vertical_number_density_interpolation.has_value())
		{
			atmosphere.vertical_number_density_interpolation = VerticalProfileInterpolation::Exponential;
			std::cout << "[Configuration::validateConfiguration] Number density interpolation was not specified. Automatically set to exponential." << std::endl;
		}
	}
	else if(atmosphere.vertical_number_density_profile.value() == VerticalNumberDensityProfile::External)
	{
		throw std::runtime_error("[Configuration::validateConfiguration] Number density profile 'External' is not supported currently.");
	}

	//species
	bool is_hitran = false;

	for(int i = 0; i < atmosphere.species_configuration.size(); ++i)
	{
		if(!atmosphere.species_configuration[i].name.has_value())
		{
			atmosphere.species_configuration[i].name = "species_" + std::to_string(i);
			std::cout << "[Configuration::validateConfiguration] Name of species " << i << " was not specified. Automatically set to " << atmosphere.species_configuration[i].name.value() << "." << std::endl;
		}

		if(atmosphere.species_configuration[i].vertical_profile.empty())
		{
			throw std::runtime_error("[Configuration::validateConfiguration] Vertical profile for species "+ std::to_string(i) + " was not specified.");
		}
		
		if(atmosphere.species_configuration[i].is_same_layering_atmosphere == true)
		{
			if(atmosphere.species_configuration[i].unit_vertical_profile.size() == 0)
			{
				atmosphere.species_configuration[i].unit_vertical_profile = {atmosphere.z_unit.value(), "m-3"};
				std::cout << "[Configuration::validateConfiguration] Vertical profile unit was not specified for species " << i << ". Automatically set to m-3." << std::endl;
			}
			else if(atmosphere.species_configuration[i].unit_vertical_profile.size() == 1)
			{
				atmosphere.species_configuration[i].unit_vertical_profile.insert(atmosphere.species_configuration[i].unit_vertical_profile.begin(), atmosphere.z_unit);
				
				if(getUnitInfo(atmosphere.species_configuration[i].unit_vertical_profile[0].value()).dim != UnitDim::Dimensionless && getUnitInfo(atmosphere.species_configuration[i].unit_vertical_profile[0].value()).dim != UnitDim::NumberDensity && getUnitInfo(atmosphere.species_configuration[i].unit_vertical_profile[0].value()).dim != UnitDim::ColumnNumberDensity)
				{
					throw std::runtime_error("[Configuration::validateConfiguration] Invalid vertical profile unit dimension for species " + std::to_string(i) + ".");
				}
			}
			else
			{
				throw std::runtime_error("[Configuration::validateConfiguration] Vertical profile unit for species " + std::to_string(i) + " was overspecified.");
			}
			if(!atmosphere.z_center.empty())
			{
				if(atmosphere.z_center.size() != atmosphere.species_configuration[i].vertical_profile.size())
				{
					throw std::runtime_error("[Configuration::validateConfiguration] Vertical profile layering for species " + std::to_string(i) + " does not match to atmosphere.");
				}
			}
			else if(!atmosphere.z_edge.empty())
			{
				if(atmosphere.z_edge.size() - 1 != atmosphere.species_configuration[i].vertical_profile.size())
				{
					throw std::runtime_error("[Configuration::validateConfiguration] Vertical profile layering for species " + std::to_string(i) + " does not match to atmosphere.");
				}
			}
		}
		else
		{
			if(!atmosphere.species_configuration[i].vertical_profile_interpolation.has_value())
			{
				atmosphere.species_configuration[i].vertical_profile_interpolation = VerticalProfileInterpolation::Exponential;
				std::cout << "[Configuration::validateConfiguration] Vertical profile interpolation for species "+ std::to_string(i) + " was not specified. Automatically set to exponential." << std::endl;
			}
			
			if(atmosphere.species_configuration[i].unit_vertical_profile.size() == 0)
			{
				atmosphere.species_configuration[i].unit_vertical_profile = {atmosphere.z_unit.value(), "m-3"};
				std::cout << "[Configuration::validateConfiguration] (z, vertical_profile) unit for species " + std::to_string(i) + " was not specified. Automatically set to (" << atmosphere.z_unit.value() << ", m-3)." << std::endl;
			}
			else if(atmosphere.species_configuration[i].unit_vertical_profile.size() == 1)
			{
				if(getUnitInfo(atmosphere.species_configuration[i].unit_vertical_profile[0].value()).dim == UnitDim::Length)
				{
					atmosphere.species_configuration[i].unit_vertical_profile.push_back(std::optional<std::string>("m-3"));
					std::cout << "[Configuration::validateConfiguration] Vertical profile unit for species " + std::to_string(i) + " was not specified. Automatically set to m-3." << std::endl;
				}
				else if(getUnitInfo(atmosphere.species_configuration[i].unit_vertical_profile[0].value()).dim == UnitDim::Dimensionless || getUnitInfo(atmosphere.species_configuration[i].unit_vertical_profile[0].value()).dim == UnitDim::NumberDensity || getUnitInfo(atmosphere.species_configuration[i].unit_vertical_profile[0].value()).dim == UnitDim::ColumnNumberDensity)
				{
					atmosphere.species_configuration[i].unit_vertical_profile.insert(atmosphere.species_configuration[i].unit_vertical_profile.begin(), atmosphere.z_unit);
					std::cout << "[Configuration::validateConfiguration] z_unit for vertical profile for species " + std::to_string(i) + " was not specified. Automatically set to m." << std::endl;
				}
			}
		}
	
		if(!atmosphere.species_configuration[i].species_state.has_value())
		{
			throw std::runtime_error("[Configuration::validateConfiguration] species_state for species "+ std::to_string(i) + " was not specified.");
		}
		if(atmosphere.species_configuration[i].species_state.value() == SpeciesState::Molecule && !atmosphere.species_configuration[i].species_type.has_value())
		{
			throw std::runtime_error("[Configuration::validateConfiguration] species_type (scatterer, absorber or extinction) for species "+ std::to_string(i) + " was not specified.");
		}
		if(atmosphere.species_configuration[i].species_state.value() == SpeciesState::Aerosol && atmosphere.species_configuration[i].species_type.has_value())
		{
			throw std::runtime_error("[Configuration::validateConfiguration] species_type (scatterer, absorber or extinction) for aerosol species "+ std::to_string(i) + " was specified.");
		}
		// 物性の整合性検証
		if(atmosphere.species_configuration[i].species_state.value() == SpeciesState::Molecule)
		{
			if(atmosphere.species_configuration[i].scatter_type.value() == ScatterType::Mie)
			{
				throw std::runtime_error("[Configuration::validateConfiguration] Mie scattering is not supported for molecules for species "+ std::to_string(i) + ".");
			}

			if(atmosphere.species_configuration[i].species_type.value() == SpeciesType::Scatterer || atmosphere.species_configuration[i].species_type.value() == SpeciesType::Extinction)
			{
				if(!atmosphere.species_configuration[i].scatter_type.has_value())
				{
					throw std::runtime_error("[Configuration::validateConfiguration] scatter_type for species "+ std::to_string(i) + " was not specified.");
				}
				else if(atmosphere.species_configuration[i].scatter_type.value() != ScatterType::Mie)
				{
					if(!atmosphere.species_configuration[i].scattering_cross_section_type.has_value())
					{
						throw std::runtime_error("[Configuration::validateConfiguration] scattering_cross_section_type for species "+ std::to_string(i) + " was not specified.");
					}
					else if(atmosphere.species_configuration[i].scattering_cross_section_type == CrossSectionType::Constant)
					{
						if(!atmosphere.species_configuration[i].scattering_cross_section_unit.has_value())
						{
							atmosphere.species_configuration[i].scattering_cross_section_unit = "m2";
							std::cout << "[Configuration::validateConfiguration] scattering_cross_section_unit for species " + std::to_string(i) + " was not specified. Automatically set to m2." << std::endl;
						}
						if(!atmosphere.species_configuration[i].scattering_cross_section.has_value())
						{
							throw std::runtime_error("[Configuration::validateConfiguration] scattering_cross_section for species "+ std::to_string(i) + " was not specified.");
						}
					}
					else if(atmosphere.species_configuration[i].scattering_cross_section_type == CrossSectionType::External)
					{
						if(!atmosphere.species_configuration[i].varname_scattering_cross_section_spectral.has_value() || !atmosphere.species_configuration[i].varname_scattering_cross_section.has_value())
						{
							throw std::runtime_error("[Configuration::validateConfiguration] Variable name of scattering cross section file for species "+ std::to_string(i) + " was not specified.");
						}
						if(!atmosphere.species_configuration[i].filename_scattering_cross_section.has_value())
						{
							throw std::runtime_error("[Configuration::validateConfiguration] filename_scattering_cross_section for species "+ std::to_string(i) + " was not specified.");
						}
					}

					if(atmosphere.species_configuration[i].scatter_type.value() == ScatterType::HenyeyGreenstein)
					{
						if(!atmosphere.species_configuration[i].g_factor.has_value())
						{
							throw std::runtime_error("[Configuration::validateConfiguration] g_factor for species "+ std::to_string(i) + " was not specified.");
						}
					}
				}
			}

			if(atmosphere.species_configuration[i].species_type.value() == SpeciesType::Absorber || atmosphere.species_configuration[i].species_type.value() == SpeciesType::Extinction)
			{
				if(!atmosphere.species_configuration[i].absorption_cross_section_type.has_value())
				{
					throw std::runtime_error("[Configuration::validateConfiguration] absorption_cross_section_type for species "+ std::to_string(i) + " was not specified.");
				}
				else if(atmosphere.species_configuration[i].absorption_cross_section_type == CrossSectionType::Constant)
				{
					if(!atmosphere.species_configuration[i].absorption_cross_section_unit.has_value())
					{
						atmosphere.species_configuration[i].absorption_cross_section_unit = "m2";
						std::cout << "[Configuration::validateConfiguration] absorption_cross_section_unit for species " + std::to_string(i) + " was not specified. Automatically set to m2." << std::endl;
					}
					if(!atmosphere.species_configuration[i].absorption_cross_section.has_value())
					{
						throw std::runtime_error("[Configuration::validateConfiguration] absorption_cross_section for species "+ std::to_string(i) + " was not specified.");
					}
				}
				else if(atmosphere.species_configuration[i].absorption_cross_section_type == CrossSectionType::External)
				{
					if(!atmosphere.species_configuration[i].varname_absorption_cross_section_spectral.has_value() || !atmosphere.species_configuration[i].varname_absorption_cross_section.has_value())
						{
							throw std::runtime_error("[Configuration::validateConfiguration] Variable name of absorption cross section file for species "+ std::to_string(i) + " was not specified.");
						}
						if(!atmosphere.species_configuration[i].filename_absorption_cross_section.has_value())
						{
							throw std::runtime_error("[Configuration::validateConfiguration] filename_absorption_cross_section for species "+ std::to_string(i) + " was not specified.");
						}
					if(!atmosphere.species_configuration[i].filename_absorption_cross_section.has_value())
					{
						throw std::runtime_error("[Configuration::validateConfiguration] filename_absorption_cross_section for species "+ std::to_string(i) + " was not specified.");
					}
				}
				else if(atmosphere.species_configuration[i].absorption_cross_section_type == CrossSectionType::HITRAN)
				{
					is_hitran = true;

					if(!atmosphere.species_configuration[i].molecule_id.has_value())
					{
						throw std::runtime_error("[Configuration::validateConfiguration] molecule_id for species " + std::to_string(i) + " was not specified.");
					}

					if(!atmosphere.species_configuration[i].isotopologue_type.has_value())
					{
						throw std::runtime_error("[Configuration::validateConfiguration] isotopologue_type for species " + std::to_string(i) + " was not specified.");
					}
					else if(atmosphere.species_configuration[i].isotopologue_type.value() == IsotopologueType::Defined)
					{
						if(atmosphere.species_configuration[i].local_isotopologue_id.empty())
						{
							throw std::runtime_error("[Configuration::validateConfiguration] local_isotopologue_id for species " + std::to_string(i) + " was not specified.");
						}

						std::vector<int> check_ids = atmosphere.species_configuration[i].local_isotopologue_id;
						std::sort(check_ids.begin(), check_ids.end());
						
						auto it = std::adjacent_find(check_ids.begin(), check_ids.end());

						if(it != check_ids.end())
						{
							throw std::runtime_error("[Configuration::validateConfiguration] Duplicate local_isotopologue_id (" + std::to_string(*it) + ") found for species " + std::to_string(i) + ".");
						}
					}
					else if(atmosphere.species_configuration[i].isotopologue_type.value() == IsotopologueType::All)
					{
						if(!atmosphere.species_configuration[i].local_isotopologue_id.empty())
						{
							throw std::runtime_error("[Configuration::validateConfiguration] local_isotopologue_id for species " + std::to_string(i) + " was ignored.");
						}
					}

					if(!atmosphere.species_configuration[i].isotopologue_abundance_type.has_value())
					{
						throw std::runtime_error("[Configuration::validateConfiguration] isotopologue_abundance_type for species " + std::to_string(i) + " was not specified.");
					}
					else if(atmosphere.species_configuration[i].isotopologue_abundance_type == IsotopologueAbundanceType::Defined)
					{
						if(atmosphere.species_configuration[i].abundance.empty())
						{
							throw std::runtime_error("[Configuration::validateConfiguration] isotopologue abundance for species " + std::to_string(i) + " was not specified.");
						}
						else if(atmosphere.species_configuration[i].isotopologue_type.value() == IsotopologueType::Defined)
						{
							if(atmosphere.species_configuration[i].abundance.size() != atmosphere.species_configuration[i].local_isotopologue_id.size())
							{
								throw std::runtime_error("[Configuration::validateConfiguration] isotopologue abundance for species " + std::to_string(i) + " mismatch to local id list.");
							}
						}
						else if(atmosphere.species_configuration[i].isotopologue_type.value() == IsotopologueType::All)
						{
							if(atmosphere.species_configuration[i].abundance.size() != hitran::isos_for_molecule(atmosphere.species_configuration[i].molecule_id.value()).size())
							{
								throw std::runtime_error("[Configuration::validateConfiguration] isotopologue abundance for species " + std::to_string(i) + " mismatch to local id list.");
							}
						}
					}
					else if(atmosphere.species_configuration[i].isotopologue_abundance_type == IsotopologueAbundanceType::HITRAN)
					{
						if(atmosphere.species_configuration[i].abundance.empty())
						{
							throw std::runtime_error("[Configuration::validateConfiguration] isotopologue abundance for species "+ std::to_string(i) + " was not specified.");
						}
					}

					if(!atmosphere.species_configuration[i].scalar.empty())
					{
						if(atmosphere.species_configuration[i].isotopologue_type.value() == IsotopologueType::Defined)
						{
							if(atmosphere.species_configuration[i].scalar.size() != atmosphere.species_configuration[i].local_isotopologue_id.size())
							{
								throw std::runtime_error("[Configuration::validateConfiguration] isotopologue scalar for species " + std::to_string(i) + " mismatch to local id list.");
							}
						}
						else if(atmosphere.species_configuration[i].isotopologue_type.value() == IsotopologueType::All)
						{
							if(atmosphere.species_configuration[i].scalar.size() != hitran::isos_for_molecule(atmosphere.species_configuration[i].molecule_id.value()).size())
							{
								throw std::runtime_error("[Configuration::validateConfiguration] isotopologue scalar for species " + std::to_string(i) + " mismatch to local id list.");
							}
						}
					}

					if(!atmosphere.species_configuration[i].is_normalize.has_value())
					{
						atmosphere.species_configuration[i].is_normalize = false;
						std::cout << "[Configuration::validateConfiguration] normalization of isotopologue abundance for species " + std::to_string(i) + " was not specified. Automatically set to false." << std::endl;
					}
				}
			}
		}
		else if(atmosphere.species_configuration[i].species_state.value() == SpeciesState::Aerosol)
		{
			if(atmosphere.species_configuration[i].scatter_type.value() == ScatterType::Mie)
			{
				//Mie計算に必要なもの：粒径, 複素屈折率
				if(!atmosphere.species_configuration[i].size_distribution.has_value())
				{
					throw std::runtime_error("[Configuration::validateConfiguration] size_distribution for species "+ std::to_string(i) + " was not specified.");
				}
				if(!atmosphere.species_configuration[i].unit_input_radius.has_value())
				{
					atmosphere.species_configuration[i].unit_input_radius = "m";
					std::cout << "[Configuration::validateConfiguration] Unit of radius of species " << i << " was not specified. Automatically set to " << atmosphere.species_configuration[i].unit_input_radius.value() << "." << std::endl;
				}
				
				if(atmosphere.species_configuration[i].size_distribution.value() == ParticleSizeDistribution::Delta)
				{
					// 1. 必須パラメータのチェック (Deltaの半径: delta_r)
					if(!atmosphere.species_configuration[i].delta_r.has_value())
					{
						throw std::runtime_error("[Configuration::validateConfiguration] Delta radius (r) for species "+ std::to_string(i) + " was not specified.");
					}

					// 2. 他の全分布パラメータの無視とリセット (Robustness)

					// Rectangular パラメータ
					if(atmosphere.species_configuration[i].rect_r_mean.has_value())
					{
						std::cout << "[Configuration::validateConfiguration] rect_r_mean (r_mean) was ignored for Delta." << std::endl;
						atmosphere.species_configuration[i].rect_r_mean.reset();
					}
					if(atmosphere.species_configuration[i].rect_width.has_value())
					{
						std::cout << "[Configuration::validateConfiguration] rect_width (width) was ignored for Delta." << std::endl;
						atmosphere.species_configuration[i].rect_width.reset();
					}

					// Log-Normal パラメータ (LND)
					if(atmosphere.species_configuration[i].lnd_r_g.has_value())
					{
						std::cout << "[Configuration::validateConfiguration] lnd_r_g (r_g) was ignored for Delta." << std::endl;
						atmosphere.species_configuration[i].lnd_r_g.reset();
					}
					if(atmosphere.species_configuration[i].lnd_sigma_g.has_value())
					{
						std::cout << "[Configuration::validateConfiguration] lnd_sigma_g (sigma_g) was ignored for Delta." << std::endl;
						atmosphere.species_configuration[i].lnd_sigma_g.reset();
					}
					
					// Gamma (GD) パラメータ
					if(atmosphere.species_configuration[i].gd_a.has_value())
					{
						std::cout << "[Configuration::validateConfiguration] gd_a (a) was ignored for Delta." << std::endl;
						atmosphere.species_configuration[i].gd_a.reset();
					}
					if(atmosphere.species_configuration[i].gd_b.has_value())
					{
						std::cout << "[Configuration::validateConfiguration] gd_b (b) was ignored for Delta." << std::endl;
						atmosphere.species_configuration[i].gd_b.reset();
					}
					
					// Modified Gamma (MGD) パラメータ
					if(atmosphere.species_configuration[i].mgd_r_c.has_value())
					{
						std::cout << "[Configuration::validateConfiguration] mgd_r_c (r_c) was ignored for Delta." << std::endl;
						atmosphere.species_configuration[i].mgd_r_c.reset();
					}
					if(atmosphere.species_configuration[i].mgd_alpha.has_value())
					{
						std::cout << "[Configuration::validateConfiguration] mgd_alpha (alpha) was ignored for Delta." << std::endl;
						atmosphere.species_configuration[i].mgd_alpha.reset();
					}
					if(atmosphere.species_configuration[i].mgd_gamma.has_value())
					{
						std::cout << "[Configuration::validateConfiguration] mgd_gamma (beta) was ignored for Delta." << std::endl;
						atmosphere.species_configuration[i].mgd_gamma.reset();
					}

					// Power Law (PL) パラメータ
					if(atmosphere.species_configuration[i].pl_delta.has_value())
					{
						std::cout << "[Configuration::validateConfiguration] pl_delta (delta) was ignored for Delta." << std::endl;
						atmosphere.species_configuration[i].pl_delta.reset();
					}
					if(atmosphere.species_configuration[i].pl_r1.has_value())
					{
						std::cout << "[Configuration::validateConfiguration] pl_r1 (r_min) was ignored for Delta." << std::endl;
						atmosphere.species_configuration[i].pl_r1.reset();
					}
					if(atmosphere.species_configuration[i].pl_r2.has_value())
					{
						std::cout << "[Configuration::validateConfiguration] pl_r2 (r_max) was ignored for Delta." << std::endl;
						atmosphere.species_configuration[i].pl_r2.reset();
					}

					// サンプリング設定 (Deltaは通常サンプリングをしないため)
					if(atmosphere.species_configuration[i].count_radius.has_value())
					{
						std::cout << "[Configuration::validateConfiguration] n_radius was ignored for Delta." << std::endl;
						atmosphere.species_configuration[i].count_radius.reset();
					}
				}
				else 
				{
					if(!atmosphere.species_configuration[i].count_radius.has_value())
					{
						atmosphere.species_configuration[i].count_radius = 16;
						std::cout << "[Configuration::validateConfiguration] n_radius for species " << i << " was not specified. Automatically set to " << atmosphere.species_configuration[i].count_radius.value() << "." << std::endl;

					}

					if(atmosphere.species_configuration[i].size_distribution.value() == ParticleSizeDistribution::Rectangular)
					{
						// 1. 必須パラメータのチェック
						if(!atmosphere.species_configuration[i].rect_r_mean.has_value())
						{
							throw std::runtime_error("[Configuration::validateConfiguration] Rectangular mean radius (rect_r_mean) for species "+ std::to_string(i) + " was not specified.");
						}
						if(!atmosphere.species_configuration[i].rect_width.has_value())
						{
							throw std::runtime_error("[Configuration::validateConfiguration] Rectangular width (rect_width) for species "+ std::to_string(i) + " was not specified.");
						}
						
						// 他の全分布パラメータの無視とリセット (Ignored Checks)
						if(atmosphere.species_configuration[i].delta_r.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] delta_r (r) was ignored for Rectangular." << std::endl;
							atmosphere.species_configuration[i].delta_r.reset(); 
						}
						if(atmosphere.species_configuration[i].lnd_r_g.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] lnd_r_g (r_g) was ignored for Rectangular." << std::endl;
							atmosphere.species_configuration[i].lnd_r_g.reset(); 
						}
						if(atmosphere.species_configuration[i].lnd_sigma_g.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] lnd_sigma_g (sigma_g) was ignored for Rectangular." << std::endl;
							atmosphere.species_configuration[i].lnd_sigma_g.reset(); 
						}
						if(atmosphere.species_configuration[i].gd_a.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] gd_a (a) was ignored for Rectangular." << std::endl;
							atmosphere.species_configuration[i].gd_a.reset(); 
						}
						if(atmosphere.species_configuration[i].gd_b.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] gd_b (b) was ignored for Rectangular." << std::endl;
							atmosphere.species_configuration[i].gd_b.reset(); 
						}
						if(atmosphere.species_configuration[i].mgd_r_c.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] mgd_r_c (r_c) was ignored for Rectangular." << std::endl;
							atmosphere.species_configuration[i].mgd_r_c.reset(); 
						}
						if(atmosphere.species_configuration[i].mgd_alpha.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] mgd_alpha (alpha) was ignored for Rectangular." << std::endl;
							atmosphere.species_configuration[i].mgd_alpha.reset(); 
						}
						if(atmosphere.species_configuration[i].mgd_gamma.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] mgd_gamma (gamma) was ignored for Rectangular." << std::endl;
							atmosphere.species_configuration[i].mgd_gamma.reset(); 
						}
						if(atmosphere.species_configuration[i].pl_delta.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] pl_delta (delta) was ignored for Rectangular." << std::endl;
							atmosphere.species_configuration[i].pl_delta.reset(); 
						}
						if(atmosphere.species_configuration[i].pl_r1.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] pl_r1 (r_min) was ignored for Rectangular." << std::endl;
							atmosphere.species_configuration[i].pl_r1.reset(); 
						}
						if(atmosphere.species_configuration[i].pl_r2.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] pl_r2 (r_max) was ignored for Rectangular." << std::endl;
							atmosphere.species_configuration[i].pl_r2.reset(); 
						}
					}
					else if(atmosphere.species_configuration[i].size_distribution.value() == ParticleSizeDistribution::LogNormal)
					{
						// 1. 必須パラメータのチェック
						if(!atmosphere.species_configuration[i].lnd_r_g.has_value())
						{
							throw std::runtime_error("[Configuration::validateConfiguration] LogNormal geometric mean radius (r_g) for species "+ std::to_string(i) + " was not specified.");
						}
						if(!atmosphere.species_configuration[i].lnd_sigma_g.has_value())
						{
							throw std::runtime_error("[Configuration::validateConfiguration] LogNormal log standard deviation (sigma_g) for species "+ std::to_string(i) + " was not specified.");
						}

						// 2. 他の全分布パラメータの無視とリセット (Ignored Checks)
						if(atmosphere.species_configuration[i].delta_r.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] delta_r (r) was ignored for LogNormal." << std::endl;
							atmosphere.species_configuration[i].delta_r.reset(); 
						}
						if(atmosphere.species_configuration[i].rect_r_mean.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] rect_r_mean (r_mean) was ignored for LogNormal." << std::endl;
							atmosphere.species_configuration[i].rect_r_mean.reset(); 
						}
						if(atmosphere.species_configuration[i].rect_width.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] rect_width (width) was ignored for LogNormal." << std::endl;
							atmosphere.species_configuration[i].rect_width.reset(); 
						}
						if(atmosphere.species_configuration[i].gd_a.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] gd_a (a) was ignored for LogNormal." << std::endl;
							atmosphere.species_configuration[i].gd_a.reset(); 
						}
						if(atmosphere.species_configuration[i].gd_b.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] gd_b (b) was ignored for LogNormal." << std::endl;
							atmosphere.species_configuration[i].gd_b.reset(); 
						}
						if(atmosphere.species_configuration[i].mgd_r_c.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] mgd_r_c (r_c) was ignored for LogNormal." << std::endl;
							atmosphere.species_configuration[i].mgd_r_c.reset(); 
						}
						if(atmosphere.species_configuration[i].mgd_alpha.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] mgd_alpha (alpha) was ignored for LogNormal." << std::endl;
							atmosphere.species_configuration[i].mgd_alpha.reset(); 
						}
						if(atmosphere.species_configuration[i].mgd_gamma.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] mgd_gamma (gamma) was ignored for LogNormal." << std::endl;
							atmosphere.species_configuration[i].mgd_gamma.reset(); 
						}
						if(atmosphere.species_configuration[i].pl_delta.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] pl_delta (delta) was ignored for LogNormal." << std::endl;
							atmosphere.species_configuration[i].pl_delta.reset(); 
						}
						if(atmosphere.species_configuration[i].pl_r1.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] pl_r1 (r_min) was ignored for LogNormal." << std::endl;
							atmosphere.species_configuration[i].pl_r1.reset(); 
						}
						if(atmosphere.species_configuration[i].pl_r2.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] pl_r2 (r_max) was ignored for LogNormal." << std::endl;
							atmosphere.species_configuration[i].pl_r2.reset(); 
						}
					}
					else if(atmosphere.species_configuration[i].size_distribution.value() == ParticleSizeDistribution::Gamma)
					{
						// 1. 必須パラメータのチェック
						if(!atmosphere.species_configuration[i].gd_a.has_value())
						{
							throw std::runtime_error("[Configuration::validateConfiguration] Gamma scale parameter (a) for species "+ std::to_string(i) + " was not specified.");
						}
						if(!atmosphere.species_configuration[i].gd_b.has_value())
						{
							throw std::runtime_error("[Configuration::validateConfiguration] Gamma shape parameter (b) for species "+ std::to_string(i) + " was not specified.");
						}

						// 2. 他の全分布パラメータの無視とリセット (Ignored Checks)
						if(atmosphere.species_configuration[i].delta_r.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] delta_r (r) was ignored for Gamma." << std::endl;
							atmosphere.species_configuration[i].delta_r.reset(); 
						}
						if(atmosphere.species_configuration[i].rect_r_mean.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] rect_r_mean (r_mean) was ignored for Gamma." << std::endl;
							atmosphere.species_configuration[i].rect_r_mean.reset(); 
						}
						if(atmosphere.species_configuration[i].rect_width.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] rect_width (width) was ignored for Gamma." << std::endl;
							atmosphere.species_configuration[i].rect_width.reset(); 
						}
						if(atmosphere.species_configuration[i].lnd_r_g.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] lnd_r_g (r_g) was ignored for Gamma." << std::endl;
							atmosphere.species_configuration[i].lnd_r_g.reset(); 
						}
						if(atmosphere.species_configuration[i].lnd_sigma_g.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] lnd_sigma_g (sigma_g) was ignored for Gamma." << std::endl;
							atmosphere.species_configuration[i].lnd_sigma_g.reset(); 
						}
						if(atmosphere.species_configuration[i].mgd_r_c.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] mgd_r_c (r_c) was ignored for Gamma." << std::endl;
							atmosphere.species_configuration[i].mgd_r_c.reset(); 
						}
						if(atmosphere.species_configuration[i].mgd_alpha.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] mgd_alpha (alpha) was ignored for Gamma." << std::endl;
							atmosphere.species_configuration[i].mgd_alpha.reset(); 
						}
						if(atmosphere.species_configuration[i].mgd_gamma.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] mgd_gamma (gamma) was ignored for Gamma." << std::endl;
							atmosphere.species_configuration[i].mgd_gamma.reset(); 
						}
						if(atmosphere.species_configuration[i].pl_delta.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] pl_delta (delta) was ignored for Gamma." << std::endl;
							atmosphere.species_configuration[i].pl_delta.reset(); 
						}
						if(atmosphere.species_configuration[i].pl_r1.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] pl_r1 (r_min) was ignored for Gamma." << std::endl;
							atmosphere.species_configuration[i].pl_r1.reset(); 
						}
						if(atmosphere.species_configuration[i].pl_r2.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] pl_r2 (r_max) was ignored for Gamma." << std::endl;
							atmosphere.species_configuration[i].pl_r2.reset(); 
						}
					}
					else if(atmosphere.species_configuration[i].size_distribution.value() == ParticleSizeDistribution::ModifiedGamma)
					{
						// 1. 必須パラメータのチェック
						if(!atmosphere.species_configuration[i].mgd_r_c.has_value())
						{
							throw std::runtime_error("[Configuration::validateConfiguration] Modified Gamma characteristic radius (r_c) for species "+ std::to_string(i) + " was not specified.");
						}
						if(!atmosphere.species_configuration[i].mgd_alpha.has_value())
						{
							throw std::runtime_error("[Configuration::validateConfiguration] Modified Gamma alpha shape (alpha) for species "+ std::to_string(i) + " was not specified.");
						}
						if(!atmosphere.species_configuration[i].mgd_gamma.has_value())
						{
							throw std::runtime_error("[Configuration::validateConfiguration] Modified Gamma gamma spread (gamma) for species "+ std::to_string(i) + " was not specified.");
						}

						// 2. 他の全分布パラメータの無視とリセット (Ignored Checks)
						if(atmosphere.species_configuration[i].delta_r.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] delta_r (r) was ignored for Modified Gamma." << std::endl;
							atmosphere.species_configuration[i].delta_r.reset(); 
						}
						if(atmosphere.species_configuration[i].rect_r_mean.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] rect_r_mean (r_mean) was ignored for Modified Gamma." << std::endl;
							atmosphere.species_configuration[i].rect_r_mean.reset(); 
						}
						if(atmosphere.species_configuration[i].rect_width.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] rect_width (width) was ignored for Modified Gamma." << std::endl;
							atmosphere.species_configuration[i].rect_width.reset(); 
						}
						if(atmosphere.species_configuration[i].lnd_r_g.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] lnd_r_g (r_g) was ignored for Modified Gamma." << std::endl;
							atmosphere.species_configuration[i].lnd_r_g.reset(); 
						}
						if(atmosphere.species_configuration[i].lnd_sigma_g.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] lnd_sigma_g (sigma_g) was ignored for Modified Gamma." << std::endl;
							atmosphere.species_configuration[i].lnd_sigma_g.reset(); 
						}
						if(atmosphere.species_configuration[i].gd_a.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] gd_a (a) was ignored for Modified Gamma." << std::endl;
							atmosphere.species_configuration[i].gd_a.reset(); 
						}
						if(atmosphere.species_configuration[i].gd_b.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] gd_b (b) was ignored for Modified Gamma." << std::endl;
							atmosphere.species_configuration[i].gd_b.reset(); 
						}
						// mgd_r_c, mgd_alpha, mgd_gamma は必須
						if(atmosphere.species_configuration[i].pl_delta.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] pl_delta (delta) was ignored for Modified Gamma." << std::endl;
							atmosphere.species_configuration[i].pl_delta.reset(); 
						}
						if(atmosphere.species_configuration[i].pl_r1.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] pl_r1 (r_min) was ignored for Modified Gamma." << std::endl;
							atmosphere.species_configuration[i].pl_r1.reset(); 
						}
						if(atmosphere.species_configuration[i].pl_r2.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] pl_r2 (r_max) was ignored for Modified Gamma." << std::endl;
							atmosphere.species_configuration[i].pl_r2.reset(); 
						}
					}
					else if(atmosphere.species_configuration[i].size_distribution.value() == ParticleSizeDistribution::PowerLaw)
					{
						// 1. 必須パラメータのチェック
						if(!atmosphere.species_configuration[i].pl_delta.has_value())
						{
							throw std::runtime_error("[Configuration::validateConfiguration] Power Law exponent (delta) for species "+ std::to_string(i) + " was not specified.");
						}
						if(!atmosphere.species_configuration[i].pl_r1.has_value())
						{
							throw std::runtime_error("[Configuration::validateConfiguration] Power Law minimum radius (r1) for species "+ std::to_string(i) + " was not specified.");
						}
						if(!atmosphere.species_configuration[i].pl_r2.has_value())
						{
							throw std::runtime_error("[Configuration::validateConfiguration] Power Law maximum radius (r2) for species "+ std::to_string(i) + " was not specified.");
						}

						// 1b. 物理的整合性チェック
						if(atmosphere.species_configuration[i].pl_r1.value() >= atmosphere.species_configuration[i].pl_r2.value())
						{
							throw std::runtime_error("[Configuration::validateConfiguration] Power Law error: pl_r1 (r1) must be strictly less than pl_r2 (r2).");
						}

						// 2. 他の全分布パラメータの無視とリセット (Ignored Checks)
						if(atmosphere.species_configuration[i].delta_r.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] delta_r (r) was ignored for Power Law." << std::endl;
							atmosphere.species_configuration[i].delta_r.reset(); 
						}
						if(atmosphere.species_configuration[i].rect_r_mean.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] rect_r_mean (r_mean) was ignored for Power Law." << std::endl;
							atmosphere.species_configuration[i].rect_r_mean.reset(); 
						}
						if(atmosphere.species_configuration[i].rect_width.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] rect_width (width) was ignored for Power Law." << std::endl;
							atmosphere.species_configuration[i].rect_width.reset(); 
						}
						if(atmosphere.species_configuration[i].lnd_r_g.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] lnd_r_g (r_g) was ignored for Power Law." << std::endl;
							atmosphere.species_configuration[i].lnd_r_g.reset(); 
						}
						if(atmosphere.species_configuration[i].lnd_sigma_g.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] lnd_sigma_g (sigma_g) was ignored for Power Law." << std::endl;
							atmosphere.species_configuration[i].lnd_sigma_g.reset(); 
						}
						if(atmosphere.species_configuration[i].gd_a.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] gd_a (a) was ignored for Power Law." << std::endl;
							atmosphere.species_configuration[i].gd_a.reset(); 
						}
						if(atmosphere.species_configuration[i].gd_b.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] gd_b (b) was ignored for Power Law." << std::endl;
							atmosphere.species_configuration[i].gd_b.reset(); 
						}
						if(atmosphere.species_configuration[i].mgd_r_c.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] mgd_r_c (r_c) was ignored for Power Law." << std::endl;
							atmosphere.species_configuration[i].mgd_r_c.reset(); 
						}
						if(atmosphere.species_configuration[i].mgd_alpha.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] mgd_alpha (alpha) was ignored for Power Law." << std::endl;
							atmosphere.species_configuration[i].mgd_alpha.reset(); 
						}
						if(atmosphere.species_configuration[i].mgd_gamma.has_value())
						{ 
							std::cout << "[Configuration::validateConfiguration] mgd_gamma (gamma) was ignored for Power Law." << std::endl;
							atmosphere.species_configuration[i].mgd_gamma.reset(); 
						}
					}
				}


				// 高度・波長依存性
				if(!atmosphere.species_configuration[i].refractive_index_type.has_value())
				{
					throw std::runtime_error("[Configuration::validateConfiguration] refractive_index_type for species "+ std::to_string(i) + " was not specified.");
				}
				else if(atmosphere.species_configuration[i].refractive_index_type.value() == RefractiveIndexType::Constant)
				{
					if(!atmosphere.species_configuration[i].nr.has_value() || !atmosphere.species_configuration[i].ni.has_value())
					{
						throw std::runtime_error("[Configuration::validateConfiguration] refractive_index value for species "+ std::to_string(i) + " was not specified.");
					}
				}
				else if(atmosphere.species_configuration[i].refractive_index_type.value() == RefractiveIndexType::Spectral)
				{
					atmosphere.species_configuration[i].filename_refractive_index_spectral_vertical.reset();
					atmosphere.species_configuration[i].varname_refractive_index_spectral_vertical_altitude.reset();
					atmosphere.species_configuration[i].varname_refractive_index_spectral_vertical_spectral.reset();
					atmosphere.species_configuration[i].varname_refractive_index_spectral_vertical_nr.reset();
					atmosphere.species_configuration[i].varname_refractive_index_spectral_vertical_ni.reset();

					if(!atmosphere.species_configuration[i].filename_refractive_index_spectral.has_value())
					{
						throw std::runtime_error("[Configuration::validateConfiguration] filename_refractive_index_spectral value for species "+ std::to_string(i) + " was not specified.");
					}
					if(!atmosphere.species_configuration[i].varname_refractive_index_spectral_spectral.has_value() || !atmosphere.species_configuration[i].varname_refractive_index_spectral_nr.has_value() || !atmosphere.species_configuration[i].varname_refractive_index_spectral_ni.has_value())
					{
						throw std::runtime_error("[Configuration::validateConfiguration] Variable name of refractive index spectral file for species "+ std::to_string(i) + " was not specified.");
					}
				}
				else if(atmosphere.species_configuration[i].refractive_index_type.value() == RefractiveIndexType::Vertical)
				{
					if(atmosphere.species_configuration[i].refractive_index_vertical_profile.empty())
					{
						throw std::runtime_error("[Configuration::validateConfiguration] Vertical refractive index profile table for species " + std::to_string(i) + " is empty.");
					}
					
					if(atmosphere.species_configuration[i].is_refractive_index_same_layering_atmosphere == true)
					{
						if(!atmosphere.z_center.empty())
						{
							if(atmosphere.z_center.size() != atmosphere.species_configuration[i].refractive_index_vertical_profile.size())
							{
								throw std::runtime_error("[Configuration::validateConfiguration] Refractive index vertical profile layering for species " + std::to_string(i) + " does not match to atmosphere.");
							}
						}
						else if(!atmosphere.z_edge.empty())
						{							
							if(atmosphere.z_edge.size() - 1 != atmosphere.species_configuration[i].refractive_index_vertical_profile.size())
							{
								throw std::runtime_error("[Configuration::validateConfiguration] Refractive index vertical profile layering for species " + std::to_string(i) + " does not match to atmosphere.");
							}
						}
					}
					else
					{
						if(!atmosphere.species_configuration[i].refractive_index_vertical_profile_interpolation.has_value())
						{
							atmosphere.species_configuration[i].refractive_index_vertical_profile_interpolation = VerticalProfileInterpolation::Linear;
							std::cout << "[Configuration::validateConfiguration] Refractive Index Vertical profile interpolation for species "+ std::to_string(i) + " was not specified. Automatically set to linear." << std::endl;
						}
						
						if(!atmosphere.species_configuration[i].unit_refractive_index_vertical_profile.has_value())
						{
							atmosphere.species_configuration[i].unit_refractive_index_vertical_profile = atmosphere.z_unit.value();
							std::cout << "[Configuration::validateConfiguration] z unit of refractive index vertica profile for species " + std::to_string(i) + " was not specified. Automatically set to " << atmosphere.z_unit.value() << "." << std::endl;
						}
					}
				}
				else if(atmosphere.species_configuration[i].refractive_index_type.value() == RefractiveIndexType::SpectralVertical)
				{
					atmosphere.species_configuration[i].filename_refractive_index_spectral.reset();
					atmosphere.species_configuration[i].varname_refractive_index_spectral_spectral.reset();
					atmosphere.species_configuration[i].varname_refractive_index_spectral_nr.reset();
					atmosphere.species_configuration[i].varname_refractive_index_spectral_ni.reset();

					if(!atmosphere.species_configuration[i].varname_refractive_index_spectral_vertical_altitude.has_value() || !atmosphere.species_configuration[i].varname_refractive_index_spectral_vertical_spectral.has_value() || !atmosphere.species_configuration[i].varname_refractive_index_spectral_vertical_nr.has_value() || !atmosphere.species_configuration[i].varname_refractive_index_spectral_vertical_ni.has_value())
					{
						throw std::runtime_error("[Configuration::validateConfiguration] Variable name of refractive index spectral-vertical file for species "+ std::to_string(i) + " was not specified.");
					}
					
					if(!atmosphere.species_configuration[i].filename_refractive_index_spectral_vertical.has_value())
					{
						throw std::runtime_error("[Configuration::validateConfiguration] filename_refractive_index_spectral_vertical value for species "+ std::to_string(i) + " was not specified.");
					}

					if(!atmosphere.species_configuration[i].refractive_index_vertical_profile_interpolation.has_value())
					{
						atmosphere.species_configuration[i].refractive_index_vertical_profile_interpolation = VerticalProfileInterpolation::Linear;
						std::cout << "[Configuration::validateConfiguration] Refractive Index Vertical profile interpolation for species "+ std::to_string(i) + " was not specified. Automatically set to linear." << std::endl;
					}
				}
			}
			else
			{
				throw std::runtime_error("[Configuration::validateConfiguration] Only Mie scattering is supported for aerosol species "+ std::to_string(i) + ".");
			}
		}
	}

	//diluent
	if(is_hitran == true)
	{
		if(!atmosphere.filename_hitran.has_value())
		{
			throw std::runtime_error("[Configuration::validateConfiguration] HITRAN netCDF file is not specified.");
		}
		// diluentの指定があるか確認
		// デフォルトは地球大気 (AIR)
		if(atmosphere.diluent_species.empty())
		{
			atmosphere.diluent_species.push_back("Air");
			atmosphere.diluent_ratio.push_back(1.0);
			std::cout << "[Configuration::validateConfiguration] Diluent is not specified. Automatically set to Air = 1.0." << std::endl;
		}
		else
		{
			std::vector<std::string> dil_species = {"AIR", "CO2", "H2", "HE", "H2O"};
			std::vector<int> dil_count(5);
			for(int i = 0; i < atmosphere.diluent_species.size(); ++i)
			{
				std::string dil_sp = toUpper(atmosphere.diluent_species[i]);
				
				bool found = false;
				for(int j = 0; j < dil_species.size(); ++j)
				{
					if(dil_sp == dil_species[j])
					{
						found = true;
						dil_count[j] ++;
						break;
					}
				}
				if(found == false)
				{
					throw std::runtime_error("[Configuration::validateConfiguration] Unknown diluent species name: " + atmosphere.diluent_species[i] + ".");
				}
			}
			for(int i = 0; i < dil_count.size(); ++i)
			{
				if(dil_count[i] > 1)
				{
					throw std::runtime_error("[Configuration::validateConfiguration] Diluent species " + dil_species[i] + " is duplicate.");
				}
			}
		}
	}

	return;
}

};