#pragma once

#include<complex>
#include<filesystem>
#include<fstream>
#include<iomanip>
#include<cmath>
#include<vector>
#include<string>
#include<algorithm>
#include<stdexcept>
#include<limits>
// #include<omp.h>

#include"types"
#include"constants"
#include"utilities"
#include"geometry"
#include"hitran"

#include<Eigen/Dense>
#include<netcdf>

namespace radiative_transfer
{

void normalizeScatteringPhaseFunction(std::vector<std::vector<double>>&);
void computeMieScattering(int, double, double, std::complex<double>, double&, double&, double&, std::vector<std::vector<double>>&);
void computeMieScatteringSizeDistribution(int, double, const std::vector<std::vector<double>>&, std::complex<double>, double&, double&, double&, std::vector<std::vector<double>>&);

std::vector<double> generateGaussianKernel(double, int, double);
std::vector<double> generateRectangularKernel(int);

std::vector<std::vector<std::vector<double>>> generateLogNormalSizeDistribution(int, double, double);
std::vector<std::vector<std::vector<double>>> generateRectangularSizeDistribution(int, double, double);
std::vector<std::vector<std::vector<double>>> generateGammaSizeDistribution(int, double, double);
std::vector<std::vector<std::vector<double>>> generateModifiedGammaSizeDistribution(int, double, double, double);
std::vector<std::vector<std::vector<double>>> generatePowerLawSizeDistribution(int, double, double, double);

std::vector<std::vector<double>> loadSpectralFile(std::string, std::string, std::string, std::string, std::string);
std::vector<std::vector<double>> loadRefractiveIndexSpectralFile(std::string, std::string, std::string, std::string, std::string);
std::vector<std::vector<std::vector<double>>> loadRefractiveIndexSpectralVerticalFile(std::string, std::string, std::string, std::string, std::string, std::string, std::string);

std::vector<std::vector<double>> generateSpectralGridBandpass(int, std::vector<std::vector<double>>, double);
std::vector<std::vector<double>> generateSpectralGridRectangular(int, double, double);
std::vector<std::vector<double>> generateSpectralGridGaussian(int, double, double);

double computePhaseFunction(const std::vector<std::vector<double>>&, double);
std::vector<std::vector<double>> computeRayleighScatteringFunction(int);
std::vector<std::vector<double>> computeHGScatteringFunction(int, double);
// double computeThermalEmission(double, double, double);
double computeAsymmetryParameter(const std::vector<std::vector<double>>&);
double computePlanckFunction(double, double, SpectralCoordinateDimension);
double computeThermalEmission(double, double, double);

inline void computeMieScattering(int n, double radius, double wavelength, std::complex<double> index, double& scattering_cross_section, double& absorption_cross_section, double& extinction_cross_section, std::vector<std::vector<double>>& phase_function)
{
	// Input validation
	if (radius <= 0.0 || wavelength <= 0.0 || n < 2)
	{
		scattering_cross_section = 0.0;
		absorption_cross_section = 0.0;
		extinction_cross_section = 0.0;
		phase_function.clear();
		return;
	}

	// 1) サイズパラメータ x = π·D/λ
	double diameter = 2.0 * radius;
	double x = PI * diameter / wavelength;

	// std::cout << wavelength << ", " << radius << ", " << x << std::endl;

	// 2) 級数上限 N_stop
	int nstop = int(std::floor(x + 4.05 * std::cbrt(x) + 2.0));

	//std::cout << "Riccati-Bessel" << std::endl;

	// 3) Riccati–Bessel 商 D_n(z) の計算
	std::vector<std::complex<double>> DD(nstop + 1);

	{
		double threshold = (13.78 * index.real() - 10.8) * index.real() + 3.9;
		auto z = x * index;
		auto zinv = std::complex<double>(0.0, 0.0);
	
		if (std::abs(index.imag() * x) < threshold)
		{
			DD[0] = 1.0 / std::tan(z);
			zinv  = 1.0 / z;
			for (int i = 1; i <= nstop; ++i)
			{
				double k = double(i);
				auto numerator = k * zinv;
				DD[i] = 1.0 / (numerator - DD[i - 1]) - numerator;
			}
		}
		else
		{
			zinv = 2.0 / z;
			auto aj = -(nstop + 1.5) * zinv;
			auto alpha_j1 = aj + 1.0 / ((nstop + 0.5) * zinv);
			auto alpha_j2 = aj;
			auto ratio = alpha_j1 / alpha_j2;
			auto runratio = ((nstop + 0.5) * zinv) * ratio;

			while (std::abs(std::abs(ratio) - 1.0) > 1e-12)
			{
				aj = zinv - aj;
				alpha_j1 = 1.0 / alpha_j1 + aj;
				alpha_j2 = 1.0 / alpha_j2 + aj;
				ratio = alpha_j1 / alpha_j2;
				runratio *= ratio;
				zinv = -zinv;
			}

			DD[nstop] = -double(nstop) / z + runratio;
			zinv = 1.0 / z;

			for (int i = nstop - 1; i >= 0; --i)
			{
				double k = double(i + 1);
				auto num = k * zinv;
				DD[i] = num - 1.0 / (DD[i + 1] + num);
			}
		}
	}

	//std::cout << DD[nstop] << std::endl;

	//std::cout << "a_n, b_n and Q" << std::endl;

	// 4) Mie 係数 a_n, b_n と効率 Q の計算
	std::vector<std::complex<double>> a(nstop), b(nstop);
	double Qsca = 0.0;
	double Qext = 0.0;

	{
		double psi0 = std::sin(x);
		double psi1 = psi0 / x - std::cos(x);
	
		auto xi0 = std::complex<double>(psi0, -std::cos(x));
		auto xi1 = std::complex<double>(psi1, -(std::cos(x) / x + std::sin(x)));

		// double g = 0.0;
		// double sign1 = 1.0;
		// auto s1 = std::complex<double>(0.0, 0.0);
		// auto s2 = std::complex<double>(0.0, 0.0);
		// double pi0 = 0.0;
		// double pi1 = 1.0;
		// std::complex<double> ann_1(0.0, 0.0);
		// std::complex<double> bnn_1(0.0, 0.0);

		//std::cout << xi0 << ", " << xi1 << std::endl;

		for (int i = 0; i < nstop; ++i)
		{
			a[i] = ((DD[i + 1] / index + double(i + 1) / x) * psi1 - psi0) / ((DD[i + 1] / index + double(i + 1) / x) * xi1 - xi0);
			b[i] = ((DD[i + 1] * index + double(i + 1) / x) * psi1 - psi0) / ((DD[i + 1] * index + double(i + 1) / x) * xi1 - xi0);
			
			//double factor0 = (2.0 * double(i + 1) + 1.0) / double(i + 2) / double(i + 1);
			//tau = double(i + 1) * mu * pi1 - double(i + 2) * pi0;
			//double alpha = factor0 * pi1;
			//double beta = factor0 * tau;
			
			//s1 = s1 + alpha * ann + beta * bnn;
			//s2 = s2 + alpha * bnn + beta * ann;
			
			//factor0 = pi1;//((2*n+1)*mu[k]*pi1[k]-(n+1)*pi0[k])/n;
			//pi1 = ((2.0 * double(i + 1) + 1.0) * mu * pi1 - double(i + 2) * pi0) / double(i + 1);
			//pi0 = factor0;
			
			double factor0 = 2.0 * double(i + 1) + 1.0;
			
			//g = g + double(i) / double(i + 1) * (ann_1.real() * ann.real() + ann_1.imag() * ann.imag() + bnn_1.real() * bnn.real() + bnn_1.imag() * bnn.imag());
			//g = g + factor0 / double(i + 1) / double(i + 2) * (ann.real() * bnn.real() + ann.imag() * bnn.imag());
			Qsca = Qsca + factor0 * (std::abs(a[i]) * std::abs(a[i]) + std::abs(b[i]) * std::abs(b[i]));
			Qext = Qext + factor0 * (a[i].real() + b[i].real());
			
			//sign1 = -sign1;
			
			factor0 = (2.0 * double(i + 1) + 1.0) / x;
			std::complex<double> xi = factor0 * xi1 - xi0;
			xi0 = xi1;
			xi1 = xi;
			
			double psi = factor0 * psi1 - psi0;
			psi0 = psi1;
			psi1 = xi1.real();
		}

		//std::cout << xi0 << ", " << xi1 << ", " << psi0 << ", " << psi1 << std::endl;
	}

	// 5) 無次元効率 Q の正規化
	Qsca = 2.0 * Qsca / (x * x);
	Qext = 2.0 * Qext / (x * x);
	double Qabs = Qext - Qsca;

	// std::cout << "Qsca: " << Qsca << std::endl;
	// std::cout << "Qabs: " << Qabs << std::endl;
	// std::cout << "Qext: " << Qext << std::endl;

	// 6) 断面積 [m^2] に変換
	double area = PI * radius * radius;
	scattering_cross_section = Qsca * area;
	absorption_cross_section = Qabs * area;
	extinction_cross_section = Qext * area;

	//std::cout << "Scattering phase function" << std::endl;

	// 7) 位相関数の計算
	phase_function.clear();
	phase_function.resize(n);
	double dtheta = PI / double(n - 1);

	//#pragma omp parallel for
	for (int k = 0; k < n; ++k)
	{
		double theta = dtheta * double(k);
		double mu = std::cos(theta);

		std::complex<double> S1(0.0, 0.0);
		std::complex<double> S2(0.0, 0.0);
		double pi0 = 0.0;
		double pi1 = 1.0;

		for (int i = 0; i < nstop; ++i)
		{
			double weight = (2.0 * double(i + 1) + 1.0) / double(i + 2) / double(i + 1);
			double tau = double(i + 1) * mu * pi1 - double(i + 2) * pi0;
			// double tau = n_i * mu * pi1 - (n_i + 1) * pi0;

			S1 += weight * (a[i] * pi1 + b[i] * tau);
			S2 += weight * (b[i] * pi1 + a[i] * tau);

			double pi2 = ((2.0 * double(i + 1) + 1.0) * mu * pi1 - double(i + 2) * pi0) / double(i + 1);
			pi0 = pi1;
			pi1 = pi2;
		}

		double s11 = 0.5 * (std::norm(S2) + std::norm(S1));
		// double s12 = 0.5 * (std::norm(S2) - std::norm(S1));
		// double pol = -s12 / s11;
		// double s33 = (S2 * std::conj(S1)).real();
		// double s34 = (S2 * std::conj(S1)).imag();
		double natural = s11 / (PI * x * x * Qsca);
		//double P11 = s11 / (PI * x * x * Qsca);

		phase_function[k] = {theta, natural * 4.0 * PI};
	}

	return;
}

inline void computeMieScatteringSizeDistribution(int n_theta, double wavelength, const std::vector<std::vector<double>>& weight, std::complex<double> index, double& scattering_cross_section, double& absorption_cross_section, double& extinction_cross_section, std::vector<std::vector<double>>& phase_function)
{
	int n_r = weight.size();
	// std::vector<double> scs(n_r);
	// std::vector<double> acs(n_r);
	// std::vector<std::vector<std::vector<double>>> pf(n_r, std::vector<std::vector<double>>(n_theta, std::vector<double>(2)));

	double denom = 0.0;

	absorption_cross_section = 0.0;
	scattering_cross_section = 0.0;
	extinction_cross_section = 0.0;
	phase_function = std::vector<std::vector<double>>(n_theta, std::vector<double>(2, 0.0));

	double dtheta = PI / static_cast<double>(n_theta - 1);
	for (int i = 0; i < n_theta; ++i)
	{
		phase_function[i][0] = dtheta * double(i);
	}

	for(int i = 0; i < n_r; ++i)
	{
		double scs, acs, ecs;
		std::vector<std::vector<double>> pf;
		double n_dr = weight[i][1];
		computeMieScattering(n_theta, weight[i][0], wavelength, index, scs, acs, ecs, pf);
		absorption_cross_section += acs * n_dr;
		scattering_cross_section += scs * n_dr;
		extinction_cross_section += ecs * n_dr;
		denom += n_dr;

		for(int j = 0; j < n_theta; ++j)
		{
			phase_function[j][1] += pf[j][1] * scs * n_dr;
		}
	}

	absorption_cross_section /= denom;
	scattering_cross_section /= denom;
	extinction_cross_section /= denom;
	
	normalizeScatteringPhaseFunction(phase_function);

	return;
}

inline void normalizeScatteringPhaseFunction(std::vector<std::vector<double>> &f)
{
	std::vector<std::vector<double>> phase_function_theta(f.size());

	for(int i = 0; i < f.size(); i ++)
	{
		phase_function_theta[i] = {f[i][0], f[i][1] * 2.0 * PI * std::sin(f[i][0])};
	}

	double sum = computeSimpsonIntegration(phase_function_theta) / (4.0 * PI);

	for(int i = 0; i < f.size(); i ++)
	{
		f[i][1] /= sum;
	}

	return;
}

inline double ModelBuilder::interpolateVerticalProfile(double x, const std::vector<std::vector<double>>& table, VerticalProfileInterpolation type)
{
	if (table.empty()) return 0.0;

	// 2. 範囲外チェック (外挿はせず、端の値を返すか0を返すか仕様による)
	// ここでは範囲外なら 0.0 を返す（元のコード準拠）
	if (x < table.front()[0] || x > table.back()[0])
	{
		return 0.0; 
	}

	// 3. 二分探索 (std::lower_bound) で高速に区間を見つける
	// イテレータ it は、x 以上の最初の要素を指す
	auto it = std::lower_bound(table.begin(), table.end(), x, [](const std::vector<double>& row, double val){return row[0] < val;});

	// x がテーブルの最初の要素と一致する場合のケア
	if (it == table.begin())
	{
		return table.front()[1];
	}

	// it は区間の「右端」なので、一つ戻って「左端」を取得
	size_t j = std::distance(table.begin(), it) - 1;

	// 4. 補間係数 r の計算
	double x0 = table[j][0];
	double x1 = table[j + 1][0];
	double y0 = table[j][1];
	double y1 = table[j + 1][1];

	// 分母が0になるケース（同じ高度のデータが連続している等）をケア
	if (std::abs(x1 - x0) < 1.0e-9) return y0;

	double r = (x - x0) / (x1 - x0);

	// 5. 値の計算
	if (type == VerticalProfileInterpolation::Linear)
	{
		// 線形補間: y = (1-r)y0 + r*y1
		return ((1.0 - r) * y0 + r * y1);
	}
	else
	{ 
		// 指数補間: y = exp( (1-r)ln(y0) + r*ln(y1) )
		// 安全対策: 値が正でなければ線形補間にフォールバック、または微小値を代入
		if (y0 <= 0.0 || y1 <= 0.0) 
		{
			// 0以下の値の対数は取れないため、線形で返すか、0とみなす
			return ((1.0 - r) * y0 + r * y1);
		}

		double log0 = std::log(y0);
		double log1 = std::log(y1);
		
		// 計算後にまとめて scale_value を掛ける方が log の計算回数が減る
		// exp(ln(y)) * scale = y * scale
		return std::exp((1.0 - r) * log0 + r * log1);
	}
}

inline std::vector<Species> ModelBuilder::buildSpecies_(const Configuration& configuration, const AtmosphereModel& atmosphere_model, const SpectralInformation& spectral)
{
	int n_species = configuration.atmosphere.species_configuration.size();
	int n_layers = atmosphere_model.altitude.size();

	std::vector<Species> species;

	for(int i = 0; i < n_species; ++i)
	{
		Species s;
		auto s_input = configuration.atmosphere.species_configuration[i];
		s.name = s_input.name.value();
		s.species_state = s_input.species_state.value();

		s.is_hitran = false;

		// 鉛直分布も忘れずに実装
		s.vertical_number_density_profile.resize(n_layers);
		s.vertical_mixing_ratio_profile.resize(n_layers);
		auto unit_type = getUnitInfo(s_input.unit_vertical_profile[1].value());
		std::string input_unit_val = s_input.unit_vertical_profile[1].value();
		std::string input_unit_alt = s_input.unit_vertical_profile[0].value();

		for (int j = 0; j < n_layers; ++j)
		{
			double z_target = atmosphere_model.altitude[j]; // 目標高度 [m]
			double air_density = atmosphere_model.number_density[j]; // 大気数密度 [m-3]
			double dz = atmosphere_model.altitude_top[j] - atmosphere_model.altitude_bottom[j]; // 層厚 [m]

			// 2. 入力データから、その高度における「生の値」を取得・補間
			double raw_value = 0.0;

			if (s_input.is_same_layering_atmosphere)
			{
				raw_value = s_input.vertical_profile[j][0];
			}
			else
			{
				// 層構造が違うなら、高度を使って補間
				// 入力の高度単位に合わせて z_target を変換 (m -> input_unit)
				double z_query = z_target * scaleUnit("m", input_unit_alt);
				raw_value = interpolateVerticalProfile(z_query, s_input.vertical_profile, s_input.vertical_profile_interpolation.value());
			}

			// 3. 単位と物理量に応じた変換 (数密度と混合比の両方を埋める)
			if (unit_type.dim == UnitDim::Dimensionless) // Mixing Ratio
			{
				// 入力は混合比
				double mixing_ratio = raw_value * scaleUnit(input_unit_val, "mol/mol"); // 単位変換
				
				s.vertical_mixing_ratio_profile[j] = mixing_ratio;
				s.vertical_number_density_profile[j] = mixing_ratio * air_density;
			}
			else if (unit_type.dim == UnitDim::NumberDensity) // Number Density
			{
				// 入力は数密度
				double number_density = raw_value * scaleUnit(input_unit_val, "m-3");

				s.vertical_number_density_profile[j] = number_density;
				s.vertical_mixing_ratio_profile[j] = number_density / air_density;
			}
			else if (unit_type.dim == UnitDim::ColumnNumberDensity) // Column Density
			{
				// 入力はカラム密度 [m-2]
				// 数密度 [m-3] = カラム密度 [m-2] / 層厚 [m]
				double col_density = raw_value * scaleUnit(input_unit_val, "m-2");
				double number_density = col_density / dz;

				s.vertical_number_density_profile[j] = number_density;
				s.vertical_mixing_ratio_profile[j] = number_density / air_density;
			}
		}

		if(s.species_state == SpeciesState::Molecule)
		{
			s.species_type = s_input.species_type.value();

			if(s.species_type == SpeciesType::Scatterer || s.species_type == SpeciesType::Extinction)
			{
				s.scatter_type = s_input.scatter_type.value();

				if(s_input.scattering_cross_section_type.value() == CrossSectionType::Constant)
				{
					s.scattering_cross_section_spectrum = {{spectral.spectral_grid.front() - 1.0, s_input.scattering_cross_section.value() * scaleUnit(s_input.scattering_cross_section_unit.value(), "m2")}, {spectral.spectral_grid.back() + 1.0, s_input.scattering_cross_section.value() * scaleUnit(s_input.scattering_cross_section_unit.value(), "m2")}};
				}
				else if(s_input.scattering_cross_section_type.value() == CrossSectionType::External)
				{
					// 外部ファイルを読み込み
					// 読み込んだ配列 std::vector<std::vector<double>> loaded_data ({spectral, scattering_cross_section}の配列)
					std::vector<std::vector<double>> loaded_data;

					if(spectral.spectral_dimension == SpectralCoordinateDimension::Wavelength)
					{
						loaded_data = loadSpectralFile(s_input.filename_scattering_cross_section.value(), s_input.varname_scattering_cross_section_spectral.value(), s_input.varname_scattering_cross_section.value(), "m", "m2");
					}
					else if(spectral.spectral_dimension == SpectralCoordinateDimension::Wavenumber)
					{
						loaded_data = loadSpectralFile(s_input.filename_scattering_cross_section.value(), s_input.varname_scattering_cross_section_spectral.value(), s_input.varname_scattering_cross_section.value(), "m-1", "m2");
					}

					for(int j = 0; j < loaded_data.size(); ++j)
					{
						s.scattering_cross_section_spectrum = loaded_data;
					}
				}

				if(s.scatter_type == ScatterType::HenyeyGreenstein)
				{
					s.g_factor = s_input.g_factor.value();
				}
			}

			if(s.species_type == SpeciesType::Absorber || s.species_type == SpeciesType::Extinction)
			{
				if(s_input.absorption_cross_section_type.value() == CrossSectionType::Constant)
				{
					s.absorption_cross_section_spectrum = {{spectral.spectral_grid.front() - 1.0, s_input.absorption_cross_section.value() * scaleUnit(s_input.absorption_cross_section_unit.value(), "m2")}, {spectral.spectral_grid.back() + 1.0, s_input.absorption_cross_section.value() * scaleUnit(s_input.absorption_cross_section_unit.value(), "m2")}};
				}
				else if(s_input.absorption_cross_section_type.value() == CrossSectionType::External)
				{
					// 外部ファイルを読み込み
					// 読み込んだ配列 std::vector<std::vector<double>> loaded_data ({spectral, absorption_cross_section}の配列)
					std::vector<std::vector<double>> loaded_data;

					if(spectral.spectral_dimension == SpectralCoordinateDimension::Wavelength)
					{
						loaded_data = loadSpectralFile(s_input.filename_absorption_cross_section.value(), s_input.varname_absorption_cross_section_spectral.value(), s_input.varname_absorption_cross_section.value(), "m", "m2");
					}
					else if(spectral.spectral_dimension == SpectralCoordinateDimension::Wavenumber)
					{
						loaded_data = loadSpectralFile(s_input.filename_absorption_cross_section.value(), s_input.varname_absorption_cross_section_spectral.value(), s_input.varname_absorption_cross_section.value(), "m-1", "m2");
					}

					for(int j = 0; j < loaded_data.size(); ++j)
					{
						s.absorption_cross_section_spectrum = loaded_data;
					}
				}
				else if(s_input.absorption_cross_section_type.value() == CrossSectionType::HITRAN)
				{
					s.is_hitran = true;
				}
			}
		}
		else if(s.species_state == SpeciesState::Aerosol)
		{
			s.scatter_type = s_input.scatter_type.value();

			if(s.scatter_type == ScatterType::Mie)
			{
				s.refractive_index.resize(n_layers);

				if(s_input.refractive_index_type.value() == RefractiveIndexType::Constant)
				{
					for(int j = 0; j < n_layers; ++j)
					{
						s.refractive_index[j] = {{spectral.spectral_grid.front() - 1.0, s_input.nr.value(), s_input.ni.value()}, {spectral.spectral_grid.back() + 1.0, s_input.nr.value(), s_input.ni.value()}};
					}
				}
				else if(s_input.refractive_index_type.value() == RefractiveIndexType::Spectral)
				{
					// 外部ファイル読み込み
					// 読み込んだ配列 std::vector<std::vector<double>> loaded_data ({spectral, nr, ni}の配列)

					std::vector<std::vector<double>> loaded_data;

					if(spectral.spectral_dimension == SpectralCoordinateDimension::Wavelength)
					{
						loaded_data = loadRefractiveIndexSpectralFile(s_input.filename_refractive_index_spectral.value(), s_input.varname_refractive_index_spectral_spectral.value(), s_input.varname_refractive_index_spectral_nr.value(), s_input.varname_refractive_index_spectral_ni.value(), "m");
					}
					else if(spectral.spectral_dimension == SpectralCoordinateDimension::Wavenumber)
					{
						loaded_data = loadRefractiveIndexSpectralFile(s_input.filename_refractive_index_spectral.value(), s_input.varname_refractive_index_spectral_spectral.value(), s_input.varname_refractive_index_spectral_nr.value(), s_input.varname_refractive_index_spectral_ni.value(), "m-1");
					}

					for(int j = 0; j < n_layers; ++j)
					{
						s.refractive_index[j] = loaded_data;
					}
				}
				else if(s_input.refractive_index_type.value() == RefractiveIndexType::Vertical)
				{
					if(s_input.is_refractive_index_same_layering_atmosphere == true)
					{
						for(int j = 0; j < n_layers; ++j)
						{
							s.refractive_index[j] = {{spectral.spectral_grid.front() - 1.0, s_input.refractive_index_vertical_profile[j][0], s_input.refractive_index_vertical_profile[j][1]}, {spectral.spectral_grid.back() + 1.0, s_input.refractive_index_vertical_profile[j][0], s_input.refractive_index_vertical_profile[j][1]}};
						}
					}
					else
					{
						std::vector<std::vector<double>> nr_input(s_input.refractive_index_vertical_profile.size(), std::vector<double>(2, 0.0));
						std::vector<std::vector<double>> ni_input(s_input.refractive_index_vertical_profile.size(), std::vector<double>(2, 0.0));

						for(int j = 0; j < s_input.refractive_index_vertical_profile.size(); ++j)
						{
							nr_input[j] = {s_input.refractive_index_vertical_profile[j][0] * scaleUnit(s_input.unit_refractive_index_vertical_profile.value(), "m"), s_input.refractive_index_vertical_profile[j][1]};
							ni_input[j] = {s_input.refractive_index_vertical_profile[j][0] * scaleUnit(s_input.unit_refractive_index_vertical_profile.value(), "m"), s_input.refractive_index_vertical_profile[j][2]};
						}

						auto itp = s_input.refractive_index_vertical_profile_interpolation.value();

						for(int j = 0; j < n_layers; ++j)
						{
							double alt = atmosphere_model.altitude[j];
							s.refractive_index[j] = {{spectral.spectral_grid.front() - 1.0, interpolateVerticalProfile(alt, nr_input, itp), interpolateVerticalProfile(alt, ni_input, itp)}, {spectral.spectral_grid.back() + 1.0, interpolateVerticalProfile(alt, nr_input, itp), interpolateVerticalProfile(alt, ni_input, itp)}};
						}
					}
				}
				else if(s_input.refractive_index_type.value() == RefractiveIndexType::SpectralVertical)
				{
					// 外部ファイル読み込み
					// 読み込んだ配列 std::vector<std::vector<std::vector<double>>> loaded_data ({altitude, spectral, nr, ni}の配列)
					// loaded_data[n_alt][n_spec] = {alt, spec, nr, ni}
					std::vector<std::vector<std::vector<double>>> loaded_data;
					if(spectral.spectral_dimension == SpectralCoordinateDimension::Wavelength)
					{
						loaded_data = loadRefractiveIndexSpectralVerticalFile(s_input.filename_refractive_index_spectral_vertical.value(), s_input.varname_refractive_index_spectral_vertical_altitude.value(), s_input.varname_refractive_index_spectral_vertical_spectral.value(), s_input.varname_refractive_index_spectral_vertical_nr.value(), s_input.varname_refractive_index_spectral_vertical_ni.value(), "m", "m");
					}
					else if(spectral.spectral_dimension == SpectralCoordinateDimension::Wavenumber)
					{
						loaded_data = loadRefractiveIndexSpectralVerticalFile(s_input.filename_refractive_index_spectral_vertical.value(), s_input.varname_refractive_index_spectral_vertical_altitude.value(), s_input.varname_refractive_index_spectral_vertical_spectral.value(), s_input.varname_refractive_index_spectral_vertical_nr.value(), s_input.varname_refractive_index_spectral_vertical_ni.value(), "m", "m-1");
					}

					// 入力データの高度リストを作成（検索用）
					std::vector<double> input_alts(loaded_data.size());
					for(const auto& layer : loaded_data)
					{
						input_alts.push_back(layer[0][0]);
					}

					s.refractive_index.resize(n_layers);
					auto itp_method = s_input.refractive_index_vertical_profile_interpolation.value();

					// 各計算レイヤーに対して
					for(int j = 0; j < n_layers; ++j)
					{
						double target_alt = atmosphere_model.altitude[j];

						// 補間を行う2つの入力層を探す (lower_bound)
						// it は target_alt 以上の最初の要素を指す
						auto it = std::lower_bound(input_alts.begin(), input_alts.end(), target_alt);

						// 補間結果を格納するベクタを準備
						size_t n_spec = loaded_data[0].size();
						s.refractive_index[j].resize(n_spec);

						if (it == input_alts.begin()) 
						{
							// 範囲外(下): 一番下の層をコピー
							const auto& src = loaded_data.front();

							for(size_t k=0; k<n_spec; ++k)
							{
								s.refractive_index[j][k] = {src[k][1], src[k][2], src[k][3]};
							}
						}
						else if (it == input_alts.end()) 
						{
							// 範囲外(上): 一番上の層をコピー
							const auto& src = loaded_data.back();

							for(size_t k=0; k<n_spec; ++k)
							{
								s.refractive_index[j][k] = {src[k][1], src[k][2], src[k][3]};
							}
						}
						else
						{
							// 範囲内
							size_t idx_upper = std::distance(input_alts.begin(), it);
							size_t idx_lower = idx_upper - 1;

							double z0 = input_alts[idx_lower];
							double z1 = input_alts[idx_upper];
							
							// 線形補間係数
							double factor = (target_alt - z0) / (z1 - z0);

							// ★ここが最適化ポイント★
							// 「波長ごとのループ」の中で「高度探索」をするのではなく、
							// 「決まった2つの高度層」に対して「全波長を一気に計算」する。
							
							const auto& layer0 = loaded_data[idx_lower];
							const auto& layer1 = loaded_data[idx_upper];

							// ---------------------------------------------------
							// 補間方法による分岐 (ループの外で判定)
							// ---------------------------------------------------
							if (itp_method == VerticalProfileInterpolation::Linear)
							{
								// --- 線形補間 (Linear) ---
								// y = y0 + factor * (y1 - y0)
								for(size_t k = 0; k < n_spec; ++k)
								{
									double wl = layer0[k][1];
									double nr = layer0[k][2] + factor * (layer1[k][2] - layer0[k][2]);
									double ni = layer0[k][3] + factor * (layer1[k][3] - layer0[k][3]);

									s.refractive_index[j][k] = {wl, nr, ni};
								}
							}
							else
							{
								// --- 対数線形補間 (Exponential / Log-Linear) ---
								// ln(y) = ln(y0) + factor * (ln(y1) - ln(y0))
								// y = exp( ... )
								
								for(size_t k = 0; k < n_spec; ++k)
								{
									double wl = layer0[k][1];
									double nr, ni;

									// 実部 (Nr) の補間
									double nr0 = layer0[k][2];
									double nr1 = layer1[k][2];
									
									// 安全策: 値が正でなければ対数が取れないため、線形にフォールバック
									if (nr0 <= 1.0e-50 || nr1 <= 1.0e-50)
									{
										nr = nr0 + factor * (nr1 - nr0);
									}
									else
									{
										nr = std::exp(std::log(nr0) + factor * (std::log(nr1) - std::log(nr0)));
									}

									// 虚部 (Ni) の補間
									double ni0 = layer0[k][3];
									double ni1 = layer1[k][3];

									if (ni0 <= 1.0e-50 || ni1 <= 1.0e-50)
									{
										ni = ni0 + factor * (ni1 - ni0);
									}
									else
									{
										ni = std::exp(std::log(ni0) + factor * (std::log(ni1) - std::log(ni0)));
									}

									s.refractive_index[j][k] = {wl, nr, ni};
								}
							}
						}
					}
				}

				if(s_input.size_distribution.value() == ParticleSizeDistribution::Delta)
				{
					s.particle_size_distribution = {{s_input.delta_r.value() * scaleUnit(s_input.unit_input_radius.value(), "m"), 1.0}};
					s.weight_particle_size_distribution = {{s_input.delta_r.value() * scaleUnit(s_input.unit_input_radius.value(), "m"), 1.0}};
				}
				else if(s_input.size_distribution.value() == ParticleSizeDistribution::Rectangular)
				{
					auto node_weight = generateRectangularSizeDistribution(s_input.count_radius.value(), s_input.rect_r_mean.value() * scaleUnit(s_input.unit_input_radius.value(), "m"), s_input.rect_width.value() * scaleUnit(s_input.unit_input_radius.value(), "m"));
					s.particle_size_distribution = node_weight[0]; // 本当は不要
					s.weight_particle_size_distribution = node_weight[1];
				}
				else if(s_input.size_distribution.value() == ParticleSizeDistribution::Gamma)
				{
					auto node_weight = generateGammaSizeDistribution(s_input.count_radius.value(), s_input.gd_a.value() * scaleUnit(s_input.unit_input_radius.value(), "m"), s_input.gd_b.value());
					s.particle_size_distribution = node_weight[0]; // 本当は不要
					s.weight_particle_size_distribution = node_weight[1];
				}
				else if(s_input.size_distribution.value() == ParticleSizeDistribution::ModifiedGamma)
				{
					auto node_weight = generateModifiedGammaSizeDistribution(s_input.count_radius.value(), s_input.mgd_r_c.value() * scaleUnit(s_input.unit_input_radius.value(), "m"), s_input.mgd_alpha.value(), s_input.mgd_gamma.value());
					s.particle_size_distribution = node_weight[0]; // 本当は不要
					s.weight_particle_size_distribution = node_weight[1];
				}
				else if(s_input.size_distribution.value() == ParticleSizeDistribution::LogNormal)
				{
					auto node_weight = generateLogNormalSizeDistribution(s_input.count_radius.value(), s_input.lnd_r_g.value() * scaleUnit(s_input.unit_input_radius.value(), "m"), s_input.lnd_sigma_g.value());
					s.particle_size_distribution = node_weight[0]; // 本当は不要
					s.weight_particle_size_distribution = node_weight[1];
				}
				else if(s_input.size_distribution.value() == ParticleSizeDistribution::PowerLaw)
				{
					auto node_weight = generatePowerLawSizeDistribution(s_input.count_radius.value(), s_input.pl_delta.value(), s_input.pl_r1.value() * scaleUnit(s_input.unit_input_radius.value(), "m"), s_input.pl_r2.value() * scaleUnit(s_input.unit_input_radius.value(), "m"));
					s.particle_size_distribution = node_weight[0]; // 本当は不要
					s.weight_particle_size_distribution = node_weight[1];
				}
			}
		}

		if(s.is_hitran == false)
		{
			species.push_back(s);
		}
		else
		{
			netCDF::NcFile nc_hitran(configuration.atmosphere.filename_hitran.value(), netCDF::NcFile::read);

			double wavenumber_max_calc, wavenumber_min_calc;

			if(spectral.spectral_dimension == SpectralCoordinateDimension::Wavelength)
			{
				wavenumber_max_calc = 1.0 / spectral.spectral_grid[0];
				wavenumber_min_calc = 1.0 / spectral.spectral_grid[spectral.spectral_grid.size() - 1];
			}
			else if(spectral.spectral_dimension == SpectralCoordinateDimension::Wavenumber)
			{
				wavenumber_max_calc = spectral.spectral_grid[spectral.spectral_grid.size() - 1];
				wavenumber_min_calc = spectral.spectral_grid[0];
			}

			double wavenumber_min = std::max(0.0, wavenumber_min_calc - 1000.0 * scaleUnit("cm-1", "m-1"));
			double wavenumber_max = wavenumber_max_calc + 1000.0 * scaleUnit("cm-1", "m-1"); // 1000.0はハードコード．あまり良くないかも


			if(s_input.isotopologue_type.value() == IsotopologueType::All)
			{
				auto isos = hitran::isos_for_molecule(s_input.molecule_id.value());

				if(!s_input.abundance.empty())
				{
					for(int j = 0; j < isos.size(); ++j)
					{
						isos[j].abundance = s_input.abundance[j];
					}
				}
				
				if(!s_input.scalar.empty())
				{
					for(int j = 0; j < isos.size(); ++j)
					{
						isos[j].abundance *= s_input.scalar[j];
					}
				}

				if(s_input.is_normalize.value() == true)
				{
					double norm_const = 0.0;

					for(const auto& iso : isos)
					{
						norm_const += iso.abundance;
					}
					
					if(norm_const > 0.0)
					{
						for(auto& iso : isos)
						{
							iso.abundance /= norm_const;
						}
					}
				}

				for(int j = 0; j < isos.size(); ++j)
				{
					Species ss = s;
					ss.isotopologue = isos[j];

					for(int k = 0; k < ss.vertical_mixing_ratio_profile.size(); ++k)
					{
						ss.vertical_mixing_ratio_profile[k] *= isos[j].abundance;
						ss.vertical_number_density_profile[k] *= isos[j].abundance;
					}

					ss.lines = hitran::loadLines(nc_hitran, ss.isotopologue, wavenumber_min, wavenumber_max, false);

					species.push_back(ss);
				}
			}
			else if(s_input.isotopologue_type.value() == IsotopologueType::Defined)
			{
				std::vector<hitran::Isotopologue> isos(s_input.local_isotopologue_id.size());

				for(int j = 0; j < isos.size(); ++j)
				{
					isos[j] = hitran::iso_from_global(hitran::global_from_mol_local(s_input.molecule_id.value(), s_input.local_isotopologue_id[j]));
				}

				if(!s_input.abundance.empty())
				{
					for(int j = 0; j < isos.size(); ++j)
					{
						isos[j].abundance = s_input.abundance[j];
					}
				}
				
				if(!s_input.scalar.empty())
				{
					for(int j = 0; j < isos.size(); ++j)
					{
						isos[j].abundance *= s_input.scalar[j];
					}
				}

				if(s_input.is_normalize.value() == true)
				{
					double norm_const = 0.0;

					for(const auto& iso : isos)
					{
						norm_const += iso.abundance;
					}
					
					if(norm_const > 0.0)
					{
						for(auto& iso : isos)
						{
							iso.abundance /= norm_const;
						}
					}
				}

				for(int j = 0; j < isos.size(); ++j)
				{
					Species ss = s;
					ss.isotopologue = isos[j];

					for(int k = 0; k < ss.vertical_mixing_ratio_profile.size(); ++k)
					{
						ss.vertical_mixing_ratio_profile[k] *= isos[j].abundance;
						ss.vertical_number_density_profile[k] *= isos[j].abundance;
					}

					ss.lines = hitran::loadLines(nc_hitran, ss.isotopologue, wavenumber_min, wavenumber_max, false);

					species.push_back(ss);
				}
			}
		}
	}

	return species;
}

inline AtmosphereModel ModelBuilder::buildAtmosphereModel(const Configuration& configuration, const SpectralInformation& spectral)
{
	AtmosphereModel model;

	// layering
	if(! configuration.atmosphere.z_edge.empty())
	{
		int n_layer = configuration.atmosphere.z_edge.size() - 1;
		model.altitude_bottom.resize(n_layer);
		model.altitude_top.resize(n_layer);
		model.altitude.resize(n_layer);

		for(int i = 0; i < n_layer; ++i)
		{
			model.altitude_bottom[i] = configuration.atmosphere.z_edge[i];
			model.altitude_top[i] = configuration.atmosphere.z_edge[i + 1];
			model.altitude[i] = 0.5 * (model.altitude_top[i] + model.altitude_bottom[i]);
		}
	}
	else
	{
		int n_layer = configuration.atmosphere.z_center.size();
		model.altitude_bottom.resize(n_layer);
		model.altitude_top.resize(n_layer);
		model.altitude.resize(n_layer);

		for(int i = 0; i < n_layer; ++i)
		{
			model.altitude[i] = configuration.atmosphere.z_center[i];

			if(i == 0)
			{
				model.altitude_bottom[i] = configuration.atmosphere.z_center[0];
				model.altitude_top[i] = 0.5 * (configuration.atmosphere.z_center[0] + configuration.atmosphere.z_center[1]);
			}
			else if(i == n_layer - 1)
			{
				model.altitude_bottom[i] = 0.5 * (configuration.atmosphere.z_center[n_layer - 2] + configuration.atmosphere.z_center[n_layer - 1]);
				model.altitude_top[i] = configuration.atmosphere.z_center[n_layer - 1];
			}
			else
			{
				model.altitude_bottom[i] = 0.5 * (configuration.atmosphere.z_center[i - 1] + configuration.atmosphere.z_center[i]);
				model.altitude_top[i] = 0.5 * (configuration.atmosphere.z_center[i] + configuration.atmosphere.z_center[i + 1]);
			}
		}
	}

	int n_layer = model.altitude.size();

	model.temperature.resize(n_layer);

	if(configuration.atmosphere.is_same_temperature_layering_atmosphere == false)
	{
		if(configuration.atmosphere.vertical_temperature_profile == VerticalTemperatureProfile::VIRA_EQUATOR || configuration.atmosphere.vertical_temperature_profile == VerticalTemperatureProfile::VIRA_45 || configuration.atmosphere.vertical_temperature_profile == VerticalTemperatureProfile::VIRA_60 || configuration.atmosphere.vertical_temperature_profile == VerticalTemperatureProfile::Table)
		{
			std::vector<std::vector<double>> profile_data;
			if(configuration.atmosphere.vertical_temperature_profile == VerticalTemperatureProfile::VIRA_EQUATOR)
			{
				profile_data.resize(vira_equator.size());
				
				for(int i = 0; i < vira_equator.size(); i ++)
				{
					profile_data[i] = {vira_equator[i][0] * scaleUnit("km", "m"), vira_equator[i][1]};
				}
			}
			else if(configuration.atmosphere.vertical_temperature_profile == VerticalTemperatureProfile::VIRA_45)
			{
				profile_data.resize(vira_45.size());

				for(int i = 0; i < vira_45.size(); i ++)
				{
					profile_data[i] = {vira_45[i][0] * scaleUnit("km", "m"), vira_45[i][1]};
				}
			}
			else if(configuration.atmosphere.vertical_temperature_profile == VerticalTemperatureProfile::VIRA_60)
			{
				profile_data.resize(vira_60.size());

				for(int i = 0; i < vira_60.size(); i ++)
				{
					profile_data[i] = {vira_60[i][0] * scaleUnit("km", "m"), vira_60[i][1]};
				}
			}
			else if(configuration.atmosphere.vertical_temperature_profile == VerticalTemperatureProfile::Table)
			{
				profile_data.resize(configuration.atmosphere.temperature_profile.size());

				for(int i = 0; i < configuration.atmosphere.temperature_profile.size(); i ++)
				{
					profile_data[i] = {configuration.atmosphere.temperature_profile[i][0] * scaleUnit(configuration.atmosphere.temperature_unit[0].value(), "m"), configuration.atmosphere.temperature_profile[i][1]};
				}
			}
			
			for(int i = 0; i < n_layer; ++i)
			{
				model.temperature[i] = interpolateVerticalProfile(model.altitude[i], profile_data, configuration.atmosphere.vertical_temperature_interpolation.value());
			}
		}
	}
	else
	{
		for(int i = 0; i < n_layer; i ++)
		{
			model.temperature[i] = configuration.atmosphere.temperature_profile[i][1];
		}
	}

	model.pressure.resize(n_layer);

	if(configuration.atmosphere.is_same_pressure_layering_atmosphere == false)
	{
		if(configuration.atmosphere.vertical_pressure_profile == VerticalPressureProfile::VIRA_EQUATOR || configuration.atmosphere.vertical_pressure_profile == VerticalPressureProfile::VIRA_45 || configuration.atmosphere.vertical_pressure_profile == VerticalPressureProfile::VIRA_60 || configuration.atmosphere.vertical_pressure_profile == VerticalPressureProfile::Table)
		{
			std::vector<std::vector<double>> profile_data;
			if(configuration.atmosphere.vertical_pressure_profile == VerticalPressureProfile::VIRA_EQUATOR)
			{
				profile_data.resize(vira_equator.size());
				
				for(int i = 0; i < vira_equator.size(); i ++)
				{
					profile_data[i] = {vira_equator[i][0] * scaleUnit("km", "m"), vira_equator[i][2] * scaleUnit("bar", "Pa")};
				}
			}
			else if(configuration.atmosphere.vertical_pressure_profile == VerticalPressureProfile::VIRA_45)
			{
				profile_data.resize(vira_45.size());

				for(int i = 0; i < vira_45.size(); i ++)
				{
					profile_data[i] = {vira_45[i][0] * scaleUnit("km", "m"), vira_45[i][2] * scaleUnit("bar", "Pa")};
				}
			}
			else if(configuration.atmosphere.vertical_pressure_profile == VerticalPressureProfile::VIRA_60)
			{
				profile_data.resize(vira_60.size());

				for(int i = 0; i < vira_60.size(); i ++)
				{
					profile_data[i] = {vira_60[i][0] * scaleUnit("km", "m"), vira_60[i][2] * scaleUnit("bar", "Pa")};
				}
			}
			else if(configuration.atmosphere.vertical_pressure_profile == VerticalPressureProfile::Table)
			{
				profile_data.resize(configuration.atmosphere.pressure_profile.size());

				for(int i = 0; i < configuration.atmosphere.pressure_profile.size(); i ++)
				{
					profile_data[i] = {configuration.atmosphere.pressure_profile[i][0] * scaleUnit(configuration.atmosphere.pressure_unit[0].value(), "m"), configuration.atmosphere.pressure_profile[i][1] * scaleUnit(configuration.atmosphere.pressure_unit[1].value(), "Pa")};
				}
			}
			
			for(int i = 0; i < n_layer; ++i)
			{
				model.pressure[i] = interpolateVerticalProfile(model.altitude[i], profile_data, configuration.atmosphere.vertical_pressure_interpolation.value());
			}
		}
		else if(configuration.atmosphere.vertical_pressure_profile == VerticalPressureProfile::External)
		{
			// configuration.atmosphere.output_log << "CURRENTRY EXTERNAL INPUT IS NOT SUPPORTED" << std::endl;
		}
		else if(configuration.atmosphere.vertical_pressure_profile == VerticalPressureProfile::Hydrostatic)
		{
			// configuration.atmosphere.output_log << "CURRENTRY HYDROSTATIC IS NOT SUPPORTED" << std::endl;
		}
	}
	else
	{
		for(int i = 0; i < n_layer; i ++)
		{
			model.pressure[i] = configuration.atmosphere.pressure_profile[i][1] * scaleUnit(configuration.atmosphere.pressure_unit[1].value(), "Pa");
		}
	}

	model.number_density.resize(n_layer);

	//Ideal Gas Law PV=nRT n(mol)/V(m^3) = P(N/m^2)/(R(N.m/K/mol)*T(K)) n(molecules/m^3)=NA*P*/(R*T)
	if(configuration.atmosphere.vertical_number_density_profile == VerticalNumberDensityProfile::IdealGas)
	{
		for(int i = 0; i < n_layer; i ++)
		{
			model.number_density[i] = model.pressure[i] * AVOGADRO_CONSTANT / (MOLAR_GAS_CONSTANT * model.temperature[i]);
		}
	}
	else
	{
		if(configuration.atmosphere.is_same_number_density_layering_atmosphere == false)
		{
			if(configuration.atmosphere.vertical_number_density_profile == VerticalNumberDensityProfile::VIRA_EQUATOR || configuration.atmosphere.vertical_number_density_profile == VerticalNumberDensityProfile::VIRA_45 || configuration.atmosphere.vertical_number_density_profile == VerticalNumberDensityProfile::VIRA_60 || configuration.atmosphere.vertical_number_density_profile == VerticalNumberDensityProfile::Table)
			{
				std::vector<std::vector<double>> profile_data;
				if(configuration.atmosphere.vertical_number_density_profile == VerticalNumberDensityProfile::VIRA_EQUATOR)
				{
					profile_data.resize(vira_equator.size());
					
					for(int i = 0; i < vira_equator.size(); i ++)
					{
						profile_data[i] = {vira_equator[i][0] * scaleUnit("km", "m"), vira_equator[i][3] * scaleUnit("m-3", "m-3")};
					}
				}
				else if(configuration.atmosphere.vertical_number_density_profile == VerticalNumberDensityProfile::VIRA_45)
				{
					profile_data.resize(vira_45.size());

					for(int i = 0; i < vira_45.size(); i ++)
					{
						profile_data[i] = {vira_45[i][0] * scaleUnit("km", "m"), vira_45[i][3] * scaleUnit("m-3", "m-3")};
					}
				}
				else if(configuration.atmosphere.vertical_number_density_profile == VerticalNumberDensityProfile::VIRA_60)
				{
					profile_data.resize(vira_60.size());

					for(int i = 0; i < vira_60.size(); i ++)
					{
						profile_data[i] = {vira_60[i][0] * scaleUnit("km", "m"), vira_60[i][3] * scaleUnit("m-3", "m-3")};
					}
				}
				else if(configuration.atmosphere.vertical_number_density_profile == VerticalNumberDensityProfile::Table)
				{
					profile_data.resize(configuration.atmosphere.number_density_profile.size());

					for(int i = 0; i < configuration.atmosphere.number_density_profile.size(); i ++)
					{
						if(configuration.atmosphere.unit_dim_number_density.value() == UnitDim::NumberDensity)
						{
							profile_data[i] = {configuration.atmosphere.number_density_profile[i][0] * scaleUnit(configuration.atmosphere.number_density_unit[0].value(), "m"), configuration.atmosphere.number_density_profile[i][1] * scaleUnit(configuration.atmosphere.number_density_unit[1].value(), "m-3")};
						}
						else if(configuration.atmosphere.unit_dim_number_density.value() == UnitDim::ColumnNumberDensity)
						{
							profile_data[i] = {configuration.atmosphere.number_density_profile[i][0] * scaleUnit(configuration.atmosphere.number_density_unit[0].value(), "m"), configuration.atmosphere.number_density_profile[i][1] * scaleUnit(configuration.atmosphere.number_density_unit[1].value(), "m-2")};
						}
					}
				}
				
				for(int i = 0; i < n_layer; ++i)
				{
					if(configuration.atmosphere.unit_dim_number_density.value() == UnitDim::NumberDensity)
					{
						model.number_density[i] = interpolateVerticalProfile(model.altitude[i], profile_data, configuration.atmosphere.vertical_number_density_interpolation.value());
					}
					else if(configuration.atmosphere.unit_dim_number_density.value() == UnitDim::ColumnNumberDensity)
					{
						model.number_density[i] = interpolateVerticalProfile(model.altitude[i], profile_data, configuration.atmosphere.vertical_number_density_interpolation.value()) / (model.altitude_top[i] - model.altitude_bottom[i]);
					}
				}
			}
			else if(configuration.atmosphere.vertical_number_density_profile == VerticalNumberDensityProfile::External)
			{
				// configuration.atmosphere.output_log << "CURRENTRY EXTERNAL INPUT IS NOT SUPPORTED" << std::endl;
			}
		}
		else
		{
			for(int i = 0; i < n_layer; i ++)
			{
				if(configuration.atmosphere.unit_dim_number_density.value() == UnitDim::NumberDensity)
				{
					model.number_density[i] = configuration.atmosphere.number_density_profile[i][1] * scaleUnit(configuration.atmosphere.number_density_unit[1].value(), "m-3");
				}
				else if(configuration.atmosphere.unit_dim_number_density.value() == UnitDim::ColumnNumberDensity)
				{
					model.number_density[i] = configuration.atmosphere.number_density_profile[i][1] * scaleUnit(configuration.atmosphere.number_density_unit[1].value(), "m-2") / (model.altitude_top[i] - model.altitude_bottom[i]);
				}
			}
		}
	}

	model.enable_atmospheric_emission = configuration.simulation.enable_atmospheric_emission.value();

	model.species = buildSpecies_(configuration, model, spectral);

	bool is_hitran = false;

	for(int i = 0; i < model.species.size(); ++i)
	{
		if(model.species[i].is_hitran)
		{
			is_hitran = true;
			break;
		}
	}

	if(is_hitran)
	{
		std::vector<std::string> dil_species = {"AIR", "CO2", "H2", "HE", "H2O"};
		std::vector<double> dil_ratio(5, 0.0);

		for(int i = 0; i < configuration.atmosphere.diluent_species.size(); ++i)
		{
			std::string dil_sp = toUpper(configuration.atmosphere.diluent_species[i]);
			
			for(int j = 0; j < dil_species.size(); ++j)
			{
				if(dil_sp == dil_species[j])
				{
					dil_ratio[j] = configuration.atmosphere.diluent_ratio[i];
					break;
				}
			}
			
			model.diluent.air = dil_ratio[0];
			model.diluent.CO2 = dil_ratio[1];
			model.diluent.H2 = dil_ratio[2];
			model.diluent.He = dil_ratio[3];
			model.diluent.H2O = dil_ratio[4];
		}
	}

	return model;
}

inline Geometry ModelBuilder::buildGeometry(const Configuration& configuration)
{
	Geometry geometry;
	
	geometry.Ntheta = configuration.geometry.n_theta.value();
	// geometry.Nphi = configuration.n_phi;
	// geometry.M = configuration.n_mode;

	if(configuration.geometry.grid_type == GridType::Regular)
	{
		if(geometry.Ntheta % 2 == 0)
		{
			geometry.Ntheta ++;
		}
	}

	if(configuration.geometry.n_mode.has_value() && !configuration.geometry.n_phi.has_value())
	{
		geometry.M = configuration.geometry.n_mode.value();
		geometry.Nphi = geometry.M * 2 + 3;
	}
	else if(configuration.geometry.n_phi.has_value() && !configuration.geometry.n_mode.has_value())
	{
		geometry.Nphi = configuration.geometry.n_phi.value();

		if(geometry.Nphi % 2 == 0)
		{
			geometry.Nphi ++;
		}
		
		geometry.M = (geometry.Nphi - 3) / 2;
	}
	else if(!configuration.geometry.n_phi.has_value() && !configuration.geometry.n_mode.has_value())
	{
		geometry.Nphi = geometry.Ntheta * 4 + 1;
		geometry.M = (geometry.Nphi - 3) / 2;
	}

	geometry.phi = Eigen::VectorXd::Zero(geometry.Nphi);
	geometry.d_phi = 2.0 * PI / double(geometry.Nphi);

	for(int i = 0; i < geometry.Nphi; i ++)
	{
		geometry.phi(i) = double(i) * geometry.d_phi;
	}

	geometry.theta_uh = Eigen::VectorXd::Zero(geometry.Ntheta);
	geometry.theta_lh = Eigen::VectorXd::Zero(geometry.Ntheta);
	geometry.theta_all = Eigen::VectorXd::Zero(geometry.Ntheta * 2);
	geometry.mu_uh = Eigen::VectorXd::Zero(geometry.Ntheta);
	geometry.mu_lh = Eigen::VectorXd::Zero(geometry.Ntheta);
	geometry.weight_uh = Eigen::VectorXd::Zero(geometry.Ntheta);
	geometry.weight_lh = Eigen::VectorXd::Zero(geometry.Ntheta);

	geometry.WMU_uh = Eigen::MatrixXd::Zero(geometry.Ntheta, geometry.Ntheta);
	geometry.WMU_lh = Eigen::MatrixXd::Zero(geometry.Ntheta, geometry.Ntheta);

	if(configuration.geometry.grid_type == GridType::Regular)
	{
		double eps = PI / 2.0 / double(geometry.Ntheta - 1) * 1.0E-3;
		double dtheta = (PI / 2.0 - eps) / double(geometry.Ntheta - 1);

		// #pragma omp parallel for
		for(int i = 0; i < geometry.Ntheta; i ++)
		{	
			geometry.theta_uh(i) = 0.0 + dtheta * double(i);
			geometry.theta_lh(i) = PI - dtheta * double(i);
			geometry.mu_uh(i) = std::abs(std::cos(geometry.theta_uh(i)));
			geometry.mu_lh(i) = std::abs(std::cos(geometry.theta_lh(i)));

			geometry.theta_all(i) = geometry.theta_uh(i);
			geometry.theta_all(geometry.Ntheta * 2 - 1 - i) = geometry.theta_lh(i);
		}

		// #pragma omp parallel for
		for(int i = 0; i < geometry.Ntheta; i ++)
		{
			if(i <= geometry.Ntheta - 3)
			{
				if(i == 0 || i == geometry.Ntheta - 3)
				{
					geometry.weight_uh(i) = 1.0 / 3.0 * dtheta * std::sin(geometry.theta_uh(i));
					geometry.weight_lh(i) = 1.0 / 3.0 * dtheta * std::sin(geometry.theta_lh(i));
				}
				else if(i % 2 == 1)
				{
					geometry.weight_uh(i) = 4.0 / 3.0 * dtheta * std::sin(geometry.theta_uh(i));
					geometry.weight_lh(i) = 4.0 / 3.0 * dtheta * std::sin(geometry.theta_lh(i));
				}
				else
				{
					geometry.weight_uh(i) = 2.0 / 3.0 * dtheta * std::sin(geometry.theta_uh(i));
					geometry.weight_lh(i) = 2.0 / 3.0 * dtheta * std::sin(geometry.theta_lh(i));
				}
			}

			if(i == geometry.Ntheta - 3)
			{
				geometry.weight_uh(i) += ((1.0 / (6.0 * dtheta * dtheta)) * std::pow(2.0 * dtheta + eps, 3) - (3.0 / (4.0 * dtheta)) * std::pow(2.0 * dtheta + eps, 2) + (2.0 * dtheta + eps)) * std::sin(geometry.theta_uh(i));
				geometry.weight_lh(i) += ((1.0 / (6.0 * dtheta * dtheta)) * std::pow(2.0 * dtheta + eps, 3) - (3.0 / (4.0 * dtheta)) * std::pow(2.0 * dtheta + eps, 2) + (2.0 * dtheta + eps)) * std::sin(geometry.theta_lh(i));
			}
			else if(i == geometry.Ntheta - 2)
			{
				geometry.weight_uh(i) = ((- 1.0 / (3.0 * dtheta * dtheta)) * std::pow(2.0 * dtheta + eps, 3) + (1.0 / dtheta) * std::pow(2.0 * dtheta + eps, 2)) * std::sin(geometry.theta_uh(i));
				geometry.weight_lh(i) = ((- 1.0 / (3.0 * dtheta * dtheta)) * std::pow(2.0 * dtheta + eps, 3) + (1.0 / dtheta) * std::pow(2.0 * dtheta + eps, 2)) * std::sin(geometry.theta_lh(i));
			}
			else if(i == geometry.Ntheta - 1)
			{
				geometry.weight_uh(i) = ((1.0 / (6.0 * dtheta * dtheta)) * std::pow(2.0 * dtheta + eps, 3) - (1.0 / (4.0 * dtheta)) * std::pow(2.0 * dtheta + eps, 2)) * std::sin(geometry.theta_uh(i));
				geometry.weight_lh(i) = ((1.0 / (6.0 * dtheta * dtheta)) * std::pow(2.0 * dtheta + eps, 3) - (1.0 / (4.0 * dtheta)) * std::pow(2.0 * dtheta + eps, 2)) * std::sin(geometry.theta_lh(i));
			}
		}
	}
	else if(configuration.geometry.grid_type == GridType::GaussRadau)
	{
		auto node_weight = computeGaussRadauQuadratureNodeWeight(geometry.Ntheta);

		for(int i = 0; i < node_weight.size(); i ++)
		{
			geometry.mu_uh(i) = node_weight[node_weight.size() - 1 - i][0];
			geometry.mu_lh(i) = node_weight[node_weight.size() - 1 - i][0];
			geometry.theta_uh(i) = std::acos(node_weight[node_weight.size() - 1 - i][0]);
			geometry.theta_lh(i) = PI - std::acos(node_weight[node_weight.size() - 1 - i][0]);

			geometry.theta_all(i) = geometry.theta_uh(i);
			geometry.theta_all(geometry.Ntheta * 2 - 1 - i) = geometry.theta_lh(i);

			geometry.weight_uh(i) = node_weight[node_weight.size() - 1 - i][1];
			geometry.weight_lh(i) = node_weight[node_weight.size() - 1 - i][1];
		}
	}

	// #pragma omp parallel for
	for(int i = 0; i < geometry.Ntheta; i ++)
	{
		geometry.WMU_uh(i, i) = geometry.weight_uh(i) * geometry.mu_uh(i);
		geometry.WMU_lh(i, i) = geometry.weight_lh(i) * geometry.mu_lh(i);
	}

	return geometry;
}

inline SpectralInformation ModelBuilder::buildSpectral(const Configuration& configuration)
{
	SpectralInformation spectral;
	
	spectral.spectral_dimension = configuration.spectral_coordinate.spectral_coordinate_dimension.value();

	//monochrome, spectrum, bandpass
	if(configuration.spectral_coordinate.spectral_coordinate_type.value() == SpectralCoordinateType::Monochrome)
	{
		spectral.spectral_coordinate_type = SpectralCoordinateType::Monochrome;
		
		spectral.spectral_grid = {configuration.spectral_coordinate.mono.value() * getUnitInfo(configuration.spectral_coordinate.unit.value()).to_si};
	}
	else if(configuration.spectral_coordinate.spectral_coordinate_type.value() == SpectralCoordinateType::Spectrum)
	{
		spectral.spectral_coordinate_type = SpectralCoordinateType::Spectrum;

		if(configuration.instrument.convolution_kernel_type.value() == InstrumentFunctionType::Delta)
		{
			spectral.convolution_kernel = {1.0};

			if(configuration.spectral_coordinate.n_spectral.has_value())
			{
				double scale = getUnitInfo(configuration.spectral_coordinate.unit.value()).to_si;

				double min = configuration.spectral_coordinate.min.value() * scale;
				double max = configuration.spectral_coordinate.max.value() * scale;
				int n_spec = configuration.spectral_coordinate.n_spectral.value();
				double d_spec = (max - min) / static_cast<double>(n_spec - 1);
				spectral.spectral_grid.resize(n_spec);
				
				for(int i = 0; i < n_spec; ++i)
				{
					spectral.spectral_grid[i] = min + d_spec * static_cast<double>(i);
				}
			}
			else
			{
				double scale = getUnitInfo(configuration.spectral_coordinate.unit.value()).to_si;

				double min = configuration.spectral_coordinate.min.value() * scale;
				double max = configuration.spectral_coordinate.max.value() * scale;

				double d_spec = configuration.spectral_coordinate.increment.value() * scale;
				int n_spec = static_cast<int>((max - min) / d_spec);
				spectral.spectral_grid.resize(n_spec);

				for(int i = 0; i < n_spec; ++i)
				{
					spectral.spectral_grid[i] = min + d_spec * static_cast<double>(i);
				}
			}
		}
		else if(configuration.instrument.convolution_kernel_type.value() == InstrumentFunctionType::Rectangle)
		{
			// パディングが必要
			double scale = getUnitInfo(configuration.spectral_coordinate.unit.value()).to_si;
			double min = configuration.spectral_coordinate.min.value() * scale;
			double max = configuration.spectral_coordinate.max.value() * scale;
			double width = configuration.instrument.kernel_width.value() * scale;

			int osc = configuration.instrument.over_sampling_count.value() % 2 == 0 ? configuration.instrument.over_sampling_count.value() + 1 : configuration.instrument.over_sampling_count.value();
			// ここでカーネルとspectralグリッドを生成
			double d_spec = width / static_cast<double>(osc - 1);
			int n_spec = static_cast<int>((max - min) / d_spec);
			spectral.spectral_grid.resize(n_spec + (osc - 1));
			

			for(int i = 0; i < n_spec + (osc - 1); ++i)
			{
				spectral.spectral_grid[i] = min + static_cast<double>(i - osc / 2) * d_spec;
			}

			spectral.convolution_kernel = generateRectangularKernel(osc);
		}
		else if(configuration.instrument.convolution_kernel_type.value() == InstrumentFunctionType::Gauss)
		{
			double scale = getUnitInfo(configuration.spectral_coordinate.unit.value()).to_si;
			double min = configuration.spectral_coordinate.min.value() * scale;
			double max = configuration.spectral_coordinate.max.value() * scale;
			double sigma = configuration.instrument.kernel_sigma.value() * scale;
			double cut_off_sigma = configuration.instrument.kernel_cut_off_sigma.value();
			int osc = configuration.instrument.over_sampling_count.value() % 2 == 0 ? configuration.instrument.over_sampling_count.value() + 1 : configuration.instrument.over_sampling_count.value();
			double d_spec = 2.0 * cut_off_sigma * sigma / static_cast<double>(osc - 1);
			int n_spec = static_cast<int>((max - min) / d_spec);
			spectral.spectral_grid.resize(n_spec + (osc - 1));
			
			for(int i = 0; i < n_spec + (osc - 1); ++i)
			{
				spectral.spectral_grid[i] = min + static_cast<double>(i - osc / 2) * d_spec;
			}

			spectral.convolution_kernel = generateGaussianKernel(sigma, osc, cut_off_sigma);
		}
	}
	else if(configuration.spectral_coordinate.spectral_coordinate_type.value() == SpectralCoordinateType::Bandpass)
	{
		spectral.spectral_coordinate_type = SpectralCoordinateType::Bandpass;

		if(configuration.instrument.filter_function_type.value() == InstrumentFunctionType::Delta)
		{
			double scale = getUnitInfo(configuration.spectral_coordinate.unit.value()).to_si;
			double center = configuration.instrument.filter_center.value() * scale;
			spectral.spectral_grid = {center};
			spectral.filter_function = {1.0};
			spectral.filter_weight = {1.0};

		}
		else if(configuration.instrument.filter_function_type.value() == InstrumentFunctionType::Rectangle)
		{
			double scale = getUnitInfo(configuration.spectral_coordinate.unit.value()).to_si;
			double center = configuration.instrument.filter_center.value() * scale;
			double width = configuration.instrument.filter_width.value() * scale;
			
			auto grid = generateSpectralGridRectangular(configuration.instrument.sampling_count.value(), center, width);

			spectral.spectral_grid = grid[0];
			spectral.filter_function = grid[1];
			spectral.filter_weight = grid[2];
		}
		else if(configuration.instrument.filter_function_type.value() == InstrumentFunctionType::Gauss)
		{
			double scale = getUnitInfo(configuration.spectral_coordinate.unit.value()).to_si;
			double center = configuration.instrument.filter_center.value() * scale;
			double sigma = configuration.instrument.filter_sigma.value() * scale;
			
			auto grid = generateSpectralGridGaussian(configuration.instrument.sampling_count.value(), center, sigma);

			spectral.spectral_grid = grid[0];
			spectral.filter_function = grid[1];
			spectral.filter_weight = grid[2];
		}
		else if(configuration.instrument.filter_function_type.value() == InstrumentFunctionType::External)
		{
			if(spectral.spectral_dimension == SpectralCoordinateDimension::Wavelength)
			{
				auto loaded_data = loadSpectralFile(configuration.instrument.filename_filter_function.value(), configuration.instrument.varname_spectral.value(), configuration.instrument.varname_transmittance.value(), "m", "dimensionless");
				auto grid = generateSpectralGridBandpass(configuration.instrument.sampling_count.value(), loaded_data);
				spectral.spectral_grid = grid[0];
				spectral.filter_function = grid[1];
				spectral.filter_weight = grid[2];
			}
			else if(spectral.spectral_dimension == SpectralCoordinateDimension::Wavenumber)
			{
				auto loaded_data = loadSpectralFile(configuration.instrument.filename_filter_function.value(), configuration.instrument.varname_spectral.value(), configuration.instrument.varname_transmittance.value(), "m-1", "dimensionless");
				auto grid = generateSpectralGridBandpass(configuration.instrument.sampling_count.value(), loaded_data);
				spectral.spectral_grid = grid[0];
				spectral.filter_function = grid[1];
				spectral.filter_weight = grid[2];
			}
		}
	}
	
	return spectral;
}

inline DeltaApproximation ModelBuilder::buildDeltaApproximation(const Configuration& configuration)
{
	DeltaApproximation delta_approximation;

	delta_approximation.delta_approximation_type = configuration.delta_m.delta_approximation_type.value();
	delta_approximation.icss_type = configuration.delta_m.icss_type.value();
	delta_approximation.n_icss_sample = configuration.delta_m.n_icss_sample.value();
	delta_approximation.fwhm_ratio = configuration.delta_m.fwhm_ratio.value();
	delta_approximation.f_target = configuration.delta_m.f_target.value();

	return delta_approximation;
}

inline std::vector<double> generateGaussianKernel(double sigma, int sampling_count, double cut_off_sigma = 3.0)
{
	if (sigma <= 0.0)
	{
		throw std::runtime_error("Sigma must be positive.");
	}
	if ( sampling_count <= 1)
	{
		throw std::runtime_error("Total samples must be greater than 1.");
	}
	if (sampling_count % 2 == 0)
	{
		throw std::runtime_error("Total samples must be odd.");
	}

	double step = 2.0 * cut_off_sigma * sigma / static_cast<double>(sampling_count - 1);

	int half_width_n = (sampling_count - 1) / 2;
	std::vector<double> kernel(sampling_count);

	double sum = 0.0;
	double two_sigma_sq = 2.0 * sigma * sigma;

	for (int i = 0; i < sampling_count; ++i)
	{
		double x = (static_cast<double>(i) - static_cast<double>(half_width_n)) * step;
		
		double val = std::exp(-(x * x) / two_sigma_sq);
		
		kernel[i] = val;
		sum += val;
	}

	for (double& v : kernel)
	{
		v /= sum;
	}

	return kernel;
}

inline std::vector<double> generateRectangularKernel(int sampling_count)
{
	if ( sampling_count <= 1)
	{
		throw std::runtime_error("Total samples must be greater than 1.");
	}

	if (sampling_count % 2 == 0)
	{
		throw std::runtime_error("Total samples must be odd.");
	}

	std::vector<double> kernel(sampling_count, 1.0 / static_cast<double>(sampling_count));

	return kernel;
}

inline std::vector<std::vector<std::vector<double>>> generateLogNormalSizeDistribution(int n_r, double r_g, double sigma_g)
{
	std::vector<std::vector<double>> size_distribution(n_r, std::vector<double>(2));
	std::vector<std::vector<double>> weight(n_r, std::vector<double>(2));

	if (n_r <= 0 || r_g <= 0.0 || sigma_g <= 0.0)
	{
		if (sigma_g <= 0.0)
		{
			throw std::runtime_error("[generateLogNormalSizeDistribution] sigma_g must be positive.");
		}
	}

	std::vector<std::vector<double>> node_weight_hermite = computeGaussHermiteQuadratureNodeWeight(n_r);
	
	double ln_rg = std::log(r_g);
	double sigma_ln = sigma_g;
	
	double sqrt_2_sigma_ln = std::sqrt(2.0) * sigma_ln;

	double weight_prefactor = 1.0 / std::sqrt(PI);

	double pdf_norm_factor = 1.0 / (std::sqrt(2.0 * PI) * sigma_ln);

	for (int i = 0; i < n_r; ++i)
	{
		double u_std = node_weight_hermite[i][0];
		double w_std = node_weight_hermite[i][1];
		
		double r = std::exp(ln_rg + sqrt_2_sigma_ln * u_std);
		double ln_ratio = std::log(r / r_g); 
		
		double exponent = -(ln_ratio * ln_ratio) / (2.0 * sigma_ln * sigma_ln);

		size_distribution[i][0] = r;
		weight[i][0] = r; 
		size_distribution[i][1] = (pdf_norm_factor / r) * std::exp(exponent);
		weight[i][1] = w_std * weight_prefactor;
	}

	return {size_distribution, weight};
}

inline std::vector<std::vector<std::vector<double>>> generateRectangularSizeDistribution(int n_r, double r_mean, double width)
{
	std::vector<std::vector<double>> size_distribution(n_r, std::vector<double>(2));
	std::vector<std::vector<double>> weight(n_r, std::vector<double>(2));

	if (n_r <= 0 || width <= 0.0)
	{
		throw std::runtime_error("[generateRectangularSizeDistribution] Invalid input parameters (n_r <= 0 or width <= 0).");
	}

	double r_min = r_mean - 0.5 * width;
	double r_max = r_mean + 0.5 * width;

	if (r_min < 0.0)
	{
		throw std::runtime_error("[generateRectangularSizeDistribution] Rectangular distribution extends to negative radius (r_min < 0). Adjust r_mean or width.");
	}

	std::vector<std::vector<double>> node_weight_std = computeGaussLegendreQuadratureNodeWeight(n_r);
	
	double n_r_val = 1.0 / (r_max - r_min); 

	for (int i = 0; i < n_r; ++i)
	{
		double x_std = node_weight_std[i][0];
		double w_std = node_weight_std[i][1];

		double r = 0.5 * (r_max - r_min) * x_std + 0.5 * (r_max + r_min);

		size_distribution[i][0] = r;
		weight[i][0] = r;
		size_distribution[i][1] = n_r_val;
		weight[i][1] = w_std * 0.5;
	}

	return {size_distribution, weight};
}

inline std::vector<std::vector<std::vector<double>>> generateGammaSizeDistribution(int n_r, double a, double b)
{
	std::vector<std::vector<double>> size_distribution(n_r, std::vector<double>(2));
	std::vector<std::vector<double>> weight(n_r, std::vector<double>(2));

	if (n_r <= 0 || a <= 0.0 || b <= 0.0)
	{
		throw std::runtime_error("[generateGammaSizeDistribution] Parameters a and b must be positive.");
	}
	
	if ((1 - b) / b <= 0.0)
	{
		throw std::runtime_error("[generateGammaSizeDistribution] (1 - 2b) / b must be positive for convergence. Check parameter b.");
	}

	std::vector<std::vector<double>> node_weight_laguerre = computeGaussLaguerreQuadratureNodeWeight(n_r);
	
	double norm_const = 1.0 / (a * b * std::tgamma((1.0 - 2.0 * b) / b));

	for (int i = 0; i < n_r; ++i)
	{
		double x_laguerre = node_weight_laguerre[i][0];
		double w_laguerre = node_weight_laguerre[i][1];

		double r = a * b * x_laguerre;
		if (r < 1e-12)
		{
			r = 1e-12;
		}

		size_distribution[i][0] = r;
		weight[i][0] = r;
		size_distribution[i][1] = norm_const * std::pow(r / a / b, (1.0 - 3.0 * b) / b) * std::exp(-r / a / b);
		weight[i][1] = 1.0 / std::tgamma((1.0 - 2.0 * b) / b) * w_laguerre * std::pow(x_laguerre, (1.0 - 3.0 * b) / b);
	}

	return {size_distribution, weight};
}

inline std::vector<std::vector<std::vector<double>>> generateModifiedGammaSizeDistribution(int n_r, double r_c, double alpha, double gamma)
{
	std::vector<std::vector<double>> size_distribution(n_r, std::vector<double>(2));
	std::vector<std::vector<double>> weight(n_r, std::vector<double>(2));

	if (n_r <= 0 || r_c <= 0.0 || alpha <= 0.0 || gamma <= 0.0)
	{
		throw std::runtime_error("[generateModifiedGammaSizeDistribution] Parameters must be positive.");
	}
	
	std::vector<std::vector<double>> node_weight_laguerre = computeGeneralizedGaussLaguerreQuadratureNodeWeight(n_r, (alpha - gamma + 1.0) / gamma);
	
	double norm_const = gamma / (r_c * std::tgamma((alpha + 1.0) / gamma)) * std::pow(alpha / gamma, (alpha + 1) / gamma);
	
	for (int i = 0; i < n_r; ++i)
	{
		double x_laguerre = node_weight_laguerre[i][0];
		double w_laguerre = node_weight_laguerre[i][1];

		double r;
		if (x_laguerre == 0.0)
		{
			r = 0.0;
		}
		else
		{
			r = r_c * std::pow((gamma / alpha) * x_laguerre, 1.0 / gamma);
		}
		
		if (r < 1e-12)
		{
			r = 1e-12;
		}

		size_distribution[i][0] = r;
		weight[i][0] = r;
		size_distribution[i][1] = norm_const * std::pow(r / r_c, alpha) * std::exp(-alpha / gamma * std::pow(r / r_c, gamma));
		weight[i][1] = w_laguerre / std::tgamma((alpha + 1.0) / gamma);
	}

	return {size_distribution, weight};
}

inline std::vector<std::vector<std::vector<double>>> generatePowerLawSizeDistribution(int n_r, double pl_delta, double pl_r1, double pl_r2)
{
	std::vector<std::vector<double>> size_distribution(n_r, std::vector<double>(2));
	std::vector<std::vector<double>> weight(n_r, std::vector<double>(2));

	if (n_r <= 0 || pl_r1 <= 0.0 || pl_r2 <= 0.0 || pl_r1 >= pl_r2)
	{
		throw std::runtime_error("[generatePowerLawSizeDistribution] Invalid limits or parameters (r1 >= r2).");
	}

	double ln_r_min = std::log(pl_r1);
	double ln_r_max = std::log(pl_r2);

	std::vector<std::vector<double>> node_weight_std = computeGaussLegendreQuadratureNodeWeight(n_r);
	
	double diff = ln_r_max - ln_r_min;
	double sum_limits = ln_r_max + ln_r_min;
	double jacobian = 0.5 * diff;
	
	double c;
	if (std::abs(pl_delta - 1.0) < 1e-9)
	{
		c = 1.0 / diff;
	}
	else
	{
		double term_nu = 1.0 - pl_delta;
		c = term_nu / (std::pow(pl_r2, term_nu) - std::pow(pl_r1, term_nu));
	}

	for (int i = 0; i < n_r; ++i)
	{
		double x_std = node_weight_std[i][0];
		double w_std = node_weight_std[i][1];

		double ln_r = 0.5 * diff * x_std + 0.5 * sum_limits;
		double r = std::exp(ln_r);

		double n_r_val = c * std::pow(r, -pl_delta);
		double dr = r * w_std * jacobian;
		
		size_distribution[i][0] = r;
		weight[i][0] = r;
		size_distribution[i][1] = n_r_val;
		weight[i][1] = n_r_val * dr;
	}

	return {size_distribution, weight};
}

inline std::vector<std::vector<double>> loadSpectralFile(std::string filename, std::string var_name_spectral, std::string var_name_value, std::string unit_target_spectral, std::string unit_target_value)
{
	try
	{
		netCDF::NcFile dataFile(filename, netCDF::NcFile::read);

		auto getVarSafe = [&](std::string name) -> netCDF::NcVar
		{
			netCDF::NcVar var = dataFile.getVar(name);
			if(var.isNull())
			{
				throw std::runtime_error("NetCDF Variable '" + name + "' not found in " + filename);
			}
			return var;
		};

		netCDF::NcVar v_spec = getVarSafe(var_name_spectral);
		netCDF::NcVar v_value = getVarSafe(var_name_value);

		size_t n_data = v_spec.getDim(0).getSize();

		// 単位変換
		std::string source_unit_spec;
		try
		{
			netCDF::NcVarAtt att = v_spec.getAtt("units");
			if(!att.isNull()) att.getValues(source_unit_spec);
		}
		catch(...)
		{
			std::cout << "[Warning] 'units' missing for " << var_name_spectral << ". Assuming " << unit_target_spectral << "." << std::endl;
			source_unit_spec = unit_target_spectral;
		}

		std::string source_unit_value;
		try
		{
			netCDF::NcVarAtt att = v_value.getAtt("units");
			if(!att.isNull()) att.getValues(source_unit_value);
		}
		catch(...)
		{
			std::cout << "[Warning] 'units' missing for " << var_name_value << ". Assuming " << unit_target_value << "." << std::endl;
			source_unit_value = unit_target_value;
		}

		// double scale_spec = scaleUnit(source_unit_spec, unit_target_spectral);

		// データ読み込み
		std::vector<double> buf_spec(n_data);
		std::vector<double> buf_value(n_data);

		v_spec.getVar(buf_spec.data());
		v_value.getVar(buf_value.data());

		bool is_spectral_dimension_mismatch;
		double scale_spec;

		if(getUnitInfo(unit_target_spectral).dim != getUnitInfo(source_unit_spec).dim)
		{
			is_spectral_dimension_mismatch = true;
			scale_spec = 1.0 / (getUnitInfo(source_unit_spec).to_si * getUnitInfo(unit_target_spectral).to_si);
		}
		else
		{
			is_spectral_dimension_mismatch = false;
			scale_spec = scaleUnit(source_unit_spec, unit_target_spectral);
		}

		double scale_value = scaleUnit(source_unit_value, unit_target_value);

		// 戻り値の構築 {{spec, nr, ni}, ...}
		std::vector<std::vector<double>> result(n_data);
		for(size_t i = 0; i < n_data; ++i)
		{
			if(is_spectral_dimension_mismatch == true)
			{
				result[i] = {1.0 / buf_spec[i] * scale_spec, buf_value[i] * scale_value};
			}
			else
			{
				result[i] = {buf_spec[i] * scale_spec, buf_value[i] * scale_value};
			}
		}

		std::sort(result.begin(), result.end(), [](const auto& a, const auto& b){return a[0] < b[0];});

		return result;
	}
	catch(const netCDF::exceptions::NcException& e)
	{
		throw std::runtime_error("NetCDF Error in " + filename + ": " + std::string(e.what()));
	}
}

inline std::vector<std::vector<double>> loadRefractiveIndexSpectralFile(std::string filename, std::string var_name_spectral, std::string var_name_nr, std::string var_name_ni, std::string unit_target_spectral)
{
	try
	{
		netCDF::NcFile dataFile(filename, netCDF::NcFile::read);

		auto getVarSafe = [&](std::string name) -> netCDF::NcVar
		{
			netCDF::NcVar var = dataFile.getVar(name);
			if(var.isNull())
			{
				throw std::runtime_error("NetCDF Variable '" + name + "' not found in " + filename);
			}
			return var;
		};

		netCDF::NcVar v_spec = getVarSafe(var_name_spectral);
		netCDF::NcVar v_nr = getVarSafe(var_name_nr);
		netCDF::NcVar v_ni = getVarSafe(var_name_ni);

		size_t n_data = v_spec.getDim(0).getSize();
		
		// 次元整合性チェック
		if (v_nr.getDim(0).getSize() != n_data || v_ni.getDim(0).getSize() != n_data)
		{
			throw std::runtime_error("Dimension size mismatch in refractive index file.");
		}

		// 単位変換 (屈折率は無次元なので、スペクトルのみ計算)
		std::string source_unit_spec;
		try
		{
			netCDF::NcVarAtt att = v_spec.getAtt("units");
			if(!att.isNull()) att.getValues(source_unit_spec);
		}
		catch(...)
		{
			std::cout << "[Warning] 'units' missing for " << var_name_spectral << ". Assuming " << unit_target_spectral << "." << std::endl;
			source_unit_spec = unit_target_spectral;
		}

		// double scale_spec = scaleUnit(source_unit_spec, unit_target_spectral);

		// データ読み込み
		std::vector<double> buf_spec(n_data);
		std::vector<double> buf_nr(n_data);
		std::vector<double> buf_ni(n_data);

		v_spec.getVar(buf_spec.data());
		v_nr.getVar(buf_nr.data());
		v_ni.getVar(buf_ni.data());

		bool is_spectral_dimension_mismatch;
		double scale_unit;

		if(getUnitInfo(unit_target_spectral).dim != getUnitInfo(source_unit_spec).dim)
		{
			is_spectral_dimension_mismatch = true;
			scale_unit = 1.0 / (getUnitInfo(source_unit_spec).to_si * getUnitInfo(unit_target_spectral).to_si);
		}
		else
		{
			is_spectral_dimension_mismatch = false;
			scale_unit = scaleUnit(source_unit_spec, unit_target_spectral);
		}

		// 戻り値の構築 {{spec, nr, ni}, ...}
		std::vector<std::vector<double>> result(n_data);
		for(size_t i = 0; i < n_data; ++i)
		{
			if(is_spectral_dimension_mismatch == true)
			{
				result[i] = {1.0 / buf_spec[i] * scale_unit, buf_nr[i], buf_ni[i]};
			}
			else
			{
				result[i] = {buf_spec[i] * scale_unit, buf_nr[i], buf_ni[i]};
			}
		}

		std::sort(result.begin(), result.end(), [](const auto& a, const auto& b){return a[0] < b[0];});

		return result;
	}
	catch(const netCDF::exceptions::NcException& e)
	{
		throw std::runtime_error("NetCDF Error in " + filename + ": " + std::string(e.what()));
	}
}

inline std::vector<std::vector<std::vector<double>>> loadRefractiveIndexSpectralVerticalFile(std::string filename, std::string var_name_altitude, std::string var_name_spectral, std::string var_name_nr, std::string var_name_ni, std::string unit_target_altitude, std::string unit_target_spectral)
{
	try
	{
		netCDF::NcFile dataFile(filename, netCDF::NcFile::read);

		// ヘルパー: 変数取得と存在チェック
		auto getVarSafe = [&](std::string name) -> netCDF::NcVar
		{
			netCDF::NcVar var = dataFile.getVar(name);
			if(var.isNull())
			{
				throw std::runtime_error("NetCDF Variable '" + name + "' not found in " + filename);
			}
			return var;
		};

		// 1. 変数オブジェクトの取得
		netCDF::NcVar v_alt = getVarSafe(var_name_altitude);
		netCDF::NcVar v_spec = getVarSafe(var_name_spectral);
		netCDF::NcVar v_nr = getVarSafe(var_name_nr);
		netCDF::NcVar v_ni = getVarSafe(var_name_ni);

		// 2. 次元の取得 (変数の次元を参照する)
		// ※変数名と次元名が異なっていても対応できるように getDim(0) を使用
		size_t n_alt = v_alt.getDim(0).getSize();
		size_t n_spec = v_spec.getDim(0).getSize();

		// 2Dデータの次元チェック (念のため)
		if (v_nr.getDimCount() != 2 || v_ni.getDimCount() != 2)
		{
			throw std::runtime_error("Refractive index variables (nr, ni) must be 2D [altitude, spectral].");
		}

		// 3. 単位変換係数の計算
		// (NetCDFの "units" 属性を読み、ターゲット単位との比率を計算)

		// 単位変換
		std::string source_unit_spec;
		try
		{
			netCDF::NcVarAtt att = v_spec.getAtt("units");
			if(!att.isNull()) att.getValues(source_unit_spec);
		}
		catch(...)
		{
			std::cout << "[Warning] 'units' missing for " << var_name_spectral << ". Assuming " << unit_target_spectral << "." << std::endl;
			source_unit_spec = unit_target_spectral;
		}

		std::string source_unit_alt;
		try
		{
			netCDF::NcVarAtt att = v_alt.getAtt("units");
			if(!att.isNull()) att.getValues(source_unit_alt);
		}
		catch(...)
		{
			std::cout << "[Warning] 'units' missing for " << var_name_altitude << ". Assuming " << unit_target_altitude << "." << std::endl;
			source_unit_alt = unit_target_altitude;
		}

		bool is_spectral_dimension_mismatch;
		double scale_spec;

		if(getUnitInfo(unit_target_spectral).dim != getUnitInfo(source_unit_spec).dim)
		{
			is_spectral_dimension_mismatch = true;
			scale_spec = 1.0 / (getUnitInfo(source_unit_spec).to_si * getUnitInfo(unit_target_spectral).to_si);
		}
		else
		{
			is_spectral_dimension_mismatch = false;
			scale_spec = scaleUnit(source_unit_spec, unit_target_spectral);
		}

		double scale_alt = scaleUnit(source_unit_alt, unit_target_altitude);

		// 4. データの読み込み & スケーリング
		std::vector<double> altitudes(n_alt);
		v_alt.getVar(altitudes.data());
		for(auto& v : altitudes)
		{
			v *= scale_alt; // 単位変換
		}

		std::vector<double> spectral_grid(n_spec);
		v_spec.getVar(spectral_grid.data());
		for(auto& v : spectral_grid)
		{
			if(is_spectral_dimension_mismatch == true)
			{
				v = 1.0 / v * scale_spec; // 単位変換
			}
			else
			{
				v = v * scale_spec; // 単位変換
			}
		}

		// 5. 2Dデータの読み込み
		// NetCDF C++ はフラットな1次元配列に読み込む (順序: dim0(alt) -> dim1(spec))
		std::vector<double> buffer_nr(n_alt * n_spec);
		std::vector<double> buffer_ni(n_alt * n_spec);

		v_nr.getVar(buffer_nr.data());
		v_ni.getVar(buffer_ni.data());

		// 6. 戻り値の形式に整形
		// [Layer][Spec][Alt, Wl, Nr, Ni]
		std::vector<std::vector<std::vector<double>>> result(n_alt);

		// 高度方向のループ
		for(size_t i = 0; i < n_alt; ++i)
		{
			result[i].resize(n_spec);
			double current_alt = altitudes[i];

			// スペクトル方向のループ
			for(size_t k = 0; k < n_spec; ++k)
			{
				size_t idx = i * n_spec + k; // フラットインデックス
				
				result[i][k] = {current_alt, spectral_grid[k], buffer_nr[idx], buffer_ni[idx]};
			}

			std::sort(result[i].begin(), result[i].end(), [](const std::vector<double>& a, const std::vector<double>& b){return a[1] < b[1];});
		}

		std::sort(result.begin(), result.end(), [](const std::vector<std::vector<double>>& a, const std::vector<std::vector<double>>& b){return a[0][0] < b[0][0];});

		return result;
	}
	catch(const netCDF::exceptions::NcException& e)
	{
		throw std::runtime_error("NetCDF Error in " + filename + ": " + std::string(e.what()));
	}
}

inline std::vector<std::vector<double>> generateSpectralGridBandpass(int n_sample, std::vector<std::vector<double>> filter_data, double cutoff_ratio = 1.0E-3)
{
	std::vector<double> spectral_grid;
	std::vector<double> filter_function;
	std::vector<double> weight;

	// 1. 最大感度の探索
	double max_resp = 0.0;
	for(const auto& row : filter_data)
	{
		if (row[1] > max_resp) max_resp = row[1];
	}

	// フィルタが無効（全部ゼロ）な場合のチェック
	if (max_resp <= 0.0)
	{
		throw std::runtime_error("Filter response is invalid (max response is 0).");
	}

	// 2. 閾値の設定 (例: 0.1%)
	// これ以下の感度は、放射計算結果に寄与しないとみなして無視する
	// constexpr double CUTOFF_RATIO = 1.0e-3; 
	double threshold = max_resp * cutoff_ratio;

	// 3. 有効範囲の検出
	double valid_min = std::numeric_limits<double>::max();
	double valid_max = -std::numeric_limits<double>::max();

	bool found_peak_start = false; // ピークに入ったか？
	bool found_peak_end = false;   // ピークを抜けたか？

	for(size_t i = 0; i < filter_data.size(); ++i)
	{
		// 閾値を超えている点のみを「有効」とみなす
		if (filter_data[i][1] >= threshold)
		{
			if (found_peak_end)
			{
				throw std::runtime_error("The filter has separate passbands or significant side-lobes.");
			}
			
			if (filter_data[i][0] < valid_min) valid_min = filter_data[i][0];
			if (filter_data[i][0] > valid_max) valid_max = filter_data[i][0];

			found_peak_start = true;
		}
		else
		{
			if (found_peak_start)
			{
				// ピークの中にいたのに、閾値を下回った -> ピーク終了
				found_peak_end = true;
			}
		}
	}

	// 範囲が見つからなかった場合（あり得ないはずだが念のため）
	if (valid_min >= valid_max)
	{
		// ピーク付近の狭い範囲だけでも確保する、あるいはエラーにする
		// ここではエラーにする
		throw std::runtime_error("Could not determine valid filter range. Check filter data or threshold.");
	}

	// 4. 計算グリッドの生成
	auto gauss_node = computeGaussLegendreQuadratureNodeWeight(n_sample);

	spectral_grid.resize(n_sample);
	filter_function.resize(n_sample);
	weight.resize(n_sample);

	for(int i = 0; i < n_sample; ++i)
	{
		double x = 0.5 * (valid_max - valid_min) * gauss_node[i][0] + 0.5 * (valid_max + valid_min);

		spectral_grid[i] = x;
		double filter = interpolateTableLinear(x, filter_data)[0];
		filter_function[i] = filter;
		weight[i] = gauss_node[i][1] * filter * 0.5 * (valid_max - valid_min);
	}

	return {spectral_grid, filter_function, weight};
}

inline std::vector<std::vector<double>> generateSpectralGridRectangular(int n_sample, double center, double width)
{
	double min = center - 0.5 * width;
	double max = center + 0.5 * width;

	auto gauss_node = computeGaussLegendreQuadratureNodeWeight(n_sample);

	std::vector<double> spectral_grid(n_sample);
	std::vector<double> filter_function(n_sample);
	std::vector<double> weight(n_sample);

	for(int i = 0; i < n_sample; ++i)
	{
		spectral_grid[i] = 0.5 * (max - min) * gauss_node[i][0] + 0.5 * (max + min);
		filter_function[i] = 1.0;
		weight[i] = gauss_node[i][1] * 1.0 * 0.5 * (max - min);
	}

	return {spectral_grid, filter_function, weight};
}

inline std::vector<std::vector<double>> generateSpectralGridGaussian(int n_sample, double center, double sigma)
{
	auto gauss_node = computeGaussHermiteQuadratureNodeWeight(n_sample);

	std::vector<double> spectral_grid(n_sample);
	std::vector<double> filter_function(n_sample);
	std::vector<double> weight(n_sample);

	for(int i = 0; i < n_sample; ++i)
	{
		spectral_grid[i] = std::sqrt(2.0) * sigma * gauss_node[i][0] + center;

		if(spectral_grid[i] <= 0.0)
		{
			spectral_grid[i] = 1.0E-12;
		}

		filter_function[i] = 1.0 / (std::sqrt(2.0 * PI) * sigma) * std::exp(-(spectral_grid[i] - center) * (spectral_grid[i] - center) / (2.0 * sigma * sigma));
		weight[i] = gauss_node[i][1] / std::sqrt(PI);
	}

	return {spectral_grid, filter_function, weight};
}

inline double computePhaseFunction(const std::vector<std::vector<double>>& f, double scattering_angle)
{
	double theta_min = f[0][0];
	double theta_max = f[f.size() - 1][0];
	double dtheta = std::abs(f[1][0] - f[0][0]);

	int ntheta = (scattering_angle - theta_min) / dtheta;
	double result;

	if(ntheta == f.size() - 1)
	{
		result = f[ntheta][1];
	}
	else if(ntheta == 0)
	{
		result = f[0][1];
	}
	else
	{
		result = (f[ntheta][1] * (f[ntheta + 1][0] - scattering_angle) + f[ntheta + 1][1] * (scattering_angle - f[ntheta][0])) / (f[ntheta + 1][0] - f[ntheta][0]);
	}
	
	return result;
}

inline std::vector<std::vector<double>> computeIsotropicScatteringFunction(int ntheta)
{
	if(ntheta % 2 == 0)
	{
		ntheta ++;
	}

	std::vector<std::vector<double>> phase_function(ntheta);

	for(int i = 0; i < ntheta; i ++)
	{
		double theta = PI * double(i) / double(ntheta - 1);
		phase_function[i] = {theta, 1.0};
	}

	return phase_function;
}

inline std::vector<std::vector<double>> computeRayleighScatteringFunction(int ntheta)
{
	if(ntheta % 2 == 0)
	{
		ntheta ++;
	}

	std::vector<std::vector<double>> phase_function(ntheta);

	for(int i = 0; i < ntheta; i ++)
	{
		double theta = PI * double(i) / double(ntheta - 1);
		phase_function[i] = {theta, 3.0 / 4.0 * (1.0 + std::cos(theta) * std::cos(theta))};
	}

	return phase_function;
}

inline std::vector<std::vector<double>> computeHGScatteringFunction(int ntheta, double g)
{
	if(ntheta % 2 == 0)
	{
		ntheta ++;
	}

	std::vector<std::vector<double>> phase_function(ntheta);

	for(int i = 0; i < ntheta; i ++)
	{
		double theta = PI * double(i) / double(ntheta - 1);
		phase_function[i] = {theta, (1.0 - g * g) / std::pow(1 + g * g - 2.0 * g * std::cos(theta), 1.5)};
	}

	return phase_function;
}

inline double computePlanckFunction(double spectral, double temperature, SpectralCoordinateDimension dimension)
{
	double B = 0.0;

	if(dimension == SpectralCoordinateDimension::Wavelength)
	{
		B = 2.0 * SPEED_OF_LIGHT * SPEED_OF_LIGHT * PLANCK_CONSTANT;
		B /= std::pow(spectral, 5);
		B /= (std::exp(PLANCK_CONSTANT *SPEED_OF_LIGHT / (spectral * BOLTZMANN_CONSTANT * temperature)) - 1.0);
		
	}
	else if(dimension == SpectralCoordinateDimension::Wavenumber)
	{
		B = 2.0 * PLANCK_CONSTANT * SPEED_OF_LIGHT * SPEED_OF_LIGHT * std::pow(spectral, 3);
		B /= (std::exp(PLANCK_CONSTANT * SPEED_OF_LIGHT * spectral / (BOLTZMANN_CONSTANT * temperature)) - 1.0);
	}

	return B; // [W/m2/sr/m] or [W/m2/sr/m-1]
}

inline double computeThermalEmission(double plank_function, double tau, double mu)
{
	// std::cout << B << ", " << tau << ", " << mu << std::endl;
	// 1 – exp(‑τ/μ)  ---  use expm1 for numerical safety when τ is very small.
	return plank_function * (-std::expm1(-tau / mu));
}

inline double computeAsymmetryParameter(const std::vector<std::vector<double>>& f)
{
	double g = 0.0;

	int n = f.size();

	double num = 0.0;
	double den = 0.0;

	// double dtheta = f[1][0] - f[0][0];

	for(int i = 0; i < n; i ++)
	{
		double theta = f[i][0];
		double mu = std::cos(theta);
		double sine = std::sin(theta);

		// std::cout << theta * 180.0 / PI << ", " << f[i][1] << std::endl;

		if(i == 0 || i == n - 1)
		{
			num += f[i][1] * mu * sine;
			den += f[i][1] * sine;
		}
		else
		{
			num += 2.0 * f[i][1] * mu * sine;
			den += 2.0 * f[i][1] * sine;
		}
	}

	g = num / den;

	return g;
}

inline RadiativeLayer RadiativeTransferSolver::initializeAtmosphericLayer_(const OpticalLayer& optical_layer)
{
	RadiativeLayer radiative_layer;

	radiative_layer.n_doubling = 0;
	radiative_layer.optical_thickness = optical_layer.optical_thickness;

	while(radiative_layer.optical_thickness > initial_optical_thickness_)
	{
		radiative_layer.optical_thickness /= 2.0;
		radiative_layer.n_doubling ++;
	}

	radiative_layer.reflectance_m_top_cos = std::vector<Eigen::MatrixXd>(geometry_.M + 1, Eigen::MatrixXd::Zero(geometry_.Ntheta, geometry_.Ntheta));
	radiative_layer.reflectance_m_bottom_cos = std::vector<Eigen::MatrixXd>(geometry_.M + 1, Eigen::MatrixXd::Zero(geometry_.Ntheta, geometry_.Ntheta));
	radiative_layer.transmittance_m_top_cos = std::vector<Eigen::MatrixXd>(geometry_.M + 1, Eigen::MatrixXd::Zero(geometry_.Ntheta, geometry_.Ntheta));
	radiative_layer.transmittance_m_bottom_cos = std::vector<Eigen::MatrixXd>(geometry_.M + 1, Eigen::MatrixXd::Zero(geometry_.Ntheta, geometry_.Ntheta));
	
	radiative_layer.reflectance_m_top_sin = std::vector<Eigen::MatrixXd>(geometry_.M + 1, Eigen::MatrixXd::Zero(geometry_.Ntheta, geometry_.Ntheta));
	radiative_layer.reflectance_m_bottom_sin = std::vector<Eigen::MatrixXd>(geometry_.M + 1, Eigen::MatrixXd::Zero(geometry_.Ntheta, geometry_.Ntheta));
	radiative_layer.transmittance_m_top_sin = std::vector<Eigen::MatrixXd>(geometry_.M + 1, Eigen::MatrixXd::Zero(geometry_.Ntheta, geometry_.Ntheta));
	radiative_layer.transmittance_m_bottom_sin = std::vector<Eigen::MatrixXd>(geometry_.M + 1, Eigen::MatrixXd::Zero(geometry_.Ntheta, geometry_.Ntheta));

	radiative_layer.source_up = Eigen::VectorXd::Zero(geometry_.Ntheta);
	radiative_layer.source_down = Eigen::VectorXd::Zero(geometry_.Ntheta);

	// delta-M approximations


	for(int e_n = 0; e_n < geometry_.Ntheta; e_n ++)
	{
		//std::cout << layer.planck_function << std::endl;
		radiative_layer.source_up(e_n) = (1.0 - optical_layer.single_scattering_albedo) * computeThermalEmission(optical_layer.planck_function, radiative_layer.optical_thickness, geometry_.mu_uh(e_n));
		radiative_layer.source_down(e_n) = (1.0 - optical_layer.single_scattering_albedo) * computeThermalEmission(optical_layer.planck_function, radiative_layer.optical_thickness, geometry_.mu_lh(e_n));
	}

	std::vector<std::vector<std::vector<double>>> reflectance_top = std::vector<std::vector<std::vector<double>>>(geometry_.Ntheta, std::vector<std::vector<double>>(geometry_.Ntheta, std::vector<double>(geometry_.Nphi)));
	std::vector<std::vector<std::vector<double>>> reflectance_bottom = std::vector<std::vector<std::vector<double>>>(geometry_.Ntheta, std::vector<std::vector<double>>(geometry_.Ntheta, std::vector<double>(geometry_.Nphi)));
	std::vector<std::vector<std::vector<double>>> transmittance_top = std::vector<std::vector<std::vector<double>>>(geometry_.Ntheta, std::vector<std::vector<double>>(geometry_.Ntheta, std::vector<double>(geometry_.Nphi)));
	std::vector<std::vector<std::vector<double>>> transmittance_bottom = std::vector<std::vector<std::vector<double>>>(geometry_.Ntheta, std::vector<std::vector<double>>(geometry_.Ntheta, std::vector<double>(geometry_.Nphi)));

	for(int e = 0; e < geometry_.Ntheta; e ++)
	{
		for(int i = 0; i < geometry_.Ntheta; i ++)
		{
			for(int p = 0; p < geometry_.Nphi; p ++)
			{
				{// for R_top
					double theta_e = geometry_.theta_uh(e);
					double theta_i = geometry_.theta_lh(i);

					double xi = std::sin(theta_i);
					double yi = 0.0;
					double zi = std::cos(theta_i);

					double xe = std::sin(theta_e) * std::cos(geometry_.phi(p));
					double ye = std::sin(theta_e) * std::sin(geometry_.phi(p));
					double ze = std::cos(theta_e);

					double inner = xi * xe + yi * ye + zi * ze;
					double scattering_angle;
					if(inner >= 1.0)
					{
						scattering_angle = 0.0;
					}
					else if(inner <= -1.0)
					{
						scattering_angle = PI;
					}
					else
					{
						scattering_angle = std::acos(inner);
					}

					if(optical_layer.single_scattering_albedo == 0.0)
					{
						reflectance_top[e][i][p] = 0.0;
					}
					else
					{
						reflectance_top[e][i][p] = optical_layer.single_scattering_albedo * radiative_layer.optical_thickness / (4.0 * geometry_.mu_lh(i) * geometry_.mu_uh(e)) * computePhaseFunction(optical_layer.scattering_phase_function, scattering_angle);
					}
				}

				{// for R_bottom
					double theta_e = geometry_.theta_lh(e);
					double theta_i = geometry_.theta_uh(i);

					double xi = std::sin(theta_i);
					double yi = 0.0;
					double zi = std::cos(theta_i);

					double xe = std::sin(theta_e) * std::cos(geometry_.phi(p));
					double ye = std::sin(theta_e) * std::sin(geometry_.phi(p));
					double ze = std::cos(theta_e);

					double inner = xi * xe + yi * ye + zi * ze;
					double scattering_angle;
					if(inner >= 1.0)
					{
						scattering_angle = 0.0;
					}
					else if(inner <= -1.0)
					{
						scattering_angle = PI;
					}
					else
					{
						scattering_angle = std::acos(inner);
					}

					if(optical_layer.single_scattering_albedo == 0.0)
					{
						reflectance_bottom[e][i][p] = 0.0;
					}
					else
					{
						reflectance_bottom[e][i][p] = optical_layer.single_scattering_albedo * radiative_layer.optical_thickness / (4.0 * geometry_.mu_uh(i) * geometry_.mu_lh(e)) * computePhaseFunction(optical_layer.scattering_phase_function, scattering_angle);
					}
				}

				{// for T_top
					double theta_e = geometry_.theta_lh(e);
					double theta_i = geometry_.theta_lh(i);

					double xi = std::sin(theta_i);
					double yi = 0.0;
					double zi = std::cos(theta_i);

					double xe = std::sin(theta_e) * std::cos(geometry_.phi(p));
					double ye = std::sin(theta_e) * std::sin(geometry_.phi(p));
					double ze = std::cos(theta_e);

					double inner = xi * xe + yi * ye + zi * ze;
					double scattering_angle;
					if(inner >= 1.0)
					{
						scattering_angle = 0.0;
					}
					else if(inner <= -1.0)
					{
						scattering_angle = PI;
					}
					else
					{
						scattering_angle = std::acos(inner);
					}

					if(optical_layer.single_scattering_albedo == 0.0)
					{
						transmittance_top[e][i][p] = 0.0;
					}
					else
					{
						transmittance_top[e][i][p] = optical_layer.single_scattering_albedo * radiative_layer.optical_thickness / (4.0 * geometry_.mu_lh(i) * geometry_.mu_lh(e)) * computePhaseFunction(optical_layer.scattering_phase_function, scattering_angle);
					}
				}

				{// for T_bottom
					double theta_e = geometry_.theta_uh(e);
					double theta_i = geometry_.theta_uh(i);

					double xi = std::sin(theta_i);
					double yi = 0.0;
					double zi = std::cos(theta_i);

					double xe = std::sin(theta_e) * std::cos(geometry_.phi(p));
					double ye = std::sin(theta_e) * std::sin(geometry_.phi(p));
					double ze = std::cos(theta_e);

					double inner = xi * xe + yi * ye + zi * ze;
					double scattering_angle;
					if(inner >= 1.0)
					{
						scattering_angle = 0.0;
					}
					else if(inner <= -1.0)
					{
						scattering_angle = PI;
					}
					else
					{
						scattering_angle = std::acos(inner);
					}

					if(optical_layer.single_scattering_albedo == 0.0)
					{
						transmittance_bottom[e][i][p] = 0.0;
					}
					else
					{
						transmittance_bottom[e][i][p] = optical_layer.single_scattering_albedo * radiative_layer.optical_thickness / (4.0 * geometry_.mu_uh(i) * geometry_.mu_uh(e)) * computePhaseFunction(optical_layer.scattering_phase_function, scattering_angle);
					}
				}
			}
		}
	}

	auto R_top = computeFourierSeriesCoefficients(reflectance_top);
	auto R_bottom = computeFourierSeriesCoefficients(reflectance_bottom);
	auto T_top = computeFourierSeriesCoefficients(transmittance_top);
	auto T_bottom = computeFourierSeriesCoefficients(transmittance_bottom);

	radiative_layer.reflectance_m_top_cos = R_top[0];
	radiative_layer.reflectance_m_top_sin = R_top[1];
	radiative_layer.reflectance_m_bottom_cos = R_bottom[0];
	radiative_layer.reflectance_m_bottom_sin = R_bottom[1];

	radiative_layer.transmittance_m_top_cos = T_top[0];
	radiative_layer.transmittance_m_top_sin = T_top[1];
	radiative_layer.transmittance_m_bottom_cos = T_bottom[0];
	radiative_layer.transmittance_m_bottom_sin = T_bottom[1];

	return radiative_layer;
}

inline RadiativeLayer RadiativeTransferSolver::initializeSurfaceLayer_(const OpticalLayer& optical_layer)
{
	RadiativeLayer radiative_layer;

	radiative_layer.reflectance_m_top_cos = std::vector<Eigen::MatrixXd>(geometry_.M + 1, Eigen::MatrixXd::Zero(geometry_.Ntheta, geometry_.Ntheta));
	radiative_layer.reflectance_m_bottom_cos = std::vector<Eigen::MatrixXd>(geometry_.M + 1, Eigen::MatrixXd::Zero(geometry_.Ntheta, geometry_.Ntheta));
	radiative_layer.transmittance_m_top_cos = std::vector<Eigen::MatrixXd>(geometry_.M + 1, Eigen::MatrixXd::Zero(geometry_.Ntheta, geometry_.Ntheta));
	radiative_layer.transmittance_m_bottom_cos = std::vector<Eigen::MatrixXd>(geometry_.M + 1, Eigen::MatrixXd::Zero(geometry_.Ntheta, geometry_.Ntheta));
	
	radiative_layer.reflectance_m_top_sin = std::vector<Eigen::MatrixXd>(geometry_.M + 1, Eigen::MatrixXd::Zero(geometry_.Ntheta, geometry_.Ntheta));
	radiative_layer.reflectance_m_bottom_sin = std::vector<Eigen::MatrixXd>(geometry_.M + 1, Eigen::MatrixXd::Zero(geometry_.Ntheta, geometry_.Ntheta));
	radiative_layer.transmittance_m_top_sin = std::vector<Eigen::MatrixXd>(geometry_.M + 1, Eigen::MatrixXd::Zero(geometry_.Ntheta, geometry_.Ntheta));
	radiative_layer.transmittance_m_bottom_sin = std::vector<Eigen::MatrixXd>(geometry_.M + 1, Eigen::MatrixXd::Zero(geometry_.Ntheta, geometry_.Ntheta));

	radiative_layer.source_up = Eigen::VectorXd::Zero(geometry_.Ntheta);
	radiative_layer.source_down = Eigen::VectorXd::Zero(geometry_.Ntheta);

	radiative_layer.optical_thickness = 1.0E100;

	double s = geometry_.WMU_lh.sum();

	// std::cout << "s = " << s << std::endl;

	// #pragma omp parallel for
	for(int e = 0; e < geometry_.Ntheta; e ++)
	{
		// 上向き：一定輝度 Bsurf*ε/π
		radiative_layer.source_up(e) = (1.0 - optical_layer.surface_albedo) * optical_layer.planck_function;
		// 下向き放射はなし
		radiative_layer.source_down(e) = 0.0;

		for(int i = 0; i < geometry_.Ntheta; i ++)
		{
			radiative_layer.reflectance_m_top_cos[0](e, i) = optical_layer.surface_albedo / s;
		}
	}

	return;
}

inline std::vector<OpticalLayer> RadiativeTransferSolver::setAtmosphericLayerCondition_(const AtmosphereModel& atmosphere_model, double spectral, SpectralCoordinateDimension dimension, int n_phase_function)
{
	int n_layer = atmosphere_model.altitude.size();

	double wavelength;
	double wavenumber;

	if(dimension == SpectralCoordinateDimension::Wavelength)
	{
		wavelength = spectral;
		wavenumber = 1.0 / spectral;
	}
	else if(dimension == SpectralCoordinateDimension::Wavenumber)
	{
		wavelength = 1.0 / spectral;
		wavenumber = spectral;
	}

	std::vector<OpticalLayer> layers(n_layer);

	for(int i = 0; i < n_layer; ++i)
	{
		layers[i].enable_atmospheric_emission = atmosphere_model.enable_atmospheric_emission;

		double temperature = atmosphere_model.temperature[i]; // K
		double pressure = atmosphere_model.pressure[i]; // Pa
		double physical_thickness = atmosphere_model.altitude_top[i] - atmosphere_model.altitude_bottom[i]; // m
		// double number_density = atmosphere_model.number_density[i]; // m-3

		layers[i].absorption_coefficient = 0.0;
		layers[i].scattering_coefficient = 0.0;
		layers[i].scattering_phase_function.resize(n_phase_function);
		for(int j = 0; j < n_phase_function; ++j)
		{
			double theta = PI / static_cast<double>(n_phase_function - 1) * static_cast<double>(j);
			layers[i].scattering_phase_function[j] = {theta, 0.0};
		}

		if(layers[i].enable_atmospheric_emission)
		{
			layers[i].planck_function = computePlanckFunction(spectral, temperature, dimension);
		}

		for(int j = 0; j < atmosphere_model.species.size(); ++j)
		{
			double number_density = atmosphere_model.species[j].vertical_number_density_profile[i];
			double mixing_ratio = atmosphere_model.species[j].vertical_mixing_ratio_profile[i];

			if(atmosphere_model.species[j].species_state == SpeciesState::Aerosol)
			{
				auto ri = interpolateTableLinear(spectral, atmosphere_model.species[j].refractive_index[i]);
				std::complex<double> refractive_index = {ri[0], ri[1]};

				double scattering_cross_section;
				double absorption_cross_section;
				double extinction_cross_section;
				std::vector<std::vector<double>> pf;

				computeMieScatteringSizeDistribution(n_phase_function, wavelength, atmosphere_model.species[j].weight_particle_size_distribution, refractive_index, scattering_cross_section, absorption_cross_section, extinction_cross_section, pf);

				double scattering_coefficient = scattering_cross_section * number_density;
				double absorption_coefficient = absorption_cross_section * number_density;

				for(int k = 0; k < n_phase_function; ++k)
				{
					layers[i].scattering_phase_function[k][1] += pf[k][1] * scattering_coefficient;
				}

				layers[i].scattering_coefficient += scattering_coefficient;
				layers[i].absorption_coefficient += absorption_coefficient;
			}
			else if(atmosphere_model.species[j].species_state == SpeciesState::Molecule)
			{
				if(atmosphere_model.species[j].species_type == SpeciesType::Scatterer || atmosphere_model.species[j].species_type == SpeciesType::Extinction)
				{
					double scattering_cross_section = interpolateTableLinear(spectral, atmosphere_model.species[j].scattering_cross_section_spectrum)[0];
					double scattering_coefficient = scattering_cross_section * number_density; // m-1 = m2 / molecule * molecule / m3
					layers[i].scattering_coefficient += scattering_coefficient;
					std::vector<std::vector<double>> pf;

					if(atmosphere_model.species[j].scatter_type == ScatterType::Isotropic)
					{
						pf = computeIsotropicScatteringFunction(n_phase_function);
					}
					else if(atmosphere_model.species[j].scatter_type == ScatterType::Rayleigh)
					{
						pf = computeRayleighScatteringFunction(n_phase_function);
					}
					else if(atmosphere_model.species[j].scatter_type == ScatterType::HenyeyGreenstein)
					{
						pf = computeHGScatteringFunction(n_phase_function, atmosphere_model.species[j].g_factor);
					}

					for(int k = 0; k < n_phase_function; ++k)
					{
						layers[i].scattering_phase_function[k][1] += pf[k][1] * scattering_coefficient;
					}
				}
				
				if(atmosphere_model.species[j].species_type == SpeciesType::Absorber || atmosphere_model.species[j].species_type == SpeciesType::Extinction)
				{
					if(atmosphere_model.species[j].is_hitran)
					{
						double absorption_cross_section = 0.0;
						for(int k = 0; k < atmosphere_model.species[j].lines.size(); ++k)
						{
							absorption_cross_section += atmosphere_model.species[j].lines[k].computeCrossSection(wavenumber, temperature, pressure * mixing_ratio, pressure, atmosphere_model.species[j].isotopologue, atmosphere_model.diluent);
						}
						double absorption_coefficient = absorption_cross_section * number_density; // m-1 = m2 / molecule * molecule / m3
						layers[i].absorption_coefficient += absorption_coefficient;
					}
					else
					{
						double absorption_cross_section = interpolateTableLinear(spectral, atmosphere_model.species[j].absorption_cross_section_spectrum)[0];
						double absorption_coefficient = absorption_cross_section * number_density; // m-1 = m2 / molecule * molecule / m3
						layers[i].absorption_coefficient += absorption_coefficient;
					}
				}
			}
		}

		layers[i].optical_thickness = (layers[i].scattering_coefficient + layers[i].absorption_coefficient) * physical_thickness;
		layers[i].single_scattering_albedo = layers[i].scattering_coefficient / (layers[i].scattering_coefficient + layers[i].absorption_coefficient);
		normalizeScatteringPhaseFunction(layers[i].scattering_phase_function);
		layers[i].asymmetry_parameter = computeAsymmetryParameter(layers[i].scattering_phase_function);
	}

	return layers;
}

inline OpticalLayer RadiativeTransferSolver::setSurfaceLayerCondition_(const AtmosphereModel& atmosphere_model, double spectral, SpectralCoordinateDimension dimension)
{
	double wavelength;
	double wavenumber;

	if(dimension == SpectralCoordinateDimension::Wavelength)
	{
		wavelength = spectral;
		wavenumber = 1.0 / spectral;
	}
	else if(dimension == SpectralCoordinateDimension::Wavenumber)
	{
		wavelength = 1.0 / spectral;
		wavenumber = spectral;
	}

	OpticalLayer layer;

	layer.enable_atmospheric_emission = atmosphere_model.enable_atmospheric_emission;

	layer.surface_albedo = atmosphere_model.surface_albedo;

	if(layer.enable_atmospheric_emission)
	{
		layer.planck_function = computePlanckFunction(spectral, atmosphere_model.surface_temperature, dimension);
	}

	return layer;
}

}