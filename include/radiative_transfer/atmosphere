#pragma once

#include<complex>
#include<filesystem>
#include<fstream>
#include<iomanip>
#include<cmath>
#include<vector>
#include<string>
#include<algorithm>
#include<stdexcept>
#include<limits>

#include<Eigen/Dense>
#include<netcdf>
// #include<omp.h>

#include"types"
#include"constants"
#include"utilities"
#include"geometry"
#include"hitran"

namespace radiative_transfer
{

std::vector<std::vector<std::vector<double>>> generateLogNormalSizeDistribution(int, double, double);
std::vector<std::vector<std::vector<double>>> generateRectangularSizeDistribution(int, double, double);
std::vector<std::vector<std::vector<double>>> generateGammaSizeDistribution(int, double, double);
std::vector<std::vector<std::vector<double>>> generateModifiedGammaSizeDistribution(int, double, double, double);
std::vector<std::vector<std::vector<double>>> generatePowerLawSizeDistribution(int, double, double, double);

std::vector<std::vector<double>> loadSpectralFile(std::string, std::string, std::string, std::string, std::string);
std::vector<std::vector<double>> loadRefractiveIndexSpectralFile(std::string, std::string, std::string, std::string, std::string);
std::vector<std::vector<std::vector<double>>> loadRefractiveIndexSpectralVerticalFile(std::string, std::string, std::string, std::string, std::string, std::string, std::string);

double ModelBuilder::interpolateVerticalProfile(double x, const std::vector<std::vector<double>>& table, VerticalProfileInterpolation type)
{
	if (table.empty()) return 0.0;

	// 2. 範囲外チェック (外挿はせず、端の値を返すか0を返すか仕様による)
	// ここでは範囲外なら 0.0 を返す（元のコード準拠）
	if (x < table.front()[0] || x > table.back()[0])
	{
		return 0.0; 
	}

	// 3. 二分探索 (std::lower_bound) で高速に区間を見つける
	// イテレータ it は、x 以上の最初の要素を指す
	auto it = std::lower_bound(table.begin(), table.end(), x, [](const std::vector<double>& row, double val){return row[0] < val;});

	// x がテーブルの最初の要素と一致する場合のケア
	if (it == table.begin())
	{
		return table.front()[1];
	}

	// it は区間の「右端」なので、一つ戻って「左端」を取得
	size_t j = std::distance(table.begin(), it) - 1;

	// 4. 補間係数 r の計算
	double x0 = table[j][0];
	double x1 = table[j + 1][0];
	double y0 = table[j][1];
	double y1 = table[j + 1][1];

	// 分母が0になるケース（同じ高度のデータが連続している等）をケア
	if (std::abs(x1 - x0) < 1.0e-9) return y0;

	double r = (x - x0) / (x1 - x0);

	// 5. 値の計算
	if (type == VerticalProfileInterpolation::Linear)
	{
		// 線形補間: y = (1-r)y0 + r*y1
		return ((1.0 - r) * y0 + r * y1);
	}
	else
	{ 
		// 指数補間: y = exp( (1-r)ln(y0) + r*ln(y1) )
		// 安全対策: 値が正でなければ線形補間にフォールバック、または微小値を代入
		if (y0 <= 0.0 || y1 <= 0.0) 
		{
			// 0以下の値の対数は取れないため、線形で返すか、0とみなす
			return ((1.0 - r) * y0 + r * y1);
		}

		double log0 = std::log(y0);
		double log1 = std::log(y1);
		
		// 計算後にまとめて scale_value を掛ける方が log の計算回数が減る
		// exp(ln(y)) * scale = y * scale
		return std::exp((1.0 - r) * log0 + r * log1);
	}
}

std::vector<Species> ModelBuilder::buildSpecies_(const Configuration& configuration, const AtmosphereModel& atmosphere_model, const SpectralInformation& spectral)
{
	int n_species = configuration.atmosphere.species_configuration.size();
	int n_layers = atmosphere_model.altitude.size();

	std::vector<Species> species;

	for(int i = 0; i < n_species; ++i)
	{
		Species s;
		auto s_input = configuration.atmosphere.species_configuration[i];
		s.name = s_input.name.value();
		s.species_state = s_input.species_state.value();

		s.is_hitran = false;

		// 鉛直分布も忘れずに実装
		s.vertical_number_density_profile.resize(n_layers);
		s.vertical_mixing_ratio_profile.resize(n_layers);
		auto unit_type = getUnitInfo(s_input.unit_vertical_profile[1].value());
		std::string input_unit_val = s_input.unit_vertical_profile[1].value();
		std::string input_unit_alt = s_input.unit_vertical_profile[0].value();

		for (int j = 0; j < n_layers; ++j)
		{
			double z_target = atmosphere_model.altitude[j]; // 目標高度 [m]
			double air_density = atmosphere_model.number_density[j]; // 大気数密度 [m-3]
			double dz = atmosphere_model.altitude_top[j] - atmosphere_model.altitude_bottom[j]; // 層厚 [m]

			// 2. 入力データから、その高度における「生の値」を取得・補間
			double raw_value = 0.0;

			if (s_input.is_same_layering_atmosphere)
			{
				raw_value = s_input.vertical_profile[j][0];
			}
			else
			{
				// 層構造が違うなら、高度を使って補間
				// 入力の高度単位に合わせて z_target を変換 (m -> input_unit)
				double z_query = z_target * scaleUnit("m", input_unit_alt);
				raw_value = interpolateVerticalProfile(z_query, s_input.vertical_profile, s_input.vertical_profile_interpolation.value());
			}

			// 3. 単位と物理量に応じた変換 (数密度と混合比の両方を埋める)
			if (unit_type == UnitDim::Dimensionless) // Mixing Ratio
			{
				// 入力は混合比
				double mixing_ratio = raw_value * scaleUnit(input_unit_val, "mol/mol"); // 単位変換
				
				s.vertical_mixing_ratio_profile[j] = mixing_ratio;
				s.vertical_number_density_profile[j] = mixing_ratio * air_density;
			}
			else if (unit_type == UnitDim::NumberDensity) // Number Density
			{
				// 入力は数密度
				double number_density = raw_value * scaleUnit(input_unit_val, "m-3");

				s.vertical_number_density_profile[j] = number_density;
				s.vertical_mixing_ratio_profile[j] = number_density / air_density;
			}
			else if (unit_type == UnitDim::ColumnNumberDensity) // Column Density
			{
				// 入力はカラム密度 [m-2]
				// 数密度 [m-3] = カラム密度 [m-2] / 層厚 [m]
				double col_density = raw_value * scaleUnit(input_unit_val, "m-2");
				double number_density = col_density / dz;

				s.vertical_number_density_profile[j] = number_density;
				s.vertical_mixing_ratio_profile[j] = number_density / air_density;
			}
		}

		if(s.species_state == SpeciesState::Molecule)
		{
			s.species_type = s_input.species_type.value();

			if(s.species_type == SpeciesType::Scatterer || s.species_type == SpeciesType::Extinction)
			{
				s.scatter_type = s_input.scatter_type.value();

				if(s_input.scattering_cross_section_type.value() == CrossSectionType::Constant)
				{
					s.scattering_cross_section = s_input.scattering_cross_section.value() * scaleUnit(s_input.scattering_cross_section_unit.value(), "m2");
				}
				else if(s_input.scattering_cross_section_type.value() == CrossSectionType::External)
				{
					// 外部ファイルを読み込み
					// 読み込んだ配列 std::vector<std::vector<double>> loaded_data ({spectral, scattering_cross_section}の配列)
					std::vector<std::vector<double>> loaded_data;

					if(spectral.spectral_dimension == SpectralCoordinateDimension::Wavelength)
					{
						loaded_data = loadSpectralFile(s_input.filename_scattering_cross_section.value(), "wavelength", "scattering_cross_section", "m", "m2");
					}
					else if(spectral.spectral_dimension == SpectralCoordinateDimension::Wavenumber)
					{
						loaded_data = loadSpectralFile(s_input.filename_scattering_cross_section.value(), "wavenumber", "scattering_cross_section", "m-1", "m2");
					}

					s.scattering_cross_section_spectrum.resize(loaded_data.size(), 2);

					for(int j = 0; j < loaded_data.size(); ++j)
					{
						s.scattering_cross_section_spectrum[j] = loaded_data;
					}
				}

				if(s.scatter_type == ScatterType::HenyeyGreenstein)
				{
					s.g_factor = s_input.g_factor.value();
				}
			}

			if(s.species_type == SpeciesType::Absorber || s.species_type == SpeciesType::Extinction)
			{
				if(s_input.absorption_cross_section_type.value() == CrossSectionType::Constant)
				{
					s.absorption_cross_section = s_input.absorption_cross_section.value() * scaleUnit(s_input.absorption_cross_section_unit.value(), "m2");
				}
				else if(s_input.absorption_cross_section_type.value() == CrossSectionType::External)
				{
					// 外部ファイルを読み込み
					// 読み込んだ配列 std::vector<std::vector<double>> loaded_data ({spectral, absorption_cross_section}の配列)
					std::vector<std::vector<double>> loaded_data;

					if(spectral.spectral_dimension == SpectralCoordinateDimension::Wavelength)
					{
						loaded_data = loadSpectralFile(s_input.filename_absorption_cross_section.value(), "wavelength", "absorption_cross_section", "m", "m2");
					}
					else if(spectral.spectral_dimension == SpectralCoordinateDimension::Wavenumber)
					{
						loaded_data = loadSpectralFile(s_input.filename_absorption_cross_section.value(), "wavenumber", "absorption_cross_section", "m-1", "m2");
					}

					s.absorption_cross_section_spectrum.resize(loaded_data.size(), 2);

					for(int j = 0; j < loaded_data.size(); ++j)
					{
						s.absorption_cross_section_spectrum[j] = loaded_data;
					}
				}
				else if(s_input.absorption_cross_section_type.value() == CrossSectionType::HITRAN)
				{
					s.is_hitran = true;
				}
			}
		}
		else if(s.species_state == SpeciesState::Aerosol)
		{
			s.scatter_type = s_input.scatter_type.value();

			if(s.scatter_type == ScatterType::Mie)
			{
				s.refractive_index.resize(n_layers);

				if(s_input.refractive_index_type.value() == RefractiveIndexType::Constant)
				{
					for(int j = 0; j < n_layers; ++j)
					{
						s.refractive_index[j] = {{std::numeric_limits<double>::quiet_NaN(), s_input.nr.value(), s_input.ni.value()}};
					}
				}
				else if(s_input.refractive_index_type.value() == RefractiveIndexType::Spectral)
				{
					// 外部ファイル読み込み
					// 読み込んだ配列 std::vector<std::vector<double>> loaded_data ({spectral, nr, ni}の配列)

					std::vector<std::vector<double>> loaded_data;

					if(spectral.spectral_dimension == SpectralCoordinateDimension::Wavelength)
					{
						loaded_data = loadRefractiveIndexSpectralFile(s_input.filename_refractive_index_spectral.value(), "wavelength", "nr", "ni", "m");
					}
					else if(spectral.spectral_dimension == SpectralCoordinateDimension::Wavenumber)
					{
						loaded_data = loadRefractiveIndexSpectralFile(s_input.filename_refractive_index_spectral.value(), "wavenumber", "nr", "ni", "m-1");
					}

					for(int j = 0; j < n_layers; ++j)
					{
						s.refractive_index[j] = loaded_data;
					}
				}
				else if(s_input.refractive_index_type.value() == RefractiveIndexType::Vertical)
				{
					if(s_input.is_refractive_index_same_layering_atmosphere == true)
					{
						for(int j = 0; j < n_layers; ++j)
						{
							s.refractive_index[j] = {{std::numeric_limits<double>::quiet_NaN(), s_input.refractive_index_vertical_profile[j][0], s_input.refractive_index_vertical_profile[j][1]}};
						}
					}
					else
					{
						std::vector<std::vector<double>> nr_input(s_input.refractive_index_vertical_profile.size(), std::vector<double>(2, 0.0));
						std::vector<std::vector<double>> ni_input(s_input.refractive_index_vertical_profile.size(), std::vector<double>(2, 0.0));

						for(int j = 0; j < s_input.refractive_index_vertical_profile.size(); ++j)
						{
							nr_input[j] = {s_input.refractive_index_vertical_profile[j][0] * scaleUnit(s_input.unit_refractive_index_vertical_profile.value(), "m"), s_input.refractive_index_vertical_profile[j][1]};
							ni_input[j] = {s_input.refractive_index_vertical_profile[j][0] * scaleUnit(s_input.unit_refractive_index_vertical_profile.value(), "m"), s_input.refractive_index_vertical_profile[j][2]};
						}

						auto itp = s_input.refractive_index_vertical_profile_interpolation.value();

						for(int j = 0; j < n_layers; ++j)
						{
							double alt = atmosphere_model.altitude[j];
							s.refractive_index[j] = {{std::numeric_limits<double>::quiet_NaN(), interpolateVerticalProfile(alt, nr_input, itp), interpolateVerticalProfile(alt, ni_input, itp)}};
						}
					}
				}
				else if(s_input.refractive_index_type.value() == RefractiveIndexType::SpectralVertical)
				{
					// 外部ファイル読み込み
					// 読み込んだ配列 std::vector<std::vector<std::vector<double>>> loaded_data ({altitude, spectral, nr, ni}の配列)
					// loaded_data[n_alt][n_spec] = {alt, spec, nr, ni}
					std::vector<std::vector<std::vector<double>>> loaded_data;
					if(spectral.spectral_dimension == SpectralCoordinateDimension::Wavelength)
					{
						loaded_data = loadRefractiveIndexSpectralVerticalFile(s_input.filename_refractive_index_spectral_vertical.value(), "altitude", "wavelength", "nr", "ni", "m", "m");
					}
					else if(spectral.spectral_dimension == SpectralCoordinateDimension::Wavenumber)
					{
						loaded_data = loadRefractiveIndexSpectralVerticalFile(s_input.filename_refractive_index_spectral_vertical.value(), "altitude", "wavenumber", "nr", "ni", "m", "m-1");
					}

					// 入力データの高度リストを作成（検索用）
					std::vector<double> input_alts(loaded_data.size());
					for(const auto& layer : loaded_data)
					{
						input_alts.push_back(layer[0][0]);
					}

					s.refractive_index.resize(n_layers);
					auto itp_method = s_input.refractive_index_vertical_profile_interpolation.value();

					// 各計算レイヤーに対して
					for(int j = 0; j < n_layers; ++j)
					{
						double target_alt = atmosphere_model.altitude[j];

						// 補間を行う2つの入力層を探す (lower_bound)
						// it は target_alt 以上の最初の要素を指す
						auto it = std::lower_bound(input_alts.begin(), input_alts.end(), target_alt);

						// 補間結果を格納するベクタを準備
						size_t n_spec = loaded_data[0].size();
						s.refractive_index[j].resize(n_spec);

						if (it == input_alts.begin()) 
						{
							// 範囲外(下): 一番下の層をコピー
							const auto& src = loaded_data.front();

							for(size_t k=0; k<n_spec; ++k)
							{
								s.refractive_index[j][k] = {src[k][1], src[k][2], src[k][3]};
							}
						}
						else if (it == input_alts.end()) 
						{
							// 範囲外(上): 一番上の層をコピー
							const auto& src = loaded_data.back();

							for(size_t k=0; k<n_spec; ++k)
							{
								s.refractive_index[j][k] = {src[k][1], src[k][2], src[k][3]};
							}
						}
						else
						{
							// 範囲内
							size_t idx_upper = std::distance(input_alts.begin(), it);
							size_t idx_lower = idx_upper - 1;

							double z0 = input_alts[idx_lower];
							double z1 = input_alts[idx_upper];
							
							// 線形補間係数
							double factor = (target_alt - z0) / (z1 - z0);

							// ★ここが最適化ポイント★
							// 「波長ごとのループ」の中で「高度探索」をするのではなく、
							// 「決まった2つの高度層」に対して「全波長を一気に計算」する。
							
							const auto& layer0 = loaded_data[idx_lower];
							const auto& layer1 = loaded_data[idx_upper];

							// ---------------------------------------------------
							// 補間方法による分岐 (ループの外で判定)
							// ---------------------------------------------------
							if (itp_method == VerticalProfileInterpolation::Linear)
							{
								// --- 線形補間 (Linear) ---
								// y = y0 + factor * (y1 - y0)
								for(size_t k = 0; k < n_spec; ++k)
								{
									double wl = layer0[k][1];
									double nr = layer0[k][2] + factor * (layer1[k][2] - layer0[k][2]);
									double ni = layer0[k][3] + factor * (layer1[k][3] - layer0[k][3]);

									s.refractive_index[j][k] = {wl, nr, ni};
								}
							}
							else
							{
								// --- 対数線形補間 (Exponential / Log-Linear) ---
								// ln(y) = ln(y0) + factor * (ln(y1) - ln(y0))
								// y = exp( ... )
								
								for(size_t k = 0; k < n_spec; ++k)
								{
									double wl = layer0[k][1];
									double nr, ni;

									// 実部 (Nr) の補間
									double nr0 = layer0[k][2];
									double nr1 = layer1[k][2];
									
									// 安全策: 値が正でなければ対数が取れないため、線形にフォールバック
									if (nr0 <= 1.0e-50 || nr1 <= 1.0e-50)
									{
										nr = nr0 + factor * (nr1 - nr0);
									}
									else
									{
										nr = std::exp(std::log(nr0) + factor * (std::log(nr1) - std::log(nr0)));
									}

									// 虚部 (Ni) の補間
									double ni0 = layer0[k][3];
									double ni1 = layer1[k][3];

									if (ni0 <= 1.0e-50 || ni1 <= 1.0e-50)
									{
										ni = ni0 + factor * (ni1 - ni0);
									}
									else
									{
										ni = std::exp(std::log(ni0) + factor * (std::log(ni1) - std::log(ni0)));
									}

									s.refractive_index[j][k] = {wl, nr, ni};
								}
							}
						}
					}
				}

				if(s_input.size_distribution.value() == ParticleSizeDistribution::Delta)
				{
					s.particle_size_distribution = {s_input.delta_r.value() * scaleUnit(s_input.unit_input_radius.value(), "m"), 1.0};
					s.weight_particle_size_distribution = {s_input.delta_r.value() * scaleUnit(s_input.unit_input_radius.value(), "m"), 1.0};
				}
				else if(s_input.size_distribution.value() == ParticleSizeDistribution::Rectangular)
				{
					auto node_weight = generateRectangularSizeDistribution(s_input.count_radius.value(), s_input.r_mean.value() * scaleUnit(s_input.unit_input_radius.value(), "m"), s_input.r_width.value() * scaleUnit(s_input.unit_input_radius.value(), "m"));
					s.particle_size_distribution = node_weight[0]; // 本当は不要
					s.weight_particle_size_distribution = node_weight[1];
				}
				else if(s_input.size_distribution.value() == ParticleSizeDistribution::Gamma)
				{
					auto node_weight = generateGammaSizeDistribution(s_input.count_radius.value(), s_input.gd_a.value() * scaleUnit(s_input.unit_input_radius.value(), "m"), s_input.gd_b.value());
					s.particle_size_distribution = node_weight[0]; // 本当は不要
					s.weight_particle_size_distribution = node_weight[1];
				}
				else if(s_input.size_distribution.value() == ParticleSizeDistribution::ModifiedGamma)
				{
					auto node_weight = generateModifiedGammaSizeDistribution(s_input.count_radius.value(), s_input.mgd_r_c.value() * scaleUnit(s_input.unit_input_radius.value(), "m"), s_input.mgd_alpha.value(), s_input.mgd_gamma.value());
					s.particle_size_distribution = node_weight[0]; // 本当は不要
					s.weight_particle_size_distribution = node_weight[1];
				}
				else if(s_input.size_distribution.value() == ParticleSizeDistribution::LogNormal)
				{
					auto node_weight = generateLogNormalSizeDistribution(s_input.count_radius.value(), s_input.lnd_r_g.value() * scaleUnit(s_input.unit_input_radius.value(), "m"), s_input.lnd_sigma_g.value());
					s.particle_size_distribution = node_weight[0]; // 本当は不要
					s.weight_particle_size_distribution = node_weight[1];
				}
				else if(s_input.size_distribution.value() == ParticleSizeDistribution::PowerLaw)
				{
					auto node_weight = generatePowerLawSizeDistribution(s_input.count_radius.value(), s_input.pl_delta.value(), s_input.pl_r1.value() * scaleUnit(s_input.unit_input_radius.value(), "m"), s_input.pl_r2.value() * scaleUnit(s_input.unit_input_radius.value(), "m"));
					s.particle_size_distribution = node_weight[0]; // 本当は不要
					s.weight_particle_size_distribution = node_weight[1];
				}
			}
		}

		if(s.is_hitran == false)
		{
			species.push_back(s);
		}
		else
		{
			netCDF::NcFile nc_hitran(configuration.filename_hitran.value(), netCDF::NcFile::read);

			double wavenumber_max_calc, wavenumber_min_calc;

			if(spectral.spectral_dimension == SpectralCoordinateDimension::Wavelength)
			{
				wavenumber_max_calc = 1.0 / spectral.spectral_grid[0];
				wavenumber_min_calc = 1.0 / spectral.spectral_grid[spectral.spectral_grid.size() - 1];
			}
			else if(spectral.spectral_dimension == SpectralCoordinateDimension::Wavenumber)
			{
				wavenumber_max_calc = spectral.spectral_grid[spectral.spectral_grid.size() - 1];
				wavenumber_min_calc = spectral.spectral_grid[0];
			}

			double wavenumber_min = std::max(0.0, wavenumber_min_calc - 1000.0 * scaleUnit("cm-1", "m-1"));
			double wavenumber_max = wavenumber_max_calc + 1000.0 * scaleUnit("cm-1", "m-1"); // 1000.0はハードコード．あまり良くないかも


			if(s_input.isotopologue_type.value() == IsotopologueType::All)
			{
				auto isos = hitran::isos_for_molecule(s_input.molecule_id.value());

				if(!s_input.abundance.empty())
				{
					for(int j = 0; j < isos.size(); ++j)
					{
						isos[j].abundance = s_input.abundance[j];
					}
				}
				
				if(!s_input.scalar.empty())
				{
					for(int j = 0; j < isos.size(); ++j)
					{
						isos[j].abundance *= s_input.scalar[j];
					}
				}

				if(s_input.is_normalize.value() == true)
				{
					double norm_const = 0.0;

					for(const auto& iso : isos)
					{
						norm_const += iso.abundance;
					}
					
					if(norm_const > 0.0)
					{
						for(auto& iso : isos)
						{
							iso.abundance /= norm_const;
						}
					}
				}

				for(int j = 0; j < isos.size(); ++j)
				{
					Species ss = s;
					ss.isotopologue = isos[j];

					for(int k = 0; k < ss.vertical_mixing_ratio_profile.size(); ++k)
					{
						ss.vertical_mixing_ratio_profile[k] *= isos[j].abundance;
						ss.vertical_number_density_profile[k] *= isos[j].abundance;
					}

					ss.lines = hitran::loadLines(nc_hitran, ss.isotopologue, wavenumber_min, wavenumber_max, false);

					species.push_back(ss);
				}
			}
			else if(s_input.isotopologue_type.value() == IsotopologueType::Defined)
			{
				std::vector<hitran::Isotopologue> isos(s_input.local_isotopologue_id.size());

				for(int j = 0; j < isos.size(); ++j)
				{
					isos[j] = hitran::iso_from_global(hitran::global_from_mol_local(s_input.molecule_id.value(), s_input.local_isotopologue_id[j]));
				}

				if(!s_input.abundance.empty())
				{
					for(int j = 0; j < isos.size(); ++j)
					{
						isos[j].abundance = s_input.abundance[j];
					}
				}
				
				if(!s_input.scalar.empty())
				{
					for(int j = 0; j < isos.size(); ++j)
					{
						isos[j].abundance *= s_input.scalar[j];
					}
				}

				if(s_input.is_normalize.value() == true)
				{
					double norm_const = 0.0;

					for(const auto& iso : isos)
					{
						norm_const += iso.abundance;
					}
					
					if(norm_const > 0.0)
					{
						for(auto& iso : isos)
						{
							iso.abundance /= norm_const;
						}
					}
				}

				for(int j = 0; j < isos.size(); ++j)
				{
					Species ss = s;
					ss.isotopologue = isos[j];

					for(int k = 0; k < ss.vertical_mixing_ratio_profile.size(); ++k)
					{
						ss.vertical_mixing_ratio_profile[k] *= isos[j].abundance;
						ss.vertical_number_density_profile[k] *= isos[j].abundance;
					}

					ss.lines = hitran::loadLines(nc_hitran, ss.isotopologue, wavenumber_min, wavenumber_max, false);

					species.push_back(ss);
				}
			}
		}
	}

	return species;
}

AtmosphereModel ModelBuilder::buildAtmosphereModel(const Configuration& configuration, const SpectralInformation& spectral)
{
	AtmosphereModel model;

	// layering
	if(! configuration.atmosphere.z_edge.empty())
	{
		int n_layer = configuration.atmosphere.z_edge.size() - 1;
		model.altitude_bottom.resize(n_layer);
		model.altitude_top.resize(n_layer);
		model.altitude.resize(n_layer);

		for(int i = 0; i < n_layer; ++i)
		{
			model.altitude_bottom[i] = configuration.atmosphere.z_edge[i];
			model.altitude_top[i] = configuration.atmosphere.z_edge[i + 1];
			model.altitude[i] = 0.5 * (model.altitude_top[i] + model.altitude_bottom[i]);
		}
	}
	else
	{
		int n_layer = configuration.atmosphere.z_center.size();
		model.altitude_bottom.resize(n_layer);
		model.altitude_top.resize(n_layer);
		model.altitude.resize(n_layer);

		for(int i = 0; i < n_layer; ++i)
		{
			model.altitude[i] = configuration.atmosphere.z_center[i];

			if(i == 0)
			{
				model.altitude_bottom[i] = configuration.atmosphere.z_center[0];
				model.altitude_top[i] = 0.5 * (configuration.atmosphere.z_center[0] + configuration.atmosphere.z_center[1]);
			}
			else if(i == n_layer - 1)
			{
				model.altitude_bottom[i] = 0.5 * (configuration.atmosphere.z_center[n_layer - 2] + configuration.atmosphere.z_center[n_layer - 1]);
				model.altitude_top[i] = configuration.atmosphere.z_center[n_layer - 1];
			}
			else
			{
				model.altitude_bottom[i] = 0.5 * (configuration.atmosphere.z_center[i - 1] + configuration.atmosphere.z_center[i]);
				model.altitude_top[i] = 0.5 * (configuration.atmosphere.z_center[i] + configuration.atmosphere.z_center[i + 1]);
			}
		}
	}

	int n_layer = model.altitude.size();

	model.temperature.resize(n_layer);

	if(configuration.atmosphere.is_same_temperature_layering_atmosphere == false)
	{
		if(configuration.atmosphere.vertical_temperature_profile == VerticalTemperatureProfile::VIRA_EQUATOR || configuration.atmosphere.vertical_temperature_profile == VerticalTemperatureProfile::VIRA_45 || configuration.atmosphere.vertical_temperature_profile == VerticalTemperatureProfile::VIRA_60 || configuration.atmosphere.vertical_temperature_profile == VerticalTemperatureProfile::Table)
		{
			std::vector<std::vector<double>> profile_data;
			if(configuration.atmosphere.vertical_temperature_profile == VerticalTemperatureProfile::VIRA_EQUATOR)
			{
				profile_data.resize(vira_equator.size());
				
				for(int i = 0; i < vira_equator.size(); i ++)
				{
					profile_data[i] = {vira_equator[i][0] * scaleUnit("km", "m"), vira_equator[i][1]};
				}
			}
			else if(configuration.atmosphere.vertical_temperature_profile == VerticalTemperatureProfile::VIRA_45)
			{
				profile_data.resize(vira_45.size());

				for(int i = 0; i < vira_45.size(); i ++)
				{
					profile_data[i] = {vira_45[i][0] * scaleUnit("km", "m"), vira_45[i][1]};
				}
			}
			else if(configuration.atmosphere.vertical_temperature_profile == VerticalTemperatureProfile::VIRA_60)
			{
				profile_data.resize(vira_60.size());

				for(int i = 0; i < vira_60.size(); i ++)
				{
					profile_data[i] = {vira_60[i][0] * scaleUnit("km", "m"), vira_60[i][1]};
				}
			}
			else if(configuration.atmosphere.vertical_temperature_profile == VerticalTemperatureProfile::Table)
			{
				profile_data.resize(configuration.atmosphere.temperature_profile.size());

				for(int i = 0; i < configuration.atmosphere.temperature_profile.size(); i ++)
				{
					profile_data[i] = {configuration.atmosphere.temperature_profile[i][0] * scaleUnit(configuration.atmosphere.temperature_unit[0].value(), "m"), configuration.atmosphere.temperature_profile[i][1]};
				}
			}
			
			for(int i = 0; i < n_layer; ++i)
			{
				model.temperature[i] = interpolateVerticalProfile(model.altitude[i], profile_data, configuration.atmosphere.vertical_temperature_interpolation.value());
			}
		}
	}
	else
	{
		for(int i = 0; i < n_layer; i ++)
		{
			model.temperature[i] = configuration.atmosphere.temperature_profile[i][1];
		}
	}

	model.pressure.resize(n_layer);

	if(configuration.atmosphere.is_same_pressure_layering_atmosphere == false)
	{
		if(configuration.atmosphere.vertical_pressure_profile == VerticalPressureProfile::VIRA_EQUATOR || configuration.atmosphere.vertical_pressure_profile == VerticalPressureProfile::VIRA_45 || configuration.atmosphere.vertical_pressure_profile == VerticalPressureProfile::VIRA_60 || configuration.atmosphere.vertical_pressure_profile == VerticalPressureProfile::Table)
		{
			std::vector<std::vector<double>> profile_data;
			if(configuration.atmosphere.vertical_pressure_profile == VerticalPressureProfile::VIRA_EQUATOR)
			{
				profile_data.resize(vira_equator.size());
				
				for(int i = 0; i < vira_equator.size(); i ++)
				{
					profile_data[i] = {vira_equator[i][0] * scaleUnit("km", "m"), vira_equator[i][2] * scaleUnit("bar", "Pa")};
				}
			}
			else if(configuration.atmosphere.vertical_pressure_profile == VerticalPressureProfile::VIRA_45)
			{
				profile_data.resize(vira_45.size());

				for(int i = 0; i < vira_45.size(); i ++)
				{
					profile_data[i] = {vira_45[i][0] * scaleUnit("km", "m"), vira_45[i][2] * scaleUnit("bar", "Pa")};
				}
			}
			else if(configuration.atmosphere.vertical_pressure_profile == VerticalPressureProfile::VIRA_60)
			{
				profile_data.resize(vira_60.size());

				for(int i = 0; i < vira_60.size(); i ++)
				{
					profile_data[i] = {vira_60[i][0] * scaleUnit("km", "m"), vira_60[i][2] * scaleUnit("bar", "Pa")};
				}
			}
			else if(configuration.atmosphere.vertical_pressure_profile == VerticalPressureProfile::Table)
			{
				profile_data.resize(configuration.atmosphere.pressure_profile.size());

				for(int i = 0; i < configuration.atmosphere.pressure_profile.size(); i ++)
				{
					profile_data[i] = {configuration.atmosphere.pressure_profile[i][0] * scaleUnit(configuration.atmosphere.pressure_unit[0].value(), "m"), configuration.atmosphere.pressure_profile[i][1] * scaleUnit(configuration.atmosphere.pressure_unit[1].value(), "Pa")};
				}
			}
			
			for(int i = 0; i < n_layer; ++i)
			{
				model.pressure[i] = interpolateVerticalProfile(model.altitude[i], profile_data, configuration.atmosphere.vertical_pressure_interpolation.value());
			}
		}
		else if(configuration.atmosphere.vertical_pressure_profile == VerticalPressureProfile::External)
		{
			// configuration.atmosphere.output_log << "CURRENTRY EXTERNAL INPUT IS NOT SUPPORTED" << std::endl;
		}
		else if(configuration.atmosphere.vertical_pressure_profile == VerticalPressureProfile::Hydrostatic)
		{
			// configuration.atmosphere.output_log << "CURRENTRY HYDROSTATIC IS NOT SUPPORTED" << std::endl;
		}
	}
	else
	{
		for(int i = 0; i < n_layer; i ++)
		{
			model.pressure[i] = configuration.atmosphere.pressure_profile[i][1] * scaleUnit(configuration.atmosphere.pressure_unit[1].value(), "Pa");
		}
	}

	model.number_density.resize(n_layer);

	//Ideal Gas Law PV=nRT n(mol)/V(m^3) = P(N/m^2)/(R(N.m/K/mol)*T(K)) n(molecules/m^3)=NA*P*/(R*T)
	if(configuration.atmosphere.vertical_number_density_profile == VerticalNumberDensityProfile::IdealGas)
	{
		for(int i = 0; i < n_layer; i ++)
		{
			model.number_density[i] = model.pressure[i] * AVOGADRO_CONSTANT / (MOLAR_GAS_CONSTANT * model.temperature[i]);
		}
	}
	else
	{
		if(configuration.atmosphere.is_same_number_density_layering_atmosphere == false)
		{
			if(configuration.atmosphere.vertical_number_density_profile == VerticalNumberDensityProfile::VIRA_EQUATOR || configuration.atmosphere.vertical_number_density_profile == VerticalNumberDensityProfile::VIRA_45 || configuration.atmosphere.vertical_number_density_profile == VerticalNumberDensityProfile::VIRA_60 || configuration.atmosphere.vertical_number_density_profile == VerticalNumberDensityProfile::Table)
			{
				std::vector<std::vector<double>> profile_data;
				if(configuration.atmosphere.vertical_number_density_profile == VerticalNumberDensityProfile::VIRA_EQUATOR)
				{
					profile_data.resize(vira_equator.size());
					
					for(int i = 0; i < vira_equator.size(); i ++)
					{
						profile_data[i] = {vira_equator[i][0] * scaleUnit("km", "m"), vira_equator[i][3] * scaleUnit("m-3", "m-3")};
					}
				}
				else if(configuration.atmosphere.vertical_number_density_profile == VerticalNumberDensityProfile::VIRA_45)
				{
					profile_data.resize(vira_45.size());

					for(int i = 0; i < vira_45.size(); i ++)
					{
						profile_data[i] = {vira_45[i][0] * scaleUnit("km", "m"), vira_45[i][3] * scaleUnit("m-3", "m-3")};
					}
				}
				else if(configuration.atmosphere.vertical_number_density_profile == VerticalNumberDensityProfile::VIRA_60)
				{
					profile_data.resize(vira_60.size());

					for(int i = 0; i < vira_60.size(); i ++)
					{
						profile_data[i] = {vira_60[i][0] * scaleUnit("km", "m"), vira_60[i][3] * scaleUnit("m-3", "m-3")};
					}
				}
				else if(configuration.atmosphere.vertical_number_density_profile == VerticalNumberDensityProfile::Table)
				{
					profile_data.resize(configuration.atmosphere.number_density_profile.size());

					for(int i = 0; i < configuration.atmosphere.number_density_profile.size(); i ++)
					{
						if(configuration.atmosphere.unit_dim_number_density.value() == UnitDim::NumberDensity)
						{
							profile_data[i] = {configuration.atmosphere.number_density_profile[i][0] * scaleUnit(configuration.atmosphere.number_density_unit[0].value(), "m"), configuration.atmosphere.number_density_profile[i][1] * scaleUnit(configuration.atmosphere.number_density_unit[1].value(), "m-3")};
						}
						else if(configuration.atmosphere.unit_dim_number_density.value() == UnitDim::ColumnNumberDensity)
						{
							profile_data[i] = {configuration.atmosphere.number_density_profile[i][0] * scaleUnit(configuration.atmosphere.number_density_unit[0].value(), "m"), configuration.atmosphere.number_density_profile[i][1] * scaleUnit(configuration.atmosphere.number_density_unit[1].value(), "m-2")};
						}
					}
				}
				
				for(int i = 0; i < n_layer; ++i)
				{
					if(configuration.atmosphere.unit_dim_number_density.value() == UnitDim::NumberDensity)
					{
						model.number_density[i] = interpolateVerticalProfile(model.altitude[i], profile_data, configuration.atmosphere.vertical_number_density_interpolation.value());
					}
					else if(configuration.atmosphere.unit_dim_number_density.value() == UnitDim::ColumnNumberDensity)
					{
						model.number_density[i] = interpolateVerticalProfile(model.altitude[i], profile_data, configuration.atmosphere.vertical_number_density_interpolation.value()) / (model.altitude_top[i] - model.altitude_bottom[i]);
					}
				}
			}
			else if(configuration.atmosphere.vertical_number_density_profile == VerticalNumberDensityProfile::External)
			{
				// configuration.atmosphere.output_log << "CURRENTRY EXTERNAL INPUT IS NOT SUPPORTED" << std::endl;
			}
		}
		else
		{
			for(int i = 0; i < n_layer; i ++)
			{
				if(configuration.atmosphere.unit_dim_number_density.value() == UnitDim::NumberDensity)
				{
					model.number_density[i] = configuration.atmosphere.number_density_profile[i][1] * scaleUnit(configuration.atmosphere.number_density_unit[1].value(), "m-3");
				}
				else if(configuration.atmosphere.unit_dim_number_density.value() == UnitDim::ColumnNumberDensity)
				{
					model.number_density[i] = configuration.atmosphere.number_density_profile[i][1] * scaleUnit(configuration.atmosphere.number_density_unit[1].value(), "m-2") / (model.altitude_top[i] - model.altitude_bottom[i]);
				}
			}
		}
	}

	model.species = buildSpecies_(configuration, model, spectral);

	bool is_hitran = false;

	for(int i = 0; i < model.species.size(); ++i)
	{
		if(model.species[i].is_hitran)
		{
			is_hitran = true;
			break;
		}
	}

	if(is_hitran)
	{
		std::vector<std::string> dil_species = {"AIR", "CO2", "H2", "HE", "H2O"};
		std::vector<double> dil_ratio(5, 0.0);

		for(int i = 0; i < configuration.atmosphere.diluent_species.size(); ++i)
		{
			std::string dil_sp = toUpper(configuration.atmosphere.diluent_species[i]);
			
			for(int j = 0; j < dil_species.size(); ++j)
			{
				if(dil_sp == dil_species[j])
				{
					dil_ratio[j] = configuration.atmosphere.diluent_ratio[i];
					break;
				}
			}
			
			model.diluent.air = dil_ratio[0];
			model.diluent.CO2 = dil_ratio[1];
			model.diluent.H2 = dil_ratio[2];
			model.diluent.He = dil_ratio[3];
			model.diluent.H2O = dil_ratio[4];
		}
	}

	return model;
}

Geometry ModelBuilder::buildGeometry(const Configuration& configuration)
{
	Geometry geometry;
	
	geometry.Ntheta = configuration.geometry.n_theta.value();
	// geometry.Nphi = configuration.n_phi;
	// geometry.M = configuration.n_mode;

	if(configuration.geometry.grid_type == GridType::Regular)
	{
		if(geometry.Ntheta % 2 == 0)
		{
			geometry.Ntheta ++;
		}
	}

	if(configuration.geometry.n_mode.has_value() && !configuration.geometry.n_phi.has_value())
	{
		geometry.M = configuration.geometry.n_mode.value();
		geometry.Nphi = geometry.M * 2 + 3;
	}
	else if(configuration.geometry.n_phi.has_value() && !configuration.geometry.n_mode.has_value())
	{
		geometry.Nphi = configuration.geometry.n_phi.value();

		if(geometry.Nphi % 2 == 0)
		{
			geometry.Nphi ++;
		}
		
		geometry.M = (geometry.Nphi - 3) / 2;
	}
	else if(!configuration.geometry.n_phi.has_value() && !configuration.geometry.n_mode.has_value())
	{
		geometry.Nphi = geometry.Ntheta * 4 + 1;
		geometry.M = (geometry.Nphi - 3) / 2;
	}

	geometry.phi = Eigen::VectorXd::Zero(geometry.Nphi);
	geometry.d_phi = 2.0 * PI / double(geometry.Nphi);

	for(int i = 0; i < geometry.Nphi; i ++)
	{
		geometry.phi(i) = double(i) * geometry.d_phi;
	}

	geometry.theta_uh = Eigen::VectorXd::Zero(geometry.Ntheta);
	geometry.theta_lh = Eigen::VectorXd::Zero(geometry.Ntheta);
	geometry.theta_all = Eigen::VectorXd::Zero(geometry.Ntheta * 2);
	geometry.mu_uh = Eigen::VectorXd::Zero(geometry.Ntheta);
	geometry.mu_lh = Eigen::VectorXd::Zero(geometry.Ntheta);
	geometry.weight_uh = Eigen::VectorXd::Zero(geometry.Ntheta);
	geometry.weight_lh = Eigen::VectorXd::Zero(geometry.Ntheta);

	geometry.WMU_uh = Eigen::MatrixXd::Zero(geometry.Ntheta, geometry.Ntheta);
	geometry.WMU_lh = Eigen::MatrixXd::Zero(geometry.Ntheta, geometry.Ntheta);

	if(configuration.geometry.grid_type == GridType::Regular)
	{
		double eps = PI / 2.0 / double(geometry.Ntheta - 1) * 1.0E-3;
		double dtheta = (PI / 2.0 - eps) / double(geometry.Ntheta - 1);

		// #pragma omp parallel for
		for(int i = 0; i < geometry.Ntheta; i ++)
		{	
			geometry.theta_uh(i) = 0.0 + dtheta * double(i);
			geometry.theta_lh(i) = PI - dtheta * double(i);
			geometry.mu_uh(i) = std::abs(std::cos(geometry.theta_uh(i)));
			geometry.mu_lh(i) = std::abs(std::cos(geometry.theta_lh(i)));

			geometry.theta_all(i) = geometry.theta_uh(i);
			geometry.theta_all(geometry.Ntheta * 2 - 1 - i) = geometry.theta_lh(i);
		}

		// #pragma omp parallel for
		for(int i = 0; i < geometry.Ntheta; i ++)
		{
			if(i <= geometry.Ntheta - 3)
			{
				if(i == 0 || i == geometry.Ntheta - 3)
				{
					geometry.weight_uh(i) = 1.0 / 3.0 * dtheta * std::sin(geometry.theta_uh(i));
					geometry.weight_lh(i) = 1.0 / 3.0 * dtheta * std::sin(geometry.theta_lh(i));
				}
				else if(i % 2 == 1)
				{
					geometry.weight_uh(i) = 4.0 / 3.0 * dtheta * std::sin(geometry.theta_uh(i));
					geometry.weight_lh(i) = 4.0 / 3.0 * dtheta * std::sin(geometry.theta_lh(i));
				}
				else
				{
					geometry.weight_uh(i) = 2.0 / 3.0 * dtheta * std::sin(geometry.theta_uh(i));
					geometry.weight_lh(i) = 2.0 / 3.0 * dtheta * std::sin(geometry.theta_lh(i));
				}
			}

			if(i == geometry.Ntheta - 3)
			{
				geometry.weight_uh(i) += ((1.0 / (6.0 * dtheta * dtheta)) * std::pow(2.0 * dtheta + eps, 3) - (3.0 / (4.0 * dtheta)) * std::pow(2.0 * dtheta + eps, 2) + (2.0 * dtheta + eps)) * std::sin(geometry.theta_uh(i));
				geometry.weight_lh(i) += ((1.0 / (6.0 * dtheta * dtheta)) * std::pow(2.0 * dtheta + eps, 3) - (3.0 / (4.0 * dtheta)) * std::pow(2.0 * dtheta + eps, 2) + (2.0 * dtheta + eps)) * std::sin(geometry.theta_lh(i));
			}
			else if(i == geometry.Ntheta - 2)
			{
				geometry.weight_uh(i) = ((- 1.0 / (3.0 * dtheta * dtheta)) * std::pow(2.0 * dtheta + eps, 3) + (1.0 / dtheta) * std::pow(2.0 * dtheta + eps, 2)) * std::sin(geometry.theta_uh(i));
				geometry.weight_lh(i) = ((- 1.0 / (3.0 * dtheta * dtheta)) * std::pow(2.0 * dtheta + eps, 3) + (1.0 / dtheta) * std::pow(2.0 * dtheta + eps, 2)) * std::sin(geometry.theta_lh(i));
			}
			else if(i == geometry.Ntheta - 1)
			{
				geometry.weight_uh(i) = ((1.0 / (6.0 * dtheta * dtheta)) * std::pow(2.0 * dtheta + eps, 3) - (1.0 / (4.0 * dtheta)) * std::pow(2.0 * dtheta + eps, 2)) * std::sin(geometry.theta_uh(i));
				geometry.weight_lh(i) = ((1.0 / (6.0 * dtheta * dtheta)) * std::pow(2.0 * dtheta + eps, 3) - (1.0 / (4.0 * dtheta)) * std::pow(2.0 * dtheta + eps, 2)) * std::sin(geometry.theta_lh(i));
			}
		}
	}
	else if(configuration.geometry.grid_type == GridType::GaussRadau)
	{
		auto node_weight = computeGaussRadauQuadratureNodeWeight(geometry.Ntheta);

		for(int i = 0; i < node_weight.size(); i ++)
		{
			geometry.mu_uh(i) = node_weight[node_weight.size() - 1 - i][0];
			geometry.mu_lh(i) = node_weight[node_weight.size() - 1 - i][0];
			geometry.theta_uh(i) = std::acos(node_weight[node_weight.size() - 1 - i][0]);
			geometry.theta_lh(i) = PI - std::acos(node_weight[node_weight.size() - 1 - i][0]);

			geometry.theta_all(i) = geometry.theta_uh(i);
			geometry.theta_all(geometry.Ntheta * 2 - 1 - i) = geometry.theta_lh(i);

			geometry.weight_uh(i) = node_weight[node_weight.size() - 1 - i][1];
			geometry.weight_lh(i) = node_weight[node_weight.size() - 1 - i][1];
		}
	}

	// #pragma omp parallel for
	for(int i = 0; i < geometry.Ntheta; i ++)
	{
		geometry.WMU_uh(i, i) = geometry.weight_uh(i) * geometry.mu_uh(i);
		geometry.WMU_lh(i, i) = geometry.weight_lh(i) * geometry.mu_lh(i);
	}

	return geometry;
}

inline std::vector<std::vector<std::vector<double>>> generateLogNormalSizeDistribution(int n_r, double r_g, double sigma_g)
{
	std::vector<std::vector<double>> size_distribution(n_r, std::vector<double>(2));
	std::vector<std::vector<double>> weight(n_r, std::vector<double>(2));

	if (n_r <= 0 || r_g <= 0.0 || sigma_g <= 0.0)
	{
		if (sigma_g <= 0.0)
		{
			throw std::runtime_error("[generateLogNormalSizeDistribution] sigma_g must be positive.");
		}
	}

	std::vector<std::vector<double>> node_weight_hermite = computeGaussHermiteQuadratureNodeWeight(n_r);
	
	double ln_rg = std::log(r_g);
	double sigma_ln = sigma_g;
	
	double sqrt_2_sigma_ln = std::sqrt(2.0) * sigma_ln;

	double weight_prefactor = 1.0 / std::sqrt(PI);

	double pdf_norm_factor = 1.0 / (std::sqrt(2.0 * PI) * sigma_ln);

	for (int i = 0; i < n_r; ++i)
	{
		double u_std = node_weight_hermite[i][0];
		double w_std = node_weight_hermite[i][1];
		
		double r = std::exp(ln_rg + sqrt_2_sigma_ln * u_std);
		double ln_ratio = std::log(r / r_g); 
		
		double exponent = -(ln_ratio * ln_ratio) / (2.0 * sigma_ln * sigma_ln);

		size_distribution[i][0] = r;
		weight[i][0] = r; 
		size_distribution[i][1] = (pdf_norm_factor / r) * std::exp(exponent);
		weight[i][1] = w_std * weight_prefactor;
	}

	return {size_distribution, weight};
}

inline std::vector<std::vector<std::vector<double>>> generateRectangularSizeDistribution(int n_r, double r_mean, double width)
{
	std::vector<std::vector<double>> size_distribution(n_r, std::vector<double>(2));
	std::vector<std::vector<double>> weight(n_r, std::vector<double>(2));

	if (n_r <= 0 || width <= 0.0)
	{
		throw std::runtime_error("[generateRectangularSizeDistribution] Invalid input parameters (n_r <= 0 or width <= 0).");
	}

	double r_min = r_mean - 0.5 * width;
	double r_max = r_mean + 0.5 * width;

	if (r_min < 0.0)
	{
		throw std::runtime_error("[generateRectangularSizeDistribution] Rectangular distribution extends to negative radius (r_min < 0). Adjust r_mean or width.");
	}

	std::vector<std::vector<double>> node_weight_std = computeGaussLegendreQuadratureNodeWeight(n_r);
	
	double n_r_val = 1.0 / (r_max - r_min); 

	for (int i = 0; i < n_r; ++i)
	{
		double x_std = node_weight_std[i][0];
		double w_std = node_weight_std[i][1];

		double r = 0.5 * (r_max - r_min) * x_std + 0.5 * (r_max + r_min);

		size_distribution[i][0] = r;
		weight[i][0] = r;
		size_distribution[i][1] = n_r_val;
		weight[i][1] = w_std * 0.5;
	}

	return {size_distribution, weight};
}

inline std::vector<std::vector<std::vector<double>>> generateGammaSizeDistribution(int n_r, double a, double b)
{
	std::vector<std::vector<double>> size_distribution(n_r, std::vector<double>(2));
	std::vector<std::vector<double>> weight(n_r, std::vector<double>(2));

	if (n_r <= 0 || a <= 0.0 || b <= 0.0)
	{
		throw std::runtime_error("[generateGammaSizeDistribution] Parameters a and b must be positive.");
	}
	
	if ((1 - b) / b <= 0.0)
	{
		throw std::runtime_error("[generateGammaSizeDistribution] (1 - 2b) / b must be positive for convergence. Check parameter b.");
	}

	std::vector<std::vector<double>> node_weight_laguerre = computeGaussLaguerreQuadratureNodeWeight(n_r);
	
	double norm_const = 1.0 / (a * b * std::tgamma((1.0 - 2.0 * b) / b));

	for (int i = 0; i < n_r; ++i)
	{
		double x_laguerre = node_weight_laguerre[i][0];
		double w_laguerre = node_weight_laguerre[i][1];

		double r = a * b * x_laguerre;
		if (r < 1e-12)
		{
			r = 1e-12;
		}

		size_distribution[i][0] = r;
		weight[i][0] = r;
		size_distribution[i][1] = norm_const * std::pow(r / a / b, (1.0 - 3.0 * b) / b) * std::exp(-r / a / b);
		weight[i][1] = 1.0 / std::tgamma((1.0 - 2.0 * b) / b) * w_laguerre * std::pow(x_laguerre, (1.0 - 3.0 * b) / b);
	}

	return {size_distribution, weight};
}

inline std::vector<std::vector<std::vector<double>>> generateModifiedGammaSizeDistribution(int n_r, double r_c, double alpha, double gamma)
{
	std::vector<std::vector<double>> size_distribution(n_r, std::vector<double>(2));
	std::vector<std::vector<double>> weight(n_r, std::vector<double>(2));

	if (n_r <= 0 || r_c <= 0.0 || alpha <= 0.0 || gamma <= 0.0)
	{
		throw std::runtime_error("[generateModifiedGammaSizeDistribution] Parameters must be positive.");
	}
	
	std::vector<std::vector<double>> node_weight_laguerre = computeGeneralizedGaussLaguerreQuadratureNodeWeight(n_r, (alpha - gamma + 1.0) / gamma);
	
	double norm_const = gamma / (r_c * std::tgamma((alpha + 1.0) / gamma)) * std::pow(alpha / gamma, (alpha + 1) / gamma);
	
	for (int i = 0; i < n_r; ++i)
	{
		double x_laguerre = node_weight_laguerre[i][0];
		double w_laguerre = node_weight_laguerre[i][1];

		double r;
		if (x_laguerre == 0.0)
		{
			r = 0.0;
		}
		else
		{
			r = r_c * std::pow((gamma / alpha) * x_laguerre, 1.0 / gamma);
		}
		
		if (r < 1e-12)
		{
			r = 1e-12;
		}

		size_distribution[i][0] = r;
		weight[i][0] = r;
		size_distribution[i][1] = norm_const * std::pow(r / r_c, alpha) * std::exp(-alpha / gamma * std::pow(r / r_c, gamma));
		weight[i][1] = w_laguerre / std::tgamma((alpha + 1.0) / gamma);
	}

	return {size_distribution, weight};
}

inline std::vector<std::vector<std::vector<double>>> generatePowerLawSizeDistribution(int n_r, double pl_delta, double pl_r1, double pl_r2)
{
	std::vector<std::vector<double>> size_distribution(n_r, std::vector<double>(2));
	std::vector<std::vector<double>> weight(n_r, std::vector<double>(2));

	if (n_r <= 0 || pl_r1 <= 0.0 || pl_r2 <= 0.0 || pl_r1 >= pl_r2)
	{
		throw std::runtime_error("[generatePowerLawSizeDistribution] Invalid limits or parameters (r1 >= r2).");
	}

	double ln_r_min = std::log(pl_r1);
	double ln_r_max = std::log(pl_r2);

	std::vector<std::vector<double>> node_weight_std = computeGaussLegendreQuadratureNodeWeight(n_r);
	
	double diff = ln_r_max - ln_r_min;
	double sum_limits = ln_r_max + ln_r_min;
	double jacobian = 0.5 * diff;
	
	double c;
	if (std::abs(pl_delta - 1.0) < 1e-9)
	{
		c = 1.0 / diff;
	}
	else
	{
		double term_nu = 1.0 - pl_delta;
		c = term_nu / (std::pow(pl_r2, term_nu) - std::pow(pl_r1, term_nu));
	}

	for (int i = 0; i < n_r; ++i)
	{
		double x_std = node_weight_std[i][0];
		double w_std = node_weight_std[i][1];

		double ln_r = 0.5 * diff * x_std + 0.5 * sum_limits;
		double r = std::exp(ln_r);

		double n_r_val = c * std::pow(r, -pl_delta);
		double dr = r * w_std * jacobian;
		
		size_distribution[i][0] = r;
		weight[i][0] = r;
		size_distribution[i][1] = n_r_val;
		weight[i][1] = n_r_val * dr;
	}

	return {size_distribution, weight};
}

inline std::vector<std::vector<double>> loadSpectralFile(std::string filename, std::string var_name_spectral, std::string var_name_value, std::string unit_target_spectral, std::string unit_target_value)
{
	try
	{
		netCDF::NcFile dataFile(filename, NcFile::read);

		auto getVarSafe = [&](std::string name) -> netCDF::NcVar
		{
			netCDF::NcVar var = dataFile.getVar(name);
			if(var.isNull())
			{
				throw std::runtime_error("NetCDF Variable '" + name + "' not found in " + filename);
			}
			return var;
		};

		netCDF::NcVar v_spec = getVarSafe(var_name_spectral);
		netCDF::NcVar v_value = getVarSafe(var_name_value);

		size_t n_data = v_spec.getDim(0).getSize();

		// 単位変換
		std::string source_unit_spec;
		try
		{
			netCDF::NcVarAtt att = v_spec.getAtt("units");
			if(!att.isNull()) att.getValues(source_unit_spec);
		}
		catch(...)
		{
			std::cout << "[Warning] 'units' missing for " << var_name_spectral << ". Assuming " << unit_target_spectral << "." << std::endl;
			source_unit_spec = unit_target_spectral;
		}

		std::string source_unit_value;
		try
		{
			netCDF::NcVarAtt att = v_value.getAtt("units");
			if(!att.isNull()) att.getValues(source_unit_value);
		}
		catch(...)
		{
			std::cout << "[Warning] 'units' missing for " << var_name_value << ". Assuming " << unit_target_value << "." << std::endl;
			source_unit_value = unit_target_value;
		}

		// double scale_spec = scaleUnit(source_unit_spec, unit_target_spectral);

		// データ読み込み
		std::vector<double> buf_spec(n_data);
		std::vector<double> buf_value(n_data);

		v_spec.getVar(buf_spec.data());
		v_value.getVar(buf_value.data());

		bool is_spectral_dimension_mismatch;
		double scale_spec;

		if(getUnitInfo(unit_target_spectral).dim != getUnitInfo(source_unit_spec).dim)
		{
			is_spectral_dimension_mismatch = true;
			scale_spec = 1.0 / (getUnitInfo(source_unit_spec).to_si * getUnitInfo(unit_target_spectral).to_si);
		}
		else
		{
			is_spectral_dimension_mismatch = false;
			scale_spec = scaleUnit(source_unit_spec, unit_target_spectral);
		}

		double scale_value = scaleUnit(source_unit_value, unit_target_value);

		// 戻り値の構築 {{spec, nr, ni}, ...}
		std::vector<std::vector<double>> result(n_data);
		for(size_t i = 0; i < n_data; ++i)
		{
			if(is_spectral_dimension_mismatch == true)
			{
				result[i] = {1.0 / buf_spec[i] * scale_spec, buf_value[i] * scale_value};
			}
			else
			{
				result[i] = {buf_spec[i] * scale_spec, buf_value[i] * scale_value};
			}
		}

		std::sort(result.begin(), result.end(), [](const auto& a, const auto& b){return a[0] < b[0];});

		return result;
	}
	catch(const netcdf::exceptions::NcException& e)
	{
		throw std::runtime_error("NetCDF Error in " + filename + ": " + std::string(e.what()));
	}
}

inline std::vector<std::vector<double>> loadRefractiveIndexSpectralFile(std::string filename, std::string var_name_spectral, std::string var_name_nr, std::string var_name_ni, std::string unit_target_spectral)
{
	try
	{
		netCDF::NcFile dataFile(filename, NcFile::read);

		auto getVarSafe = [&](std::string name) -> netCDF::NcVar
		{
			netCDF::NcVar var = dataFile.getVar(name);
			if(var.isNull())
			{
				throw std::runtime_error("NetCDF Variable '" + name + "' not found in " + filename);
			}
			return var;
		};

		netCDF::NcVar v_spec = getVarSafe(var_name_spectral);
		netCDF::NcVar v_nr = getVarSafe(var_name_nr);
		netCDF::NcVar v_ni = getVarSafe(var_name_ni);

		size_t n_data = v_spec.getDim(0).getSize();
		
		// 次元整合性チェック
		if (v_nr.getDim(0).getSize() != n_data || v_ni.getDim(0).getSize() != n_data)
		{
			throw std::runtime_error("Dimension size mismatch in refractive index file.");
		}

		// 単位変換 (屈折率は無次元なので、スペクトルのみ計算)
		std::string source_unit_spec;
		try
		{
			netCDF::NcVarAtt att = v_spec.getAtt("units");
			if(!att.isNull()) att.getValues(source_unit_spec);
		}
		catch(...)
		{
			std::cout << "[Warning] 'units' missing for " << var_name_spectral << ". Assuming " << unit_target_spectral << "." << std::endl;
			source_unit_spec = unit_target_spectral;
		}

		// double scale_spec = scaleUnit(source_unit_spec, unit_target_spectral);

		// データ読み込み
		std::vector<double> buf_spec(n_data);
		std::vector<double> buf_nr(n_data);
		std::vector<double> buf_ni(n_data);

		v_spec.getVar(buf_spec.data());
		v_nr.getVar(buf_nr.data());
		v_ni.getVar(buf_ni.data());

		bool is_spectral_dimension_mismatch;
		double scale_unit;

		if(getUnitInfo(unit_target_spectral).dim != getUnitInfo(source_unit_spec).dim)
		{
			is_spectral_dimension_mismatch = true;
			scale_unit = 1.0 / (getUnitInfo(source_unit_spec).to_si * getUnitInfo(unit_target_spectral).to_si);
		}
		else
		{
			is_spectral_dimension_mismatch = false;
			scale_unit = scaleUnit(source_unit_spec, unit_target_spectral);
		}

		// 戻り値の構築 {{spec, nr, ni}, ...}
		std::vector<std::vector<double>> result(n_data);
		for(size_t i = 0; i < n_data; ++i)
		{
			if(is_spectral_dimension_mismatch == true)
			{
				result[i] = {1.0 / buf_spec[i] * scale_unit, buf_nr[i], buf_ni[i]};
			}
			else
			{
				result[i] = {buf_spec[i] * scale_unit, buf_nr[i], buf_ni[i]};
			}
		}

		std::sort(result.begin(), result.end(), [](const auto& a, const auto& b){return a[0] < b[0];});

		return result;
	}
	catch(const netcdf::exceptions::NcException& e)
	{
		throw std::runtime_error("NetCDF Error in " + filename + ": " + std::string(e.what()));
	}
}

inline std::vector<std::vector<std::vector<double>>> loadRefractiveIndexSpectralVerticalFile(std::string filename, std::string var_name_altitude, std::string var_name_spectral, std::string var_name_nr, std::string var_name_ni, std::string unit_target_altitude, std::string unit_target_spectral)
{
	try
	{
		netCDF::NcFile dataFile(filename, netCDF::NcFile::read);

		// ヘルパー: 変数取得と存在チェック
		auto getVarSafe = [&](std::string name) -> netCDF::NcVar
		{
			netCDF::NcVar var = dataFile.getVar(name);
			if(var.isNull())
			{
				throw std::runtime_error("NetCDF Variable '" + name + "' not found in " + filename);
			}
			return var;
		};

		// 1. 変数オブジェクトの取得
		netCDF::NcVar v_alt = getVarSafe(var_name_altitude);
		netCDF::NcVar v_spec = getVarSafe(var_name_spectral);
		netCDF::NcVar v_nr = getVarSafe(var_name_nr);
		netCDF::NcVar v_ni = getVarSafe(var_name_ni);

		// 2. 次元の取得 (変数の次元を参照する)
		// ※変数名と次元名が異なっていても対応できるように getDim(0) を使用
		size_t n_alt = v_alt.getDim(0).getSize();
		size_t n_spec = v_spec.getDim(0).getSize();

		// 2Dデータの次元チェック (念のため)
		if (v_nr.getDimCount() != 2 || v_ni.getDimCount() != 2)
		{
			throw std::runtime_error("Refractive index variables (nr, ni) must be 2D [altitude, spectral].");
		}

		// 3. 単位変換係数の計算
		// (NetCDFの "units" 属性を読み、ターゲット単位との比率を計算)

		// 単位変換
		std::string source_unit_spec;
		try
		{
			netCDF::NcVarAtt att = v_spec.getAtt("units");
			if(!att.isNull()) att.getValues(source_unit_spec);
		}
		catch(...)
		{
			std::cout << "[Warning] 'units' missing for " << var_name_spectral << ". Assuming " << unit_target_spectral << "." << std::endl;
			source_unit_spec = unit_target_spectral;
		}

		std::string source_unit_alt;
		try
		{
			netCDF::NcVarAtt att = v_alt.getAtt("units");
			if(!att.isNull()) att.getValues(source_unit_alt);
		}
		catch(...)
		{
			std::cout << "[Warning] 'units' missing for " << var_name_altitude << ". Assuming " << unit_target_altitude << "." << std::endl;
			source_unit_alt = unit_target_altitude;
		}

		bool is_spectral_dimension_mismatch;
		double scale_spec;

		if(getUnitInfo(unit_target_spectral).dim != getUnitInfo(source_unit_spec).dim)
		{
			is_spectral_dimension_mismatch = true;
			scale_spec = 1.0 / (getUnitInfo(source_unit_spec).to_si * getUnitInfo(unit_target_spectral).to_si);
		}
		else
		{
			is_spectral_dimension_mismatch = false;
			scale_spec = scaleUnit(source_unit_spec, unit_target_spectral);
		}

		double scale_alt = scaleUnit(source_unit_alt, unit_target_altitude);

		// 4. データの読み込み & スケーリング
		std::vector<double> altitudes(n_alt);
		v_alt.getVar(altitudes.data());
		for(auto& v : altitudes)
		{
			v *= scale_alt; // 単位変換
		}

		std::vector<double> spectral_grid(n_spec);
		v_spec.getVar(spectral_grid.data());
		for(auto& v : spectral_grid)
		{
			if(is_spectral_dimension_mismatch == true)
			{
				v = 1.0 / v * scale_spec; // 単位変換
			}
			else
			{
				v = v * scale_spec; // 単位変換
			}
		}

		// 5. 2Dデータの読み込み
		// NetCDF C++ はフラットな1次元配列に読み込む (順序: dim0(alt) -> dim1(spec))
		std::vector<double> buffer_nr(n_alt * n_spec);
		std::vector<double> buffer_ni(n_alt * n_spec);

		v_nr.getVar(buffer_nr.data());
		v_ni.getVar(buffer_ni.data());

		// 6. 戻り値の形式に整形
		// [Layer][Spec][Alt, Wl, Nr, Ni]
		std::vector<std::vector<std::vector<double>>> result(n_alt);

		// 高度方向のループ
		for(size_t i = 0; i < n_alt; ++i)
		{
			result[i].resize(n_spec);
			double current_alt = altitudes[i];

			// スペクトル方向のループ
			for(size_t k = 0; k < n_spec; ++k)
			{
				size_t idx = i * n_spec + k; // フラットインデックス
				
				result[i][k] = {current_alt, spectral_grid[k], buffer_nr[idx], buffer_ni[idx]};
			}

			std::sort(result[i].begin(), result[i].end(), [](const std::vector<double>& a, const std::vector<double>& b){return a[1] < b[1];});
		}

		std::sort(result.begin(), result.end(), [](const std::vector<std::vector<double>>& a, const std::vector<std::vector<double>>& b){return a[0][0] < b[0][0];});

		return result;
	}
	catch(const netcdf::exceptions::NcException& e)
	{
		throw std::runtime_error("NetCDF Error in " + filename + ": " + std::string(e.what()));
	}
}















std::vector<std::vector<double>> importCrossSection(std::string);
std::vector<std::vector<double>> importSizeDistribution(std::string);
std::vector<std::vector<double>> importScatteringPhaseFunction(std::string);
std::vector<std::vector<double>> importRefractiveIndex(std::string);

void computeMieScatteringLogNormal(int, int, double, double, double, std::complex<double>, double&, double&, double&, std::vector<std::vector<double>>&);
std::vector<std::vector<double>> generateLogNormalSizeDistribution(double, double, int);
std::vector<std::vector<double>> computeRayleighScatteringFunction(int);
double planck_source(double, double, double);
double computeAsymmetryParameter(const std::vector<std::vector<double>>&);

inline void Layer::normalizeScatteringPhaseFunction(void)
{
	std::vector<std::vector<double>> phase_function_theta(scattering_phase_function.size());

	for(int i = 0; i < scattering_phase_function.size(); i ++)
	{
		phase_function_theta[i] = {scattering_phase_function[i][0], scattering_phase_function[i][1] * 2.0 * PI * std::sin(scattering_phase_function[i][0])};
	}
	//std::cout << phase_function_theta.size() << std::endl;
	double sum = computeSimpsonIntegration(phase_function_theta) / (4.0 * PI);

	for(int i = 0; i < scattering_phase_function.size(); i ++)
	{
		scattering_phase_function[i][1] /= sum;
	}
	//normalizeScatteringPhaseFunction(scattering_phase_function);

	return;
}

// f: scattering phase function, scattering_angle: scattering angle [0, pi]
inline double RadiativeTransfer::computePhaseFunction(const std::vector<std::vector<double>>& f, double scattering_angle)
{
	double theta_min = f[0][0];
	double theta_max = f[f.size() - 1][0];
	double dtheta = std::abs(f[1][0] - f[0][0]);

	int ntheta = (scattering_angle - theta_min) / dtheta;
	double result;

	if(ntheta == f.size() - 1)
	{
		result = f[ntheta][1];
	}
	else if(ntheta == 0)
	{
		result = f[0][1];
	}
	else
	{
		result = (f[ntheta][1] * (f[ntheta + 1][0] - scattering_angle) + f[ntheta + 1][1] * (scattering_angle - f[ntheta][0])) / (f[ntheta + 1][0] - f[ntheta][0]);
	}
	
	return result;
}

inline double Species::computeMixingRatio(double z)
{
	double mr = 0.0;

	for(int i = 0; i < vertical_profile.size() - 1; i ++)
	{
		if(vertical_profile[i][0] <= z && z <= vertical_profile[i + 1][0])
		{
			if(vertical_profile_interpolation == VerticalProfileInterpolation::Linear)
			{
				double r = (z - vertical_profile[i][0]) / (vertical_profile[i + 1][0] - vertical_profile[i][0]);
				return vertical_profile[i][1] * (1.0 - r) + r * vertical_profile[i + 1][1];
			}
			else if(vertical_profile_interpolation == VerticalProfileInterpolation::Exponential)
			{
				double H = -(vertical_profile[i + 1][0] - vertical_profile[i][0]) / (std::log(vertical_profile[i + 1][1]) - std::log(vertical_profile[i][1]));
				return vertical_profile[i][1] * std::exp(-(z - vertical_profile[i][0]) / H);
			}
		}
	}

	return mr;
}

inline double Species::computeNumberDensity(double z)
{
	double mr = 0.0;

	for(int i = 0; i < vertical_profile.size() - 1; i ++)
	{
		if(vertical_profile[i][0] <= z && z <= vertical_profile[i + 1][0])
		{
			if(vertical_profile_interpolation == VerticalProfileInterpolation::Linear)
			{
				double r = (z - vertical_profile[i][0]) / (vertical_profile[i + 1][0] - vertical_profile[i][0]);
				return vertical_profile[i][1] * (1.0 - r) + r * vertical_profile[i + 1][1];
			}
			else if(vertical_profile_interpolation == VerticalProfileInterpolation::Exponential)
			{
				double H = -(vertical_profile[i + 1][0] - vertical_profile[i][0]) / (std::log(vertical_profile[i + 1][1]) - std::log(vertical_profile[i][1]));
				return vertical_profile[i][1] * std::exp(-(z - vertical_profile[i][0]) / H);
			}
		}
	}

	return mr;
}

inline std::complex<double> Species::computeRefractiveIndex(double z)
{
	std::complex<double> mr = {1.5, 0.0};

	for(int i = 0; i < refractive_index_vertical_profile.size() - 1; i ++)
	{
		if(refractive_index_vertical_profile[i][0] <= z && z <= refractive_index_vertical_profile[i + 1][0])
		{
			if(vertical_profile_interpolation == VerticalProfileInterpolation::Linear)
			{
				double r = (z - refractive_index_vertical_profile[i][0]) / (refractive_index_vertical_profile[i + 1][0] - refractive_index_vertical_profile[i][0]);
				double nr_int = refractive_index_vertical_profile[i][1] * (1.0 - r) + r * refractive_index_vertical_profile[i + 1][1];
				double ni_int = refractive_index_vertical_profile[i][2] * (1.0 - r) + r * refractive_index_vertical_profile[i + 1][2];
				return std::complex<double>{nr_int, ni_int};
			}
			else if(vertical_profile_interpolation == VerticalProfileInterpolation::Exponential)
			{
				double H = -(refractive_index_vertical_profile[i + 1][0] - refractive_index_vertical_profile[i][0]) / (std::log(refractive_index_vertical_profile[i + 1][1]) - std::log(refractive_index_vertical_profile[i][1]));
				double nr_int = refractive_index_vertical_profile[i][1] * std::exp(-(z - refractive_index_vertical_profile[i][0]) / H);
				double ni_int = refractive_index_vertical_profile[i][2] * std::exp(-(z - refractive_index_vertical_profile[i][0]) / H);
				return std::complex<double>{nr_int, ni_int};
			}
		}
	}

	return mr;
}

inline void normalizeScatteringPhaseFunction(std::vector<std::vector<double>> &f)
{
	std::vector<std::vector<double>> phase_function_theta(f.size());

	for(int i = 0; i < f.size(); i ++)
	{
		phase_function_theta[i] = {f[i][0], f[i][1] * 2.0 * PI * std::sin(f[i][0])};
	}

	double sum = computeSimpsonIntegration(phase_function_theta) / (4.0 * PI);

	for(int i = 0; i < f.size(); i ++)
	{
		f[i][1] /= sum;
	}

	return;
}

inline std::vector<std::vector<double>> importCrossSection(std::string filename)
{
	std::ifstream input(filename);
	std::string str;

	std::vector<std::vector<double>> spectrum;

	while(std::getline(input, str))
	{
		//std::cout << str << std::endl;
		if(str[0] != '#' && str.size() > 3)
		{
			auto data = splitString(str, ',');
			std::vector<double> temp = {std::stod(data[0]), std::stod(data[1])};
			spectrum.push_back(temp);
		}
	}

	std::sort(spectrum.begin(), spectrum.end(),[](std::vector<double>& v1, std::vector<double>& v2) {return v1[0] < v2[0];});

	return spectrum;
}

inline std::vector<std::vector<double>> importSizeDistribution(std::string filename)
{
	std::ifstream input(filename);
	std::string str;

	std::vector<std::vector<double>> size_distribution;

	while(std::getline(input, str))
	{
		if(str[0] != '#' && str.size() > 3)
		{
			auto data = splitString(str, ',');
			std::vector<double> temp = {std::stod(data[0]), std::stod(data[1])};
			size_distribution.push_back(temp);
		}
	}

	std::sort(size_distribution.begin(), size_distribution.end(),[](std::vector<double>& v1, std::vector<double>& v2) {return v1[0] < v2[0];});

	return size_distribution;
}

inline std::vector<std::vector<double>> importScatteringPhaseFunction(std::string filename)
{
	std::ifstream input(filename);
	std::string str;

	std::vector<std::vector<double>> phase_function;

	while(std::getline(input, str))
	{
		if(str[0] != '#' && str.size() > 3)
		{
			auto data = splitString(str, ',');
			std::vector<double> temp = {std::stod(data[0]), std::stod(data[1])};
			phase_function.push_back(temp);
		}
	}

	std::sort(phase_function.begin(), phase_function.end(),[](std::vector<double>& v1, std::vector<double>& v2) {return v1[0] < v2[0];});

	return phase_function;
}

inline std::vector<std::vector<double>> importRefractiveIndex(std::string filename)
{
	std::ifstream input(filename);
	std::string str;

	std::vector<std::vector<double>> refractive_index;

	while(std::getline(input, str))
	{
		if(str[0] != '#' && str.size() > 3)
		{
			auto data = splitString(str, ',');
			std::vector<double> temp = {std::stod(data[0]), std::stod(data[1]), std::stod(data[2])};
			// temp[0] *= scaleUnit(atmosphere_model.species[i].unit_input_wavelength, "m");
			refractive_index.push_back(temp);
		}
	}

	std::sort(refractive_index.begin(), refractive_index.end(),[](std::vector<double>& v1, std::vector<double>& v2) {return v1[0] < v2[0];});

	return refractive_index;
}



// inline void computeMieScattering(int n_theta, const std::vector<std::vector<double>>& size_distribution, int n_radius, double wavelength, std::complex<double> refractive_index, double& scattering_cross_section, double& absorption_cross_section, double& extinction_cross_section, std::vector<std::vector<double>>& phase_function)
// {	
// 	if(size_distribution.size() == 1)
// 	{
// 		computeMieScattering(n_theta, size_distribution[0][0], wavelength, refractive_index, scattering_cross_section, absorption_cross_section, extinction_cross_section, phase_function);
// 		normalizeScatteringPhaseFunction(phase_function);

// 		return;
// 	}

// 	if(n_radius % 2 == 0)
// 	{
// 		n_radius ++;
// 	}

// 	if(n_theta % 2 == 0)
// 	{
// 		n_theta ++;
// 	}

// 	phase_function.clear();
// 	phase_function.resize(n_theta);

// 	scattering_cross_section = 0.0;
// 	absorption_cross_section = 0.0;
// 	extinction_cross_section = 0.0;

// 	std::vector<std::vector<double>> sigma_s, sigma_a, sigma_e;

// 	double radius_min = size_distribution[0][0];
// 	double radius_max = size_distribution[size_distribution.size() - 1][0];

// 	std::vector<double> radius(n_radius);
	
// 	for(int i = 0; i < radius.size(); i ++)
// 	{
// 		radius[i] = radius_min + (radius_max - radius_min) / double(n_radius - 1) * double(i);
// 	}

// 	std::vector<std::vector<double>> size_distribution_resampled(radius.size(), {0.0, 0.0});

// 	for(int nr = 0; nr < radius.size(); nr ++)
// 	{
// 		size_distribution_resampled[nr][0] = radius[nr];

// 		for (int i = 0; i < size_distribution.size() - 1; i++)
// 		{
// 			if (size_distribution[i][0] <= radius[nr] && radius[nr] <= size_distribution[i + 1][0])
// 			{
// 				double r = (radius[nr] - size_distribution[i][0]) / (size_distribution[i + 1][0] - size_distribution[i][0]);
// 				size_distribution_resampled[nr][1] = size_distribution[i][1] + r * (size_distribution[i + 1][1] - size_distribution[i][1]);

// 				break;
// 			}
// 		}
// 	}

// 	//std::vector<std::vector<double>> pf_wl(ntheta, {0.0, 0.0}); // 波長方向の位相関数
// 	for(int i = 0; i < phase_function.size(); i ++)
// 	{
// 		double theta = PI / double(n_theta - 1) * double(i);

// 		phase_function[i] = {theta, 0.0};
// 	}

// 	std::vector<std::vector<std::vector<double>>> pf_r(n_theta);

// 	std::vector<std::vector<double>> int_size_distribution;
// 	// ガウス求積で粒径方向の積分
// 	for (int nr = 0; nr < radius.size(); nr++)
// 	{
// 		double sigma_s_r, sigma_a_r, sigma_e_r;
// 		std::vector<std::vector<double>> pf_r_temp;

// 		// 粒径に対するMie散乱計算
// 		computeMieScattering(n_theta, radius[nr], wavelength, refractive_index, sigma_s_r, sigma_a_r, sigma_e_r, pf_r_temp);
// 		//std::cout << radius[nr] << ", " << wavelength[nw] << ", " << index[nw] << std::endl;
// 		sigma_s.push_back({radius[nr], sigma_s_r * size_distribution_resampled[nr][1]});
// 		sigma_a.push_back({radius[nr], sigma_a_r * size_distribution_resampled[nr][1]});
// 		sigma_e.push_back({radius[nr], sigma_e_r * size_distribution_resampled[nr][1]});
// 		int_size_distribution.push_back({radius[nr], size_distribution_resampled[nr][1]});

// 		for (int nt = 0; nt < n_theta; nt++)
// 		{
// 			pf_r[nt].push_back({radius[nr], pf_r_temp[nt][1] * sigma_s_r * size_distribution_resampled[nr][1]});
// 		}
// 	}

// 	double int_size_dist = computeSimpsonIntegration(int_size_distribution);

// 	scattering_cross_section = computeSimpsonIntegration(sigma_s) / int_size_dist;
// 	absorption_cross_section = computeSimpsonIntegration(sigma_a) / int_size_dist;
// 	extinction_cross_section = computeSimpsonIntegration(sigma_e) / int_size_dist;

// 	for (int nt = 0; nt < n_theta; nt ++)
// 	{
// 		phase_function[nt][1] = computeSimpsonIntegration(pf_r[nt]);
// 	}

// 	normalizeScatteringPhaseFunction(phase_function);

// 	return;
// }

inline void computeMieScatteringLogNormal(int n_theta, int n_radius, double r_g, double sigma_g, double wavelength, std::complex<double> refractive_index, double& scattering_cross_section, double& absorption_cross_section, double& extinction_cross_section, std::vector<std::vector<double>>& phase_function)
{
	auto avgMieLogNormal = [](double r_g, double sigma_g, int nsd, int nangle, double wavelength, std::complex<double> refractive_index, double& c_sca, double& c_abs, double& c_ext, std::vector<std::vector<double>>& spf)
	{
		if (nsd < 3)
		{
			nsd = 3;
		}

		if (nsd % 2 == 0)
		{
			++nsd; // Simpson 用に奇数点
		}
	
		// 1) log‐normal 分布テーブル生成 (r_i, pdf_i)
		auto dist_tbl = generateLogNormalSizeDistribution(r_g, sigma_g, nsd);
	
		// ln r 等間隔確認 & Δln r 取得
		std::vector<double> ln_r(nsd), pdf(nsd);
		for (int i = 0; i < nsd; ++i)
		{
			ln_r[i] = std::log(dist_tbl[i][0]);
			//std::cout << dist_tbl[i][0] << ", " << ln_r[i] << ", " << dist_tbl[i][1] << std::endl;
			pdf[i] = dist_tbl[i][1];
		}
		double h = ln_r[1] - ln_r[0];        // Δln r (一定)
	
		// 2) 積分ループ (Simpson)
		c_sca = 0.0;
		c_abs = 0.0;
		c_ext = 0.0;
		spf.clear();
		spf.assign(nangle, {0.0, 0.0});

		for(int k = 0; k < nangle; ++k)
		{
			spf[k][0] = PI * double(k) / double(nangle - 1);
		}
	
		double Csca_sum = 0.0;
		double Cabs_sum = 0.0;
		double Cext_sum = 0.0;
		double norm_sum = 0.0;
	
		auto coeff = [&](int i){return (i == 0 || i == nsd - 1) ? 1.0 : (i % 2 ? 4.0 : 2.0);};
	
		for(int i = 0 ; i < nsd; ++i)
		{
			double r = dist_tbl[i][0];
			double w_i = pdf[i] * r * coeff(i); // ヤコビアン×Simpson 係数
	
			double Cs, Ca, Ce;
			std::vector<std::vector<double>> spf_tmp;
			computeMieScattering(nangle, r, wavelength, refractive_index, Cs, Ca, Ce, spf_tmp);

			// std::cout << r << ", " << w_i << ", " << Cs << ", " << Ca << ", " << Ce << std::endl;
	
			Csca_sum += w_i * Cs;
			Cabs_sum += w_i * Ca;
			Cext_sum += w_i * Ce;
			norm_sum += w_i;
	
			for(int k = 0; k < nangle; ++k)
			{
				spf[k][1] += w_i * Cs * spf_tmp[k][1];
			}
		}
	
		Csca_sum *= h / 3.0;
		Cabs_sum *= h / 3.0;
		Cext_sum *= h / 3.0;
		norm_sum *= h / 3.0;
	
		c_sca = Csca_sum / norm_sum;
		c_abs = Cabs_sum / norm_sum;
		c_ext = Cext_sum / norm_sum;
	
		for(int k = 0; k < nangle; ++k)
		{
			spf[k][1] = spf[k][1] * h / 3.0 / Csca_sum;
		}
	
		return;
	};

	if(n_radius % 2 == 0)
	{
		n_radius ++;
	}

	if(n_theta % 2 == 0)
	{
		n_theta ++;
	}

	phase_function.clear();
	phase_function.resize(n_theta);

	scattering_cross_section = 0.0;
	absorption_cross_section = 0.0;
	extinction_cross_section = 0.0;
	
	for(int i = 0; i < phase_function.size(); i ++)
	{
		double theta = PI / double(n_theta - 1) * double(i);

		phase_function[i] = {theta, 0.0};
	}
	
	avgMieLogNormal(r_g, sigma_g, n_radius, n_theta, wavelength, refractive_index, scattering_cross_section, absorption_cross_section, extinction_cross_section, phase_function);

	normalizeScatteringPhaseFunction(phase_function);

	return;
}

inline std::vector<std::vector<double>> generateLogNormalSizeDistribution(double r_g, double sigma_g, int nsd)
{
	auto logspace_ln = []( double r_min, double r_max, int n)
	{
		std::vector<double> result(n);
		double ln_min = std::log(r_min);
		double ln_max = std::log(r_max);
		double dln    = (ln_max - ln_min) / double(n - 1);
	
		for (int i = 0; i < n; ++i)
		{
			result[i] = std::exp(ln_min + dln * double(i));
		}
		return result;
	};

	//sigma_g is used in the textbook "Transfer of polarized light in planetary atmospheres"
	//sigma_g = log(sigma), sigma is the value used in the Pollack et al., 1980
	std::vector<std::vector<double>> result;

	//std::cout << r_g << ", " << sigma_g << std::endl;

	if(nsd % 2 == 0)
	{
		nsd ++;
	}

	double cdf_start = 0.005;
	double cdf_end = 0.995;

	double r_start = r_g * std::exp(sigma_g * std::sqrt(2.0) * computeInverseErrorFunction(2.0 * cdf_start - 1.0, sigma_g * 1.0E-5, 100));
	double r_end = r_g * std::exp(sigma_g * std::sqrt(2.0) * computeInverseErrorFunction(2.0 * cdf_end - 1.0, sigma_g * 1.0E-5, 100));
	//double dr = (r_end - r_start) / double(nsd - 1);

	auto r_list = logspace_ln(r_start, r_end, nsd);

	for (int i = 0; i < nsd; ++i)
	{
		double r = r_list[i];
		double ln  = std::log(r / r_g);
		double pdf = (1.0 / (sigma_g * r * std::sqrt(2.0 * PI))) * std::exp(-ln * ln / (2.0 * sigma_g * sigma_g));
		result.push_back({r, pdf});
	}

	// std::cout << r_start << ", " << r_end << ", " << dr << std::endl;

	// for(int i = 0; i < nsd; i ++)
	// {
	// 	double r = r_start + double(i) * dr;

	// 	if(r > 0.0 && r_g > 0 && sigma_g > 0)
	// 	{
	// 		double sd = 1.0 / (sigma_g * r * std::sqrt(2.0 * PI));
	// 		double ln = std::log(r / r_g);
	// 		sd *= std::exp(-ln * ln / (2.0 * sigma_g * sigma_g));

	// 		std::vector<double> temp = {r, sd};

	// 		result.push_back(temp);
	// 	}
	// }

	return result;
}

inline std::vector<std::vector<double>> computeRayleighScatteringFunction(int ntheta)
{
	if(ntheta % 2 == 0)
	{
		ntheta ++;
	}

	std::vector<std::vector<double>> phase_function(ntheta);

	for(int i = 0; i < ntheta; i ++)
	{
		double theta = PI * double(i) / double(ntheta - 1);
		phase_function[i] = {theta, 3.0 / 4.0 * (1.0 + std::cos(theta) * std::cos(theta))};
	}

	return phase_function;
}

inline double planck_source(double B, double tau, double mu)
{
	// std::cout << B << ", " << tau << ", " << mu << std::endl;
	// 1 – exp(‑τ/μ)  ---  use expm1 for numerical safety when τ is very small.
	return B * (-std::expm1(-tau / mu));
}

inline void RadiativeTransfer::initializeLayer(Layer& layer)
{
	while(layer.optical_thickness > configuration.tau_initial_layer)
	{
		layer.optical_thickness /= 2.0;
		layer.n_doubling ++;
	}

	layer.reflectance_m_top_cos = std::vector<Eigen::MatrixXd>(M + 1, Eigen::MatrixXd::Zero(Ntheta, Ntheta));
	layer.reflectance_m_bottom_cos = std::vector<Eigen::MatrixXd>(M + 1, Eigen::MatrixXd::Zero(Ntheta, Ntheta));
	layer.transmittance_m_top_cos = std::vector<Eigen::MatrixXd>(M + 1, Eigen::MatrixXd::Zero(Ntheta, Ntheta));
	layer.transmittance_m_bottom_cos = std::vector<Eigen::MatrixXd>(M + 1, Eigen::MatrixXd::Zero(Ntheta, Ntheta));
	
	layer.reflectance_m_top_sin = std::vector<Eigen::MatrixXd>(M + 1, Eigen::MatrixXd::Zero(Ntheta, Ntheta));
	layer.reflectance_m_bottom_sin = std::vector<Eigen::MatrixXd>(M + 1, Eigen::MatrixXd::Zero(Ntheta, Ntheta));
	layer.transmittance_m_top_sin = std::vector<Eigen::MatrixXd>(M + 1, Eigen::MatrixXd::Zero(Ntheta, Ntheta));
	layer.transmittance_m_bottom_sin = std::vector<Eigen::MatrixXd>(M + 1, Eigen::MatrixXd::Zero(Ntheta, Ntheta));

	layer.reflectance_top = std::vector<std::vector<std::vector<double>>>(Ntheta, std::vector<std::vector<double>>(Ntheta, std::vector<double>(Nphi)));
	layer.reflectance_bottom = std::vector<std::vector<std::vector<double>>>(Ntheta, std::vector<std::vector<double>>(Ntheta, std::vector<double>(Nphi)));
	layer.transmittance_top = std::vector<std::vector<std::vector<double>>>(Ntheta, std::vector<std::vector<double>>(Ntheta, std::vector<double>(Nphi)));
	layer.transmittance_bottom = std::vector<std::vector<std::vector<double>>>(Ntheta, std::vector<std::vector<double>>(Ntheta, std::vector<double>(Nphi)));

	layer.source_up = Eigen::VectorXd::Zero(Ntheta);
	layer.source_down = Eigen::VectorXd::Zero(Ntheta);

	int n_samp = configuration.n_icss_sample;
	bool enable_ssp = configuration.icss_type == InCellSuperSamplingType::Enable;

	if(configuration.delta_approximation_type != DeltaApproximationType::Disable)
	{
		// std::cout << "Delta-M approximation" << std::endl;
		double norm = 0;
		double m1 = 0;
		double m2 = 0;
		std::vector<double> cumsum(layer.scattering_phase_function.size());

		double dtheta = layer.scattering_phase_function[1][0] - layer.scattering_phase_function[0][0];

		for(int i = 0; i < layer.scattering_phase_function.size(); i ++)
		{
			double theta = layer.scattering_phase_function[i][0];
			double w = std::sin(theta) * dtheta;
			norm += layer.scattering_phase_function[i][1] * w;
			m1 += layer.scattering_phase_function[i][1] * std::cos(theta) * w;
			m2 += layer.scattering_phase_function[i][1] * 0.5 * (3.0 * std::cos(theta) * std::cos(theta) - 1.0) * w;
			cumsum [i] = norm;
		}

		if(norm <= 0.0)
		{
			norm = 1.0;
		}

		m1 /= norm;
		m2 /= norm;

		double f = 0.0;

		if(configuration.delta_approximation_type == DeltaApproximationType::d_m1)
		{
			f = m1 * m1;
		}
		else if(configuration.delta_approximation_type == DeltaApproximationType::d_m2)
		{
			f = m2;
		}
		else if(configuration.delta_approximation_type == DeltaApproximationType::Cumulative)
		{
			int lo = 0;
			int hi = layer.scattering_phase_function.size() - 1;

			while(hi - lo > 1)
			{
				int mid = (lo + hi) / 2;
				if (cumsum[mid] / norm >= configuration.f)
				{
					hi = mid;
				}
				else
				{
					lo = mid;
				}
			}

			f = cumsum[hi] / norm;  // 実際に抜き取る面積
		}
		else if(configuration.delta_approximation_type == DeltaApproximationType::FWHM)
		{
			std::vector<double> tail;
			tail.reserve(layer.scattering_phase_function.size() / 2);
			for(int i = 0; i < layer.scattering_phase_function.size(); ++i)
			{
				if (layer.scattering_phase_function[i][0] > PI / 2.0)
				{
					tail.push_back(layer.scattering_phase_function[i][1]); // 位相関数値だけ抜き出し
				}
			}
			if (tail.empty())
			{
				tail.clear();
				tail.reserve(layer.scattering_phase_function.size());
				for(int i = 0; i < layer.scattering_phase_function.size(); ++i)
				{
					tail.push_back(layer.scattering_phase_function[i][1]); 
				}
			}

			// 中央値を nth_element で求める
			std::nth_element(tail.begin(), tail.begin() + tail.size() / 2, tail.end());
			double B = tail[tail.size() / 2];   // background

			// 3) ピーク H
			double H = layer.scattering_phase_function[0][1];

			// 4) 閾値 T
			double T = B + configuration.fwhm_ratio * (H - B);

			// 5) 最小インデックス kc s.t. P[k][1] <= T
			int kc = layer.scattering_phase_function.size() - 1;

			for(int k = 0; k < layer.scattering_phase_function.size(); k ++)
			{
				if(layer.scattering_phase_function[k][1] <= T)
				{
					kc = k;
					break;
				}
			}

			// 6) 実際に抜き取る面積 f = cumsum[kc]/norm
			f = cumsum[kc] / norm;
		}

		double tau0 = layer.optical_thickness;
		double omega0 = layer.single_scattering_albedo;
		double denom = 1.0 - omega0 * f;
		layer.optical_thickness = (1.0 - omega0 * f) * tau0;
		layer.single_scattering_albedo = (1.0 - f) * omega0 / denom;

		/* --- 3. 位相関数の部分スケール（θ ≤ θc を同率減） ------------------- */

		/* θc に対応するインデックス k_cut：cumsum[k_cut]/norm ≧ f */
		int k_cut = 0;
		for (int k = 0; k < layer.scattering_phase_function.size(); ++ k)
		{
			if (cumsum[k] / norm >= f)
			{
				k_cut = k; break;
			}
		}

		/* θ ≤ θc 部分の面積  */
		const double A_c = cumsum[k_cut];          // 未正規化面積
		double alpha = (f * norm) / A_c;           // 縮小率 α
		alpha = std::clamp(alpha, 0.0, 1.0);       // 数値安全

		/* 位相関数の更新 */
		for (int i = 0; i < layer.scattering_phase_function.size(); ++ i)
		{
			double Pold = layer.scattering_phase_function[i][1];
			double Pnew = (i <= k_cut) ? Pold * (1.0 - alpha)  : Pold;
			Pnew /= (1.0 - f);
			layer.scattering_phase_function[i][1] = Pnew;
		}
	}

	// #pragma omp parallel for
	for(int e_n = 0; e_n < Ntheta; e_n ++)
	{
		//std::cout << layer.planck_function << std::endl;
		layer.source_up(e_n) = (1.0 - layer.single_scattering_albedo) * planck_source(layer.planck_function, layer.optical_thickness, geometry.mu_uh(e_n));
		layer.source_down(e_n) = (1.0 - layer.single_scattering_albedo) * planck_source(layer.planck_function, layer.optical_thickness, geometry.mu_lh(e_n));
	}

	//#pragma omp parallel for
	for(int e = 0; e < Ntheta; e ++)
	{
		for(int i = 0; i < Ntheta; i ++)
		{
			for(int p = 0; p < Nphi; p ++)
			{
				{// for R_top
					double theta_e = geometry.theta_uh(e);
					double theta_i = geometry.theta_lh(i);

					double xi = std::sin(theta_i);
					double yi = 0.0;
					double zi = std::cos(theta_i);

					double xe = std::sin(theta_e) * std::cos(geometry.phi[p]);
					double ye = std::sin(theta_e) * std::sin(geometry.phi[p]);
					double ze = std::cos(theta_e);

					double inner = xi * xe + yi * ye + zi * ze;
					double scattering_angle;
					if(inner >= 1.0)
					{
						scattering_angle = 0.0;
					}
					else if(inner <= -1.0)
					{
						scattering_angle = PI;
					}
					else
					{
						scattering_angle = std::acos(inner);
					}

					if(layer.single_scattering_albedo == 0.0)
					{
						layer.reflectance_top[e][i][p] = 0.0;
					}
					else
					{
						layer.reflectance_top[e][i][p] = layer.single_scattering_albedo * layer.optical_thickness / (4.0 * geometry.mu_lh(i) * geometry.mu_uh(e)) * computePhaseFunction(layer.scattering_phase_function, scattering_angle);
					}
				}

				{// for R_bottom
					double theta_e = geometry.theta_lh(e);
					double theta_i = geometry.theta_uh(i);

					double xi = std::sin(theta_i);
					double yi = 0.0;
					double zi = std::cos(theta_i);

					double xe = std::sin(theta_e) * std::cos(geometry.phi[p]);
					double ye = std::sin(theta_e) * std::sin(geometry.phi[p]);
					double ze = std::cos(theta_e);

					double inner = xi * xe + yi * ye + zi * ze;
					double scattering_angle;
					if(inner >= 1.0)
					{
						scattering_angle = 0.0;
					}
					else if(inner <= -1.0)
					{
						scattering_angle = PI;
					}
					else
					{
						scattering_angle = std::acos(inner);
					}

					if(layer.single_scattering_albedo == 0.0)
					{
						layer.reflectance_bottom[e][i][p] = 0.0;
					}
					else
					{
						layer.reflectance_bottom[e][i][p] = layer.single_scattering_albedo * layer.optical_thickness / (4.0 * geometry.mu_uh(i) * geometry.mu_lh(e)) * computePhaseFunction(layer.scattering_phase_function, scattering_angle);
					}
				}

				{// for T_top
					double theta_e = geometry.theta_lh(e);
					double theta_i = geometry.theta_lh(i);

					double xi = std::sin(theta_i);
					double yi = 0.0;
					double zi = std::cos(theta_i);

					double xe = std::sin(theta_e) * std::cos(geometry.phi[p]);
					double ye = std::sin(theta_e) * std::sin(geometry.phi[p]);
					double ze = std::cos(theta_e);

					double inner = xi * xe + yi * ye + zi * ze;
					double scattering_angle;
					if(inner >= 1.0)
					{
						scattering_angle = 0.0;
					}
					else if(inner <= -1.0)
					{
						scattering_angle = PI;
					}
					else
					{
						scattering_angle = std::acos(inner);
					}

					if(layer.single_scattering_albedo == 0.0)
					{
						layer.transmittance_top[e][i][p] = 0.0;
					}
					else
					{
						layer.transmittance_top[e][i][p] = layer.single_scattering_albedo * layer.optical_thickness / (4.0 * geometry.mu_lh(i) * geometry.mu_lh(e)) * computePhaseFunction(layer.scattering_phase_function, scattering_angle);
					}
				}

				{// for T_bottom
					double theta_e = geometry.theta_uh(e);
					double theta_i = geometry.theta_uh(i);

					double xi = std::sin(theta_i);
					double yi = 0.0;
					double zi = std::cos(theta_i);

					double xe = std::sin(theta_e) * std::cos(geometry.phi[p]);
					double ye = std::sin(theta_e) * std::sin(geometry.phi[p]);
					double ze = std::cos(theta_e);

					double inner = xi * xe + yi * ye + zi * ze;
					double scattering_angle;
					if(inner >= 1.0)
					{
						scattering_angle = 0.0;
					}
					else if(inner <= -1.0)
					{
						scattering_angle = PI;
					}
					else
					{
						scattering_angle = std::acos(inner);
					}

					if(layer.single_scattering_albedo == 0.0)
					{
						layer.transmittance_bottom[e][i][p] = 0.0;
					}
					else
					{
						layer.transmittance_bottom[e][i][p] = layer.single_scattering_albedo * layer.optical_thickness / (4.0 * geometry.mu_uh(i) * geometry.mu_uh(e)) * computePhaseFunction(layer.scattering_phase_function, scattering_angle);
					}
				}
			}
		}
	}

	// std::cout << "Computing Fouriere Series Expansion." << std::endl;
	computeFourierSeriesCoefficients(layer);

	layer.asymmetry_parameter = computeAsymmetryParameter(layer.scattering_phase_function);
	// std::cout << layer.asymmetry_parameter << std::endl;

	return;
}

inline void RadiativeTransfer::initializeSurface(Layer& layer)
{
	if(configuration.surface_type == SurfaceType::NoSurface)
	{
		;
	}
	else if(configuration.surface_type == SurfaceType::Lambert)
	{
		layer.reflectance_m_top_cos = std::vector<Eigen::MatrixXd>(M + 1, Eigen::MatrixXd::Zero(Ntheta, Ntheta));
		layer.reflectance_m_bottom_cos = std::vector<Eigen::MatrixXd>(M + 1, Eigen::MatrixXd::Zero(Ntheta, Ntheta));
		layer.transmittance_m_top_cos = std::vector<Eigen::MatrixXd>(M + 1, Eigen::MatrixXd::Zero(Ntheta, Ntheta));
		layer.transmittance_m_bottom_cos = std::vector<Eigen::MatrixXd>(M + 1, Eigen::MatrixXd::Zero(Ntheta, Ntheta));
		
		layer.reflectance_m_top_sin = std::vector<Eigen::MatrixXd>(M + 1, Eigen::MatrixXd::Zero(Ntheta, Ntheta));
		layer.reflectance_m_bottom_sin = std::vector<Eigen::MatrixXd>(M + 1, Eigen::MatrixXd::Zero(Ntheta, Ntheta));
		layer.transmittance_m_top_sin = std::vector<Eigen::MatrixXd>(M + 1, Eigen::MatrixXd::Zero(Ntheta, Ntheta));
		layer.transmittance_m_bottom_sin = std::vector<Eigen::MatrixXd>(M + 1, Eigen::MatrixXd::Zero(Ntheta, Ntheta));

		layer.reflectance_top = std::vector<std::vector<std::vector<double>>>(Ntheta, std::vector<std::vector<double>>(Ntheta, std::vector<double>(Nphi)));
		layer.reflectance_bottom = std::vector<std::vector<std::vector<double>>>(Ntheta, std::vector<std::vector<double>>(Ntheta, std::vector<double>(Nphi)));
		layer.transmittance_top = std::vector<std::vector<std::vector<double>>>(Ntheta, std::vector<std::vector<double>>(Ntheta, std::vector<double>(Nphi)));
		layer.transmittance_bottom = std::vector<std::vector<std::vector<double>>>(Ntheta, std::vector<std::vector<double>>(Ntheta, std::vector<double>(Nphi)));

		layer.source_up = Eigen::VectorXd::Zero(Ntheta);
		layer.source_down = Eigen::VectorXd::Zero(Ntheta);

		layer.optical_thickness = 1.0E100;

		double s = geometry.WMU_lh.sum();

		// std::cout << "s = " << s << std::endl;

		// #pragma omp parallel for
		for(int e = 0; e < Ntheta; e ++)
		{
			// 上向き：一定輝度 Bsurf*ε/π
			layer.source_up(e) = (1.0 - configuration.surface_albedo) * layer.planck_function;
			// 下向き放射はなし
			layer.source_down(e) = 0.0;

			for(int i = 0; i < Ntheta; i ++)
			{
				for(int p = 0; p < Nphi; p ++)
				{
					layer.reflectance_top[e][i][p] = configuration.surface_albedo / s;
					// std::cout <<  layer.reflectance_top[e][i][p] << std::endl;
					layer.transmittance_top[e][i][p] = 0.0;
					layer.reflectance_bottom[e][i][p] = 0.0;
					layer.transmittance_bottom[e][i][p] = 0.0;
				}
			}
		}
	}

	computeFourierSeriesCoefficients(layer);

	return;
}

inline void RadiativeTransfer::setLayerCondition(AtmosphereModel& atmosphere_model, double wavenumber)
{
	double wavelength = 1.0 / wavenumber;

	auto B_lambda = [=](double lambda, double T) -> double
	{
		double B = 2.0 * SPEED_OF_LIGHT * SPEED_OF_LIGHT * PLANCK_CONSTANT;
		B /= std::pow(lambda, 5);
		B /= (std::exp(PLANCK_CONSTANT *SPEED_OF_LIGHT / (lambda * BOLTZMANN_CONSTANT * T)) - 1.0);
		return B;
	};

	auto B_nu = [=](double nu, double T) -> double
	{
		double B = 2.0 * PLANCK_CONSTANT * SPEED_OF_LIGHT * SPEED_OF_LIGHT * std::pow(nu, 3);
		B /= (std::exp(PLANCK_CONSTANT * SPEED_OF_LIGHT * nu / (BOLTZMANN_CONSTANT * T)) - 1.0);
		return B; // [W·m^-2·sr^-1·(m^-1)^-1]
	};

	if(configuration.surface_type == SurfaceType::NoSurface)
	{
		if(configuration.enable_atmospheric_emission == true)
		{
			atmosphere_model.surface_layer.enable_atmospheric_emission = true;
		}
		else
		{
			atmosphere_model.surface_layer.enable_atmospheric_emission = false;
		}
	}
	else if(configuration.surface_type == SurfaceType::Lambert)
	{
		if(configuration.enable_atmospheric_emission == true)
		{
			atmosphere_model.surface_layer.enable_atmospheric_emission = true;
		}
		else
		{
			atmosphere_model.surface_layer.enable_atmospheric_emission = false;
		}

		atmosphere_model.surface_layer.temperature = configuration.surface_temperature;

		if(configuration.is_wavenumber == true)
		{
			atmosphere_model.surface_layer.planck_function = B_nu(wavenumber, atmosphere_model.surface_layer.temperature);
		}
		else
		{
			atmosphere_model.surface_layer.planck_function = B_lambda(wavelength, atmosphere_model.surface_layer.temperature);
		}
	}
	
	// 高度によらず一定の値のみ計算
	for(int i = 0; i < atmosphere_model.species.size(); i ++)
	{
		if(atmosphere_model.species[i].species_state == SpeciesState::Aerosol)
		{
			if(atmosphere_model.species[i].scatter_type == ScatterType::Mie)
			{
				if(atmosphere_model.species[i].refractive_index_type != RefractiveIndexType::VerticalProfile)
				{
					std::complex<double> refractive_idx;
					std::vector<std::vector<double>> size_dist;
					std::vector<std::vector<double>> pf;
					double ex;

					if(atmosphere_model.species[i].refractive_index_type == RefractiveIndexType::Constant)
					{
						refractive_idx = std::complex<double>(atmosphere_model.species[i].nr, atmosphere_model.species[i].ni);
					}
					else if(atmosphere_model.species[i].refractive_index_type == RefractiveIndexType::External)
					{
						auto refractive_idx_file = importRefractiveIndex(atmosphere_model.species[i].filename_refractive_index);
						
						if(atmosphere_model.species[i].unit_x_input_refractive_index == UnitDim::Length)
						{
							for(int j = 0; j < refractive_idx_file.size(); j ++)
							{
								refractive_idx_file[j][0] *= scaleUnit(atmosphere_model.species[i].unit_input_refractive_index_wavelength, "m");
							}

							if(wavelength <= refractive_idx_file[0][0])
							{
								refractive_idx = std::complex<double>(refractive_idx_file[0][1], refractive_idx_file[0][2]);
							}
							else if(wavelength >= refractive_idx_file[refractive_idx_file.size() - 1][0])
							{
								refractive_idx = std::complex<double>(refractive_idx_file[refractive_idx_file.size() - 1][1], refractive_idx_file[refractive_idx_file.size() - 1][2]);
							}
							else
							{
								for(int j = 0; j < refractive_idx_file.size() - 1; j ++)
								{
									if(refractive_idx_file[j][0] <= wavelength && wavelength < refractive_idx_file[j + 1][0])
									{
										double r = (wavelength - refractive_idx_file[j][0]) / (refractive_idx_file[j + 1][0] - refractive_idx_file[j][0]);
										double real = refractive_idx_file[j][1] + r * (refractive_idx_file[j + 1][1] - refractive_idx_file[j][1]);
										double imag = refractive_idx_file[j][2] + r * (refractive_idx_file[j + 1][2] - refractive_idx_file[j][2]);
										refractive_idx = std::complex<double>(real, imag);
										break;
									}	
								}
							}
						}
						else if(atmosphere_model.species[i].unit_x_input_refractive_index == UnitDim::Wavenumber)
						{
							for(int j = 0; j < refractive_idx_file.size(); j ++)
							{
								refractive_idx_file[j][0] *= scaleUnit(atmosphere_model.species[i].unit_input_refractive_index_wavenumber, "m-1");
							}

							if(wavenumber <= refractive_idx_file[0][0])
							{
								refractive_idx = std::complex<double>(refractive_idx_file[0][1], refractive_idx_file[0][2]);
							}
							else if(wavenumber >= refractive_idx_file[refractive_idx_file.size() - 1][0])
							{
								refractive_idx = std::complex<double>(refractive_idx_file[refractive_idx_file.size() - 1][1], refractive_idx_file[refractive_idx_file.size() - 1][2]);
							}
							else
							{
								for(int j = 0; j < refractive_idx_file.size() - 1; j ++)
								{
									if(refractive_idx_file[j][0] <= wavenumber && wavenumber < refractive_idx_file[j + 1][0])
									{
										double r = (wavenumber - refractive_idx_file[j][0]) / (refractive_idx_file[j + 1][0] - refractive_idx_file[j][0]);
										double real = refractive_idx_file[j][1] + r * (refractive_idx_file[j + 1][1] - refractive_idx_file[j][1]);
										double imag = refractive_idx_file[j][2] + r * (refractive_idx_file[j + 1][2] - refractive_idx_file[j][2]);
										refractive_idx = std::complex<double>(real, imag);
										break;
									}	
								}
							}
						}
						
					}

					if(atmosphere_model.species[i].size_distribution == ParticleSizeDistribution::Delta)
					{
						size_dist = {{atmosphere_model.species[i].size, 1.0}};
						computeMieScattering(configuration.n_scattering_angle, size_dist, 100, wavelength, refractive_idx, atmosphere_model.species[i].scattering_cross_section, atmosphere_model.species[i].absorption_cross_section, ex, pf);
					}
					else if(atmosphere_model.species[i].size_distribution == ParticleSizeDistribution::Gaussian)
					{
						double d_radius = 5.0 * atmosphere_model.species[i].sigma / double((atmosphere_model.species[i].n_radius - 1) / 2);

						for(int nr = 0; nr < atmosphere_model.species[i].n_radius; nr ++)
						{
							double r = atmosphere_model.species[i].r_mean - 5.0 * atmosphere_model.species[i].sigma + double(nr) * d_radius;
							if(r > 0.0)
							{
								double gauss = std::exp(-(r - atmosphere_model.species[i].r_mean) * (r - atmosphere_model.species[i].r_mean) / (2.0 * atmosphere_model.species[i].sigma * atmosphere_model.species[i].sigma));
								std::vector<double> temp = {r, gauss};
								size_dist.push_back(temp);
							}
						}

						computeMieScattering(configuration.n_scattering_angle, size_dist, 100, wavelength, refractive_idx, atmosphere_model.species[i].scattering_cross_section, atmosphere_model.species[i].absorption_cross_section, ex, pf);
					}
					else if(atmosphere_model.species[i].size_distribution == ParticleSizeDistribution::Rectangular)
					{
						double d_radius = atmosphere_model.species[i].width / double(atmosphere_model.species[i].n_radius - 1);
						
						for(int nr = 0; nr < atmosphere_model.species[i].n_radius; nr ++)
						{
							double r = atmosphere_model.species[i].r_mean - 0.5 * atmosphere_model.species[i].width + double(nr) * d_radius;
							if(r > 0.0)
							{
								std::vector<double> temp = {r, 1.0};
								size_dist.push_back(temp);
							}
						}

						computeMieScattering(configuration.n_scattering_angle, size_dist, 100, wavelength, refractive_idx, atmosphere_model.species[i].scattering_cross_section, atmosphere_model.species[i].absorption_cross_section, ex, pf);
					}
					else if(atmosphere_model.species[i].size_distribution == ParticleSizeDistribution::LogNormal)
					{
						computeMieScatteringLogNormal(configuration.n_scattering_angle, atmosphere_model.species[i].n_radius, atmosphere_model.species[i].r_g, atmosphere_model.species[i].sigma_g, wavelength, refractive_idx, atmosphere_model.species[i].scattering_cross_section, atmosphere_model.species[i].absorption_cross_section, ex, pf);
					}
					else if(atmosphere_model.species[i].size_distribution == ParticleSizeDistribution::External)
					{
						size_dist = importSizeDistribution(atmosphere_model.species[i].filename_size_distribution);

						for(int j = 0; j < size_dist.size(); j ++)
						{
							size_dist[j][0] = size_dist[j][0] * scaleUnit(atmosphere_model.species[i].unit_input_radius, "m");
						}
						
						computeMieScattering(configuration.n_scattering_angle, size_dist, 100, wavelength, refractive_idx, atmosphere_model.species[i].scattering_cross_section, atmosphere_model.species[i].absorption_cross_section, ex, pf);
					}

					atmosphere_model.species[i].scattering_phase_function = pf;
					normalizeScatteringPhaseFunction(atmosphere_model.species[i].scattering_phase_function);
				}
			}
			else
			{
				throw std::runtime_error("Currentry only Mie scattering is supported for aerosols.");
			}
		}
		else if(atmosphere_model.species[i].species_state == SpeciesState::Molecule)
		{
			if(atmosphere_model.species[i].species_type == SpeciesType::Absorber || atmosphere_model.species[i].species_type == SpeciesType::Extinction)
			{
				if(atmosphere_model.species[i].absorption_cross_section_type == CrossSectionType::Constant)
				{
					// std::cout << atmosphere_model.species[i].absorption_cross_section << std::endl;
				}
				else if(atmosphere_model.species[i].absorption_cross_section_type == CrossSectionType::External)
				{
					if(atmosphere_model.species[i].unit_x_input_absorption == UnitDim::Length)
					{
						auto spec = importCrossSection(atmosphere_model.species[i].filename_absorption_cross_section);
						for(int j = 0; j < spec.size(); j ++)
						{
							spec[j][0] = spec[j][0] * scaleUnit(atmosphere_model.species[i].unit_input_absorption_wavelength, "m");
							spec[j][1] = spec[j][1] * scaleUnit(atmosphere_model.species[i].unit_input_absorption_cross_section, "m2");

							// std::cout << spec[j][0] << ", " << spec[j][1] << std::endl;
						}
						// cross_section = computeCrossSection(spec, window_function);
						
						if(wavelength <= spec[0][0])
						{
							atmosphere_model.species[i].absorption_cross_section = spec[0][1];
						}
						else if(wavelength >= spec[spec.size() - 1][0])
						{
							atmosphere_model.species[i].absorption_cross_section = spec[spec.size() - 1][1];
						}
						else
						{
							for(int j = 0; j < spec.size() - 1; j ++)
							{
								if(spec[j][0] <= wavelength && wavelength < spec[j + 1][0])
								{
									double r = (wavelength - spec[j][0]) / (spec[j + 1][0] - spec[j][0]);
									atmosphere_model.species[i].absorption_cross_section = spec[j][1] + r * (spec[j + 1][1] - spec[j][1]);
									break;
								}
							}
						}
					}
					else if(atmosphere_model.species[i].unit_x_input_absorption == UnitDim::Wavenumber)
					{
						auto spec = importCrossSection(atmosphere_model.species[i].filename_absorption_cross_section);
						for(int j = 0; j < spec.size(); j ++)
						{
							spec[j][0] = spec[j][0] * scaleUnit(atmosphere_model.species[i].unit_input_absorption_wavenumber, "m-1");
							spec[j][1] = spec[j][1] * scaleUnit(atmosphere_model.species[i].unit_input_absorption_cross_section, "m2");

							// std::cout << spec[j][0] << ", " << spec[j][1] << std::endl;
						}
						// cross_section = computeCrossSection(spec, window_function);
						
						if(wavenumber <= spec[0][0])
						{
							atmosphere_model.species[i].absorption_cross_section = spec[0][1];
						}
						else if(wavenumber >= spec[spec.size() - 1][0])
						{
							atmosphere_model.species[i].absorption_cross_section = spec[spec.size() - 1][1];
						}
						else
						{
							for(int j = 0; j < spec.size() - 1; j ++)
							{
								if(spec[j][0] <= wavenumber && wavenumber < spec[j + 1][0])
								{
									double r = (wavenumber - spec[j][0]) / (spec[j + 1][0] - spec[j][0]);
									atmosphere_model.species[i].absorption_cross_section = spec[j][1] + r * (spec[j + 1][1] - spec[j][1]);
									break;
								}
							}
						}
					}
				}
				else if(atmosphere_model.species[i].absorption_cross_section_type == CrossSectionType::HITRAN)
				{
					;
				}
			}
			
			if(atmosphere_model.species[i].species_type == SpeciesType::Scatterer || atmosphere_model.species[i].species_type == SpeciesType::Extinction)
			{
				if(atmosphere_model.species[i].scattering_cross_section_type == CrossSectionType::Constant)
				{
					;
				}
				else if(atmosphere_model.species[i].scattering_cross_section_type == CrossSectionType::External)
				{
					if(atmosphere_model.species[i].unit_x_input_scattering == UnitDim::Length)
					{
						auto spec = importCrossSection(atmosphere_model.species[i].filename_scattering_cross_section);
						for(int j = 0; j < spec.size(); j ++)
						{
							spec[j][0] = spec[j][0] * scaleUnit(atmosphere_model.species[i].unit_input_scattering_wavelength, "m");
							spec[j][1] = spec[j][1] * scaleUnit(atmosphere_model.species[i].unit_input_scattering_cross_section, "m2");
						}
						
						if(wavelength <= spec[0][0])
						{
							atmosphere_model.species[i].scattering_cross_section = spec[0][1];
						}
						else if(wavelength >= spec[spec.size() - 1][0])
						{
							atmosphere_model.species[i].scattering_cross_section = spec[spec.size() - 1][1];
						}
						else
						{
							for(int j = 0; j < spec.size() - 1; j ++)
							{
								if(spec[j][0] <= wavelength && wavelength < spec[j + 1][0])
								{
									double r = (wavelength - spec[j][0]) / (spec[j + 1][0] - spec[j][0]);
									atmosphere_model.species[i].scattering_cross_section = spec[j][1] + r * (spec[j + 1][1] - spec[j][1]);
									break;
								}
							}
						}
					}
					else if(atmosphere_model.species[i].unit_x_input_scattering == UnitDim::Wavenumber)
					{
						auto spec = importCrossSection(atmosphere_model.species[i].filename_scattering_cross_section);
						for(int j = 0; j < spec.size(); j ++)
						{
							spec[j][0] = spec[j][0] * scaleUnit(atmosphere_model.species[i].unit_input_scattering_wavenumber, "m-1");
							spec[j][1] = spec[j][1] * scaleUnit(atmosphere_model.species[i].unit_input_scattering_cross_section, "m2");

							// std::cout << spec[j][0] << ", " << spec[j][1] << std::endl;
						}
						// cross_section = computeCrossSection(spec, window_function);
						
						if(wavenumber <= spec[0][0])
						{
							atmosphere_model.species[i].scattering_cross_section = spec[0][1];
						}
						else if(wavenumber >= spec[spec.size() - 1][0])
						{
							atmosphere_model.species[i].scattering_cross_section = spec[spec.size() - 1][1];
						}
						else
						{
							for(int j = 0; j < spec.size() - 1; j ++)
							{
								if(spec[j][0] <= wavenumber && wavenumber < spec[j + 1][0])
								{
									double r = (wavenumber - spec[j][0]) / (spec[j + 1][0] - spec[j][0]);
									atmosphere_model.species[i].scattering_cross_section = spec[j][1] + r * (spec[j + 1][1] - spec[j][1]);
									break;
								}
							}
						}
					}
				}
				else if(atmosphere_model.species[i].scattering_cross_section_type == CrossSectionType::HITRAN)
				{
					throw std::runtime_error("Currentry HITRAN module for scattering is not supported.");
				}

				if(atmosphere_model.species[i].scatter_type == ScatterType::Rayleigh)
				{
					auto pf = computeRayleighScatteringFunction(configuration.n_scattering_angle);
					//output_log << atmosphere_model.species[i].name << ", " << pf.size() << std::endl;
					atmosphere_model.species[i].scattering_phase_function = pf;
					normalizeScatteringPhaseFunction(atmosphere_model.species[i].scattering_phase_function);
				}
				else if(atmosphere_model.species[i].scatter_type == ScatterType::Isotropic)
				{
					std::vector<std::vector<double>> pf(configuration.n_scattering_angle);
					double dtheta = PI / double(configuration.n_scattering_angle - 1);

					for(int k = 0; k < configuration.n_scattering_angle; k ++)
					{
						double scattering_angle = dtheta * double(k);
						pf[k].resize(2);
						pf[k][0] = scattering_angle;
						pf[k][1] = 1.0;
					}

					atmosphere_model.species[i].scattering_phase_function = pf;

					// std::cout << "thru" << std::endl;

					normalizeScatteringPhaseFunction(atmosphere_model.species[i].scattering_phase_function);
				}
				else if(atmosphere_model.species[i].scatter_type == ScatterType::HenyeyGreenstein)
				{
					double g = atmosphere_model.species[i].g_factor;

					std::vector<std::vector<double>> pf(configuration.n_scattering_angle);
					double dtheta = PI / double(configuration.n_scattering_angle - 1);

					for(int k = 0; k < configuration.n_scattering_angle; k ++)
					{
						double hg = (1.0 - g * g) / std::pow(1 + g * g - 2.0 * g * std::cos(dtheta * double(k)), 1.5);
						pf[k].resize(2);
						pf[k][0] = dtheta * double(k);
						pf[k][1] = hg;
					}

					atmosphere_model.species[i].scattering_phase_function = pf;

					normalizeScatteringPhaseFunction(atmosphere_model.species[i].scattering_phase_function);
				}
				else if(atmosphere_model.species[i].scatter_type == ScatterType::Mie)
				{
					throw std::runtime_error("Currentry Mie scattering is not supported for molecules.");
				}
			}
		}
	}
	
	for(int i = 0; i < atmosphere_model.layers.size(); i ++)
	{
		if(configuration.is_wavenumber == true)
		{
			atmosphere_model.layers[i].planck_function = B_nu(wavenumber, atmosphere_model.layers[i].temperature);
		}
		else
		{
			atmosphere_model.layers[i].planck_function = B_lambda(wavelength, atmosphere_model.layers[i].temperature);
		}

		for(int j = 0; j < atmosphere_model.species.size(); j ++)
		{
			if(atmosphere_model.species[j].species_state == SpeciesState::Aerosol)
			{
				if(atmosphere_model.species[j].scatter_type == ScatterType::Mie)
				{
					if(atmosphere_model.species[j].refractive_index_type == RefractiveIndexType::VerticalProfile)
					{
						std::complex<double> refractive_idx = atmosphere_model.species[j].computeRefractiveIndex(atmosphere_model.layers[i].altitude);
						std::vector<std::vector<double>> size_dist;
						std::vector<std::vector<double>> pf;
						double ex;

						atmosphere_model.species[j].scattering_cross_section = 0.0;
						atmosphere_model.species[j].absorption_cross_section = 0.0;

						if(atmosphere_model.species[j].size_distribution == ParticleSizeDistribution::Delta)
						{
							size_dist = {{atmosphere_model.species[j].size, 1.0}};
							computeMieScattering(configuration.n_scattering_angle, size_dist, 100, wavelength, refractive_idx, atmosphere_model.species[j].scattering_cross_section, atmosphere_model.species[j].absorption_cross_section, ex, pf);
						}
						else if(atmosphere_model.species[j].size_distribution == ParticleSizeDistribution::Gaussian)
						{
							double d_radius = 5.0 * atmosphere_model.species[j].sigma / double((atmosphere_model.species[j].n_radius - 1) / 2);

							for(int nr = 0; nr < atmosphere_model.species[j].n_radius; nr ++)
							{
								double r = atmosphere_model.species[j].r_mean - 5.0 * atmosphere_model.species[j].sigma + double(nr) * d_radius;
								if(r > 0.0)
								{
									double gauss = std::exp(-(r - atmosphere_model.species[j].r_mean) * (r - atmosphere_model.species[j].r_mean) / (2.0 * atmosphere_model.species[j].sigma * atmosphere_model.species[j].sigma));
									std::vector<double> temp = {r, gauss};
									size_dist.push_back(temp);
								}
							}

							computeMieScattering(configuration.n_scattering_angle, size_dist, 100, wavelength, refractive_idx, atmosphere_model.species[j].scattering_cross_section, atmosphere_model.species[j].absorption_cross_section, ex, pf);
						}
						else if(atmosphere_model.species[j].size_distribution == ParticleSizeDistribution::Rectangular)
						{
							double d_radius = atmosphere_model.species[j].width / double(atmosphere_model.species[j].n_radius - 1);
							
							for(int nr = 0; nr < atmosphere_model.species[j].n_radius; nr ++)
							{
								double r = atmosphere_model.species[j].r_mean - 0.5 * atmosphere_model.species[j].width + double(nr) * d_radius;
								if(r > 0.0)
								{
									std::vector<double> temp = {r, 1.0};
									size_dist.push_back(temp);
								}
							}

							computeMieScattering(configuration.n_scattering_angle, size_dist, 100, wavelength, refractive_idx, atmosphere_model.species[j].scattering_cross_section, atmosphere_model.species[j].absorption_cross_section, ex, pf);
						}
						else if(atmosphere_model.species[j].size_distribution == ParticleSizeDistribution::LogNormal)
						{
							computeMieScatteringLogNormal(configuration.n_scattering_angle, atmosphere_model.species[j].n_radius, atmosphere_model.species[j].r_g, atmosphere_model.species[j].sigma_g, wavelength, refractive_idx, atmosphere_model.species[j].scattering_cross_section, atmosphere_model.species[j].absorption_cross_section, ex, pf);
						}
						else if(atmosphere_model.species[j].size_distribution == ParticleSizeDistribution::External)
						{
							size_dist = importSizeDistribution(atmosphere_model.species[j].filename_size_distribution);

							for(int k = 0; k < size_dist.size(); k ++)
							{
								size_dist[k][0] = size_dist[k][0] * scaleUnit(atmosphere_model.species[j].unit_input_radius, "m");
							}
							
							computeMieScattering(configuration.n_scattering_angle, size_dist, 100, wavelength, refractive_idx, atmosphere_model.species[j].scattering_cross_section, atmosphere_model.species[j].absorption_cross_section, ex, pf);
						}

						atmosphere_model.species[j].scattering_phase_function = pf;
						normalizeScatteringPhaseFunction(atmosphere_model.species[j].scattering_phase_function); 

						atmosphere_model.layers[i].absorption_coefficient += atmosphere_model.layers[i].number_density_species[j] * atmosphere_model.species[j].absorption_cross_section;	// 1/m
						atmosphere_model.layers[i].scattering_coefficient += atmosphere_model.layers[i].number_density_species[j] * atmosphere_model.species[j].scattering_cross_section;	// 1/m

						for(int k = 0; k < atmosphere_model.layers[i].scattering_phase_function.size(); k ++)
						{
							atmosphere_model.layers[i].scattering_phase_function[k][1] += atmosphere_model.layers[i].number_density_species[j] * atmosphere_model.species[j].scattering_cross_section * atmosphere_model.species[j].scattering_phase_function[k][1];
						}
					}
					else
					{
						atmosphere_model.layers[i].absorption_coefficient += atmosphere_model.layers[i].number_density_species[j] * atmosphere_model.species[j].absorption_cross_section;	// 1/m
						atmosphere_model.layers[i].scattering_coefficient += atmosphere_model.layers[i].number_density_species[j] * atmosphere_model.species[j].scattering_cross_section;	// 1/m

						for(int k = 0; k < atmosphere_model.layers[i].scattering_phase_function.size(); k ++)
						{
							atmosphere_model.layers[i].scattering_phase_function[k][1] += atmosphere_model.layers[i].number_density_species[j] * atmosphere_model.species[j].scattering_cross_section * atmosphere_model.species[j].scattering_phase_function[k][1];
						}
					}
				}
				else
				{
					// configuration.output_log << "WARNING: CURRENTRY ONLY MIE SCATTERING IS SUPPORTED FOR AEROSOLS" << std::endl;
				}
			}
			else if(atmosphere_model.species[j].species_state == SpeciesState::Molecule)
			{
				if(atmosphere_model.species[j].species_type == SpeciesType::Scatterer || atmosphere_model.species[j].species_type == SpeciesType::Extinction)
				{
					atmosphere_model.layers[i].scattering_coefficient += atmosphere_model.layers[i].number_density_species[j] * atmosphere_model.species[j].scattering_cross_section;	// 1/m

					for(int k = 0; k < atmosphere_model.layers[i].scattering_phase_function.size(); k ++)
					{
						atmosphere_model.layers[i].scattering_phase_function[k][1] += atmosphere_model.layers[i].number_density_species[j] * atmosphere_model.species[j].scattering_cross_section * atmosphere_model.species[j].scattering_phase_function[k][1];
					}
				}
				if(atmosphere_model.species[j].species_type == SpeciesType::Absorber || atmosphere_model.species[j].species_type == SpeciesType::Extinction)
				{
					if(atmosphere_model.species[j].absorption_cross_section_type == CrossSectionType::HITRAN)
					{
						atmosphere_model.species[j].absorption_cross_section = 0.0;

						for(int nlines = 0; nlines < atmosphere_model.species[j].lines.size(); nlines ++)
						{
							double q_self = atmosphere_model.layers[i].number_density_species[j] / atmosphere_model.layers[i].number_density;
							atmosphere_model.species[j].absorption_cross_section += atmosphere_model.species[j].lines[nlines].computeCrossSection(1.0 / wavelength, atmosphere_model.layers[i].temperature, atmosphere_model.layers[i].pressure * q_self, atmosphere_model.layers[i].pressure, atmosphere_model.species[j].isotopologue, atmosphere_model.diluent);
						}
					}

					atmosphere_model.layers[i].absorption_coefficient += atmosphere_model.layers[i].number_density_species[j] * atmosphere_model.species[j].absorption_cross_section;	// 1/m
				}
			}
		}

		atmosphere_model.layers[i].normalizeScatteringPhaseFunction();
		atmosphere_model.layers[i].single_scattering_albedo = atmosphere_model.layers[i].scattering_coefficient / (atmosphere_model.layers[i].absorption_coefficient + atmosphere_model.layers[i].scattering_coefficient);
		atmosphere_model.layers[i].optical_thickness = atmosphere_model.layers[i].physical_thickness * (atmosphere_model.layers[i].absorption_coefficient + atmosphere_model.layers[i].scattering_coefficient);
	}

	return;
}

inline void RadiativeTransfer::computeAtmosphericProperties(AtmosphereModel& atmosphere_model)
{
	atmosphere_model.diluent = configuration.diluent;

	if(configuration.z_edge.size() > 0)
	{
		atmosphere_model.layers.resize(configuration.z_edge.size() - 1);
	}
	else if(configuration.z_center.size() > 0)
	{
		atmosphere_model.layers.resize(configuration.z_center.size());
	}
	else
	{
		throw std::runtime_error("Altitude coordinate not specified.");
	}

	for(int i = 0; i < atmosphere_model.layers.size(); i ++)
	{
		Layer layer;

		if(configuration.enable_atmospheric_emission == true)
		{
			layer.enable_atmospheric_emission = true;
		}
		else
		{
			layer.enable_atmospheric_emission = false;
		}

		if(configuration.z_edge.size() > 0)
		{
			layer.altitude_bottom = configuration.z_edge[i];
			layer.altitude_top = configuration.z_edge[i + 1];
			layer.altitude = 0.5 * (layer.altitude_bottom + layer.altitude_top);
		}
		else if(configuration.z_center.size() > 0)
		{
			layer.altitude = configuration.z_center[i];

			if(i == 0)
			{
				layer.altitude_bottom = configuration.z_center[0];
				layer.altitude_top = 0.5 * (configuration.z_center[0] + configuration.z_center[1]);
			}
			else if(i == configuration.z_center.size() - 1)
			{
				layer.altitude_bottom = 0.5 * (configuration.z_center[configuration.z_center.size() - 2] + configuration.z_center[configuration.z_center.size() - 1]);
				layer.altitude_top = configuration.z_center[configuration.z_center.size() - 1];
			}
			else
			{
				layer.altitude_bottom = 0.5 * (configuration.z_center[i - 1] + configuration.z_center[i]);
				layer.altitude_top = 0.5 * (configuration.z_center[i] + configuration.z_center[i + 1]);
			}
		}

		layer.absorption_coefficient = 0.0;
		layer.scattering_coefficient = 0.0;

		layer.physical_thickness = layer.altitude_top - layer.altitude_bottom;
		
		if(configuration.is_same_temperature_layering_atmosphere == false)
		{
			if(configuration.vertical_temperature_profile == VerticalTemperatureProfile::VIRA_EQUATOR)
			{
				if(configuration.vertical_temperature_interpolation == VerticalProfileInterpolation::Exponential)
				{
					for(int j = 0; j < vira_equator.size() - 1; j ++)
					{
						if(vira_equator[j][0] * scaleUnit("km", "m") <= layer.altitude && layer.altitude <= vira_equator[j + 1][0] * scaleUnit("km", "m"))
						{
							double logp0 = std::log(vira_equator[j][1] * scaleUnit("K", "K"));
							double logp1 = std::log(vira_equator[j + 1][1] * scaleUnit("K", "K"));
							double r = (layer.altitude - vira_equator[j][0] * scaleUnit("km", "m")) / (vira_equator[j + 1][0] * scaleUnit("km", "m") - vira_equator[j][0] * scaleUnit("km", "m"));
							layer.temperature = std::exp((1.0 - r) * logp0 + r * logp1);
							break;
						}
					}
				}
				else
				{
					for(int j = 0; j < vira_equator.size() - 1; j ++)
					{
						if(vira_equator[j][0] * scaleUnit("km", "m") <= layer.altitude && layer.altitude <= vira_equator[j + 1][0] * scaleUnit("km", "m"))
						{
							double r = (layer.altitude - vira_equator[j][0] * scaleUnit("km", "m")) / (vira_equator[j + 1][0] * scaleUnit("km", "m") - vira_equator[j][0] * scaleUnit("km", "m"));
							layer.temperature = (1.0 - r) * vira_equator[j][1] * scaleUnit("K", "K") + r * vira_equator[j + 1][1] * scaleUnit("K", "K");
							break;
						}
					}
				}
			}
			else if(configuration.vertical_temperature_profile == VerticalTemperatureProfile::VIRA_45)
			{
				if(configuration.vertical_temperature_interpolation == VerticalProfileInterpolation::Exponential)
				{
					for(int j = 0; j < vira_45.size() - 1; j ++)
					{
						if(vira_45[j][0] * scaleUnit("km", "m") <= layer.altitude && layer.altitude <= vira_45[j + 1][0] * scaleUnit("km", "m"))
						{
							double logp0 = std::log(vira_45[j][1] * scaleUnit("K", "K"));
							double logp1 = std::log(vira_45[j + 1][1] * scaleUnit("K", "K"));
							double r = (layer.altitude - vira_45[j][0] * scaleUnit("km", "m")) / (vira_45[j + 1][0] * scaleUnit("km", "m") - vira_45[j][0] * scaleUnit("km", "m"));
							layer.temperature = std::exp((1.0 - r) * logp0 + r * logp1);
							break;
						}
					}
				}
				else
				{
					for(int j = 0; j < vira_45.size() - 1; j ++)
					{
						if(vira_45[j][0] * scaleUnit("km", "m") <= layer.altitude && layer.altitude <= vira_45[j + 1][0] * scaleUnit("km", "m"))
						{
							double r = (layer.altitude - vira_45[j][0] * scaleUnit("km", "m")) / (vira_45[j + 1][0] * scaleUnit("km", "m") - vira_45[j][0] * scaleUnit("km", "m"));
							layer.temperature = (1.0 - r) * vira_45[j][1] * scaleUnit("K", "K") + r * vira_45[j + 1][1] * scaleUnit("K", "K");
							break;
						}
					}
				}
			}
			else if(configuration.vertical_temperature_profile == VerticalTemperatureProfile::VIRA_60)
			{
				if(configuration.vertical_temperature_interpolation == VerticalProfileInterpolation::Exponential)
				{
					for(int j = 0; j < vira_60.size() - 1; j ++)
					{
						if(vira_60[j][0] * scaleUnit("km", "m") <= layer.altitude && layer.altitude <= vira_60[j + 1][0] * scaleUnit("km", "m"))
						{
							double logp0 = std::log(vira_60[j][1] * scaleUnit("K", "K"));
							double logp1 = std::log(vira_60[j + 1][1] * scaleUnit("K", "K"));
							double r = (layer.altitude - vira_60[j][0] * scaleUnit("km", "m")) / (vira_60[j + 1][0] * scaleUnit("km", "m") - vira_60[j][0] * scaleUnit("km", "m"));
							layer.temperature = std::exp((1.0 - r) * logp0 + r * logp1);
							break;
						}
					}
				}
				else
				{
					for(int j = 0; j < vira_60.size() - 1; j ++)
					{
						if(vira_60[j][0] * scaleUnit("km", "m") <= layer.altitude && layer.altitude <= vira_60[j + 1][0] * scaleUnit("km", "m"))
						{
							double r = (layer.altitude - vira_60[j][0] * scaleUnit("km", "m")) / (vira_60[j + 1][0] * scaleUnit("km", "m") - vira_60[j][0] * scaleUnit("km", "m"));
							layer.temperature = (1.0 - r) * vira_60[j][1] * scaleUnit("K", "K") + r * vira_60[j + 1][1] * scaleUnit("K", "K");
							break;
						}
					}
				}
			}
			else if(configuration.vertical_temperature_profile == VerticalTemperatureProfile::Table)
			{
				if(configuration.vertical_temperature_interpolation == VerticalProfileInterpolation::Linear)
				{
					for(int j = 0; j < configuration.temperature_profile.size() - 1; j ++)
					{
						if(configuration.temperature_profile[j][0] <= layer.altitude && layer.altitude <= configuration.temperature_profile[j + 1][0])
						{
							double r = (layer.altitude - configuration.temperature_profile[j][0]) / (configuration.temperature_profile[j + 1][0] - configuration.temperature_profile[j][0]);
							layer.temperature = (1.0 - r) * configuration.temperature_profile[j][1] + r * configuration.temperature_profile[j + 1][1];
							break;
						}
					}
				}
				else if(configuration.vertical_temperature_interpolation == VerticalProfileInterpolation::Exponential)
				{
					for(int j = 0; j < configuration.temperature_profile.size() - 1; j ++)
					{
						if(configuration.temperature_profile[j][0] <= layer.altitude && layer.altitude <= configuration.temperature_profile[j + 1][0])
						{
							double logp0 = std::log(configuration.temperature_profile[j][1]);
							double logp1 = std::log(configuration.temperature_profile[j + 1][1]);
							double r = (layer.altitude - configuration.temperature_profile[j][0]) / (configuration.temperature_profile[j + 1][0] - configuration.temperature_profile[j][0]);
							layer.temperature = std::exp((1.0 - r) * logp0 + r * logp1);
							break;
						}
					}
				}
			}
			else if(configuration.vertical_temperature_profile == VerticalTemperatureProfile::External)
			{
				// configuration.output_log << "CURRENTRY EXTERNAL INPUT IS NOT SUPPORTED" << std::endl;
			}
		}
		else
		{
			layer.temperature = configuration.temperature_profile[i][1];
		}

		if(configuration.is_same_pressure_layering_atmosphere == false)
		{
			if(configuration.vertical_pressure_profile == VerticalPressureProfile::VIRA_EQUATOR)
			{
				if(configuration.vertical_pressure_interpolation == VerticalProfileInterpolation::Exponential)
				{
					for(int j = 0; j < vira_equator.size() - 1; j ++)
					{
						if(vira_equator[j][0] * scaleUnit("km", "m") <= layer.altitude && layer.altitude <= vira_equator[j + 1][0] * scaleUnit("km", "m"))
						{
							double logp0 = std::log(vira_equator[j][2] * scaleUnit("bar", "Pa"));
							double logp1 = std::log(vira_equator[j + 1][2] * scaleUnit("bar", "Pa"));
							double r = (layer.altitude - vira_equator[j][0] * scaleUnit("km", "m")) / (vira_equator[j + 1][0] * scaleUnit("km", "m") - vira_equator[j][0] * scaleUnit("km", "m"));
							layer.pressure = std::exp((1.0 - r) * logp0 + r * logp1);
							break;
						}
					}
				}
				else
				{
					for(int j = 0; j < vira_equator.size() - 1; j ++)
					{
						if(vira_equator[j][0] * scaleUnit("km", "m") <= layer.altitude && layer.altitude <= vira_equator[j + 1][0] * scaleUnit("km", "m"))
						{
							double r = (layer.altitude - vira_equator[j][0] * scaleUnit("km", "m")) / (vira_equator[j + 1][0] * scaleUnit("km", "m") - vira_equator[j][0] * scaleUnit("km", "m"));
							layer.pressure = (1.0 - r) * vira_equator[j][2] * scaleUnit("bar", "Pa") + r * vira_equator[j + 1][2] * scaleUnit("bar", "Pa");
							break;
						}
					}
				}
			}
			else if(configuration.vertical_pressure_profile == VerticalPressureProfile::VIRA_45)
			{
				if(configuration.vertical_pressure_interpolation == VerticalProfileInterpolation::Exponential)
				{
					for(int j = 0; j < vira_45.size() - 1; j ++)
					{
						if(vira_45[j][0] * scaleUnit("km", "m") <= layer.altitude && layer.altitude <= vira_45[j + 1][0] * scaleUnit("km", "m"))
						{
							double logp0 = std::log(vira_45[j][2] * scaleUnit("bar", "Pa"));
							double logp1 = std::log(vira_45[j + 1][2] * scaleUnit("bar", "Pa"));
							double r = (layer.altitude - vira_45[j][0] * scaleUnit("km", "m")) / (vira_45[j + 1][0] * scaleUnit("km", "m") - vira_45[j][0] * scaleUnit("km", "m"));
							layer.pressure = std::exp((1.0 - r) * logp0 + r * logp1);
							break;
						}
					}
				}
				else
				{
					for(int j = 0; j < vira_45.size() - 1; j ++)
					{
						if(vira_45[j][0] * scaleUnit("km", "m") <= layer.altitude && layer.altitude <= vira_45[j + 1][0] * scaleUnit("km", "m"))
						{
							double r = (layer.altitude - vira_45[j][0] * scaleUnit("km", "m")) / (vira_45[j + 1][0] * scaleUnit("km", "m") - vira_45[j][0] * scaleUnit("km", "m"));
							layer.pressure = (1.0 - r) * vira_45[j][2] * scaleUnit("bar", "Pa") + r * vira_45[j + 1][2] * scaleUnit("bar", "Pa");
							break;
						}
					}
				}
			}
			else if(configuration.vertical_pressure_profile == VerticalPressureProfile::VIRA_60)
			{
				if(configuration.vertical_pressure_interpolation == VerticalProfileInterpolation::Exponential)
				{
					for(int j = 0; j < vira_60.size() - 1; j ++)
					{
						if(vira_60[j][0] * scaleUnit("km", "m") <= layer.altitude && layer.altitude <= vira_60[j + 1][0] * scaleUnit("km", "m"))
						{
							double logp0 = std::log(vira_60[j][2] * scaleUnit("bar", "Pa"));
							double logp1 = std::log(vira_60[j + 1][2] * scaleUnit("bar", "Pa"));
							double r = (layer.altitude - vira_60[j][0] * scaleUnit("km", "m")) / (vira_60[j + 1][0] * scaleUnit("km", "m") - vira_60[j][0] * scaleUnit("km", "m"));
							layer.pressure = std::exp((1.0 - r) * logp0 + r * logp1);
							break;
						}
					}
				}
				else
				{
					for(int j = 0; j < vira_60.size() - 1; j ++)
					{
						if(vira_60[j][0] * scaleUnit("km", "m") <= layer.altitude && layer.altitude <= vira_60[j + 1][0] * scaleUnit("km", "m"))
						{
							double r = (layer.altitude - vira_60[j][0] * scaleUnit("km", "m")) / (vira_60[j + 1][0] * scaleUnit("km", "m") - vira_60[j][0] * scaleUnit("km", "m"));
							layer.pressure = (1.0 - r) * vira_60[j][2] * scaleUnit("bar", "Pa") + r * vira_60[j + 1][2] * scaleUnit("bar", "Pa");
							break;
						}
					}
				}
			}
			else if(configuration.vertical_pressure_profile == VerticalPressureProfile::Table)
			{
				if(configuration.vertical_pressure_interpolation == VerticalProfileInterpolation::Linear)
				{
					for(int j = 0; j < configuration.pressure_profile.size() - 1; j ++)
					{
						if(configuration.pressure_profile[j][0] <= layer.altitude && layer.altitude <= configuration.pressure_profile[j + 1][0])
						{
							double r = (layer.altitude - configuration.pressure_profile[j][0]) / (configuration.pressure_profile[j + 1][0] - configuration.pressure_profile[j][0]);
							layer.pressure = (1.0 - r) * configuration.pressure_profile[j][1] + r * configuration.pressure_profile[j + 1][1];
							break;
						}
					}
				}
				else if(configuration.vertical_pressure_interpolation == VerticalProfileInterpolation::Exponential)
				{
					for(int j = 0; j < configuration.pressure_profile.size() - 1; j ++)
					{
						if(configuration.pressure_profile[j][0] <= layer.altitude && layer.altitude <= configuration.pressure_profile[j + 1][0])
						{
							double logp0 = std::log(configuration.pressure_profile[j][1]);
							double logp1 = std::log(configuration.pressure_profile[j + 1][1]);
							double r = (layer.altitude - configuration.pressure_profile[j][0]) / (configuration.pressure_profile[j + 1][0] - configuration.pressure_profile[j][0]);
							layer.pressure = std::exp((1.0 - r) * logp0 + r * logp1);
							break;
						}
					}
				}
			}
			else if(configuration.vertical_pressure_profile == VerticalPressureProfile::External)
			{
				// configuration.output_log << "CURRENTRY EXTERNAL INPUT IS NOT SUPPORTED" << std::endl;
			}
			else if(configuration.vertical_pressure_profile == VerticalPressureProfile::Hydrostatic)
			{
				// configuration.output_log << "CURRENTRY HYDROSTATIC IS NOT SUPPORTED" << std::endl;
			}
		}
		else
		{
			layer.pressure = configuration.pressure_profile[i][1];
		}

		//Ideal Gas Law PV=nRT n(mol)/V(m^3) = P(N/m^2)/(R(N.m/K/mol)*T(K)) n(molecules/m^3)=NA*P*/(R*T)
		if(configuration.vertical_number_density_profile == VerticalNumberDensityProfile::IdealGas)
		{
			layer.number_density = layer.pressure * AVOGADRO_CONSTANT / (MOLAR_GAS_CONSTANT * layer.temperature);
		}
		else
		{
			if(configuration.is_same_number_density_layering_atmosphere == false)
			{
				if(configuration.vertical_number_density_profile == VerticalNumberDensityProfile::VIRA_EQUATOR)
				{
					if(configuration.vertical_number_density_interpolation == VerticalProfileInterpolation::Exponential)
					{
						for(int j = 0; j < vira_equator.size() - 1; j ++)
						{
							if(vira_equator[j][0] * scaleUnit("km", "m") <= layer.altitude && layer.altitude <= vira_equator[j + 1][0] * scaleUnit("km", "m"))
							{
								double logp0 = std::log(vira_equator[j][3] * scaleUnit("m-3", "m-3"));
								double logp1 = std::log(vira_equator[j + 1][3] * scaleUnit("m-3", "m-3"));
								double r = (layer.altitude - vira_equator[j][0] * scaleUnit("km", "m")) / (vira_equator[j + 1][0] * scaleUnit("km", "m") - vira_equator[j][0] * scaleUnit("km", "m"));
								layer.number_density = std::exp((1.0 - r) * logp0 + r * logp1);
								break;
							}
						}
					}
					else
					{
						for(int j = 0; j < vira_equator.size() - 1; j ++)
						{
							if(vira_equator[j][0] * scaleUnit("km", "m") <= layer.altitude && layer.altitude <= vira_equator[j + 1][0] * scaleUnit("km", "m"))
							{
								double r = (layer.altitude - vira_equator[j][0] * scaleUnit("km", "m")) / (vira_equator[j + 1][0] * scaleUnit("km", "m") - vira_equator[j][0] * scaleUnit("km", "m"));
								layer.number_density = (1.0 - r) * vira_equator[j][3] * scaleUnit("m-3", "m-3") + r * vira_equator[j + 1][3] * scaleUnit("m-3", "m-3");
								break;
							}
						}
					}
				}
				else if(configuration.vertical_number_density_profile == VerticalNumberDensityProfile::VIRA_45)
				{
					if(configuration.vertical_number_density_interpolation == VerticalProfileInterpolation::Exponential)
					{
						for(int j = 0; j < vira_45.size() - 1; j ++)
						{
							if(vira_45[j][0] * scaleUnit("km", "m") <= layer.altitude && layer.altitude <= vira_45[j + 1][0] * scaleUnit("km", "m"))
							{
								double logp0 = std::log(vira_45[j][3] * scaleUnit("m-3", "m-3"));
								double logp1 = std::log(vira_45[j + 1][3] * scaleUnit("m-3", "m-3"));
								double r = (layer.altitude - vira_45[j][0] * scaleUnit("km", "m")) / (vira_45[j + 1][0] * scaleUnit("km", "m") - vira_45[j][0] * scaleUnit("km", "m"));
								layer.number_density = std::exp((1.0 - r) * logp0 + r * logp1);
								break;
							}
						}
					}
					else
					{
						for(int j = 0; j < vira_45.size() - 1; j ++)
						{
							if(vira_45[j][0] * scaleUnit("km", "m") <= layer.altitude && layer.altitude <= vira_45[j + 1][0] * scaleUnit("km", "m"))
							{
								double r = (layer.altitude - vira_45[j][0] * scaleUnit("km", "m")) / (vira_45[j + 1][0] * scaleUnit("km", "m") - vira_45[j][0] * scaleUnit("km", "m"));
								layer.number_density = (1.0 - r) * vira_45[j][3] * scaleUnit("m-3", "m-3") + r * vira_45[j + 1][3] * scaleUnit("m-3", "m-3");
								break;
							}
						}
					}
				}
				else if(configuration.vertical_number_density_profile == VerticalNumberDensityProfile::VIRA_60)
				{
					if(configuration.vertical_number_density_interpolation == VerticalProfileInterpolation::Exponential)
					{
						for(int j = 0; j < vira_60.size() - 1; j ++)
						{
							if(vira_60[j][0] * scaleUnit("km", "m") <= layer.altitude && layer.altitude <= vira_60[j + 1][0] * scaleUnit("km", "m"))
							{
								double logp0 = std::log(vira_60[j][3] * scaleUnit("m-3", "m-3"));
								double logp1 = std::log(vira_60[j + 1][3] * scaleUnit("m-3", "m-3"));
								double r = (layer.altitude - vira_60[j][0] * scaleUnit("km", "m")) / (vira_60[j + 1][0] * scaleUnit("km", "m") - vira_60[j][0] * scaleUnit("km", "m"));
								layer.number_density = std::exp((1.0 - r) * logp0 + r * logp1);
								break;
							}
						}
					}
					else
					{
						for(int j = 0; j < vira_60.size() - 1; j ++)
						{
							if(vira_60[j][0] * scaleUnit("km", "m") <= layer.altitude && layer.altitude <= vira_60[j + 1][0] * scaleUnit("km", "m"))
							{
								double r = (layer.altitude - vira_60[j][0] * scaleUnit("km", "m")) / (vira_60[j + 1][0] * scaleUnit("km", "m") - vira_60[j][0] * scaleUnit("km", "m"));
								layer.number_density = (1.0 - r) * vira_60[j][3] * scaleUnit("m-3", "m-3") + r * vira_60[j + 1][3] * scaleUnit("m-3", "m-3");
								break;
							}
						}
					}
				}
				else if(configuration.vertical_number_density_profile == VerticalNumberDensityProfile::Table)
				{
					if(configuration.vertical_number_density_interpolation == VerticalProfileInterpolation::Linear)
					{
						for(int j = 0; j < configuration.number_density_profile.size() - 1; j ++)
						{
							if(configuration.number_density_profile[j][0] <= layer.altitude && layer.altitude <= configuration.number_density_profile[j + 1][0])
							{
								double r = (layer.altitude - configuration.number_density_profile[j][0]) / (configuration.number_density_profile[j + 1][0] - configuration.number_density_profile[j][0]);
								layer.number_density = (1.0 - r) * configuration.number_density_profile[j][1] + r * configuration.number_density_profile[j + 1][1];
								break;
							}
						}
					}
					else if(configuration.vertical_number_density_interpolation == VerticalProfileInterpolation::Exponential)
					{
						for(int j = 0; j < configuration.number_density_profile.size() - 1; j ++)
						{
							if(configuration.number_density_profile[j][0] <= layer.altitude && layer.altitude <= configuration.number_density_profile[j + 1][0])
							{
								double logp0 = std::log(configuration.number_density_profile[j][1]);
								double logp1 = std::log(configuration.number_density_profile[j + 1][1]);
								double r = (layer.altitude - configuration.number_density_profile[j][0]) / (configuration.number_density_profile[j + 1][0] - configuration.number_density_profile[j][0]);
								layer.number_density = std::exp((1.0 - r) * logp0 + r * logp1);
								break;
							}
						}
					}
				}
				else if(configuration.vertical_number_density_profile == VerticalNumberDensityProfile::External)
				{
					// configuration.output_log << "CURRENTRY EXTERNAL INPUT IS NOT SUPPORTED" << std::endl;
				}
			}
			else
			{
				if(configuration.unit_dim_number_density == UnitDim::NumberDensity)
				{
					layer.number_density = configuration.number_density_profile[i][1];
				}
				else if(configuration.unit_dim_number_density == UnitDim::ColumnNumberDensity)
				{
					layer.number_density = configuration.number_density_profile[i][1] / layer.physical_thickness;
				}
			}
		}
		// std::cout << layer.number_density << std::endl;

		//optical profiles
		layer.scattering_phase_function.resize(configuration.n_scattering_angle);
		double dtheta = PI / double(configuration.n_scattering_angle - 1);

		//output_log << layer.physical_thickness << std::endl;

		for(int j = 0; j < configuration.n_scattering_angle; j ++)
		{
			layer.scattering_phase_function[j].resize(2);
			layer.scattering_phase_function[j][0] = dtheta * double(j);
			layer.scattering_phase_function[j][1] = 0.0;
			//output_log << layer.scattering_phase_function[j][0] << ", " << layer.scattering_phase_function[j][1] << std::endl;
		}

		atmosphere_model.layers[i] = layer;
	}

	return;
}

inline void RadiativeTransfer::computeSpeciesProperties(AtmosphereModel& atmosphere_model)
{
	atmosphere_model.species = configuration.species;

	for(int i = 0; i < atmosphere_model.layers.size(); i ++)
	{
		for(int j = 0; j < atmosphere_model.species.size(); j ++)
		{
			double nd_sp;	//molecule/m^3
			double q;
			if(atmosphere_model.species[j].is_same_layering_atmosphere == true)
			{
				if(atmosphere_model.species[j].vertical_profile_type == VerticalProfileType::MixingRatio)
				{
					q = atmosphere_model.species[j].vertical_profile[i][1];
					nd_sp = atmosphere_model.layers[i].number_density * q;
				}
				else if(atmosphere_model.species[j].vertical_profile_type == VerticalProfileType::NumberDensity)
				{
					nd_sp = atmosphere_model.species[j].vertical_profile[i][1];
					q = nd_sp / atmosphere_model.layers[i].number_density;
				}
				else if(atmosphere_model.species[j].vertical_profile_type == VerticalProfileType::ColumnNumberDensity)
				{
					nd_sp = atmosphere_model.species[j].vertical_profile[i][1] / atmosphere_model.layers[i].physical_thickness;
					q = nd_sp / atmosphere_model.layers[i].number_density;
				}
			}
			else
			{
				if(atmosphere_model.species[j].vertical_profile_type == VerticalProfileType::MixingRatio)
				{
					q = atmosphere_model.species[j].computeMixingRatio(atmosphere_model.layers[i].altitude);
					nd_sp = q * atmosphere_model.layers[i].number_density;
				}
				else if(atmosphere_model.species[j].vertical_profile_type == VerticalProfileType::NumberDensity)
				{
					nd_sp = atmosphere_model.species[j].computeNumberDensity(atmosphere_model.layers[i].altitude);
					q = nd_sp / atmosphere_model.layers[i].number_density;
				}
			}

			atmosphere_model.layers[i].mixing_ratio_species.push_back(q);
			atmosphere_model.layers[i].number_density_species.push_back(nd_sp);
		}
	}

	return;
}

inline void RadiativeTransfer::validateAtmosphererModel(const AtmosphereModel& atmosphere_model)
{
	if(!atmosphere_model.Ntheta.has_value())
	{
		throw std::runtime_error("[FATAL] Grid of zenith angle is not set.");
	}

	if(!atmosphere_model.M.has_value())
	{
		throw std::runtime_error("[FATAL] Number of Fourier expansion is not set.");
	}

	if(!atmosphere_model.Nphi.has_value())
	{
		throw std::runtime_error("[FATAL] Grid of azimuth angle is not set.");
	}

	if(atmosphere_model.layers.empty())
	{
		throw std::runtime_error("[FATAL] Atmosphere Model has no layer.");
	}


	return;
}

inline double computeAsymmetryParameter(const std::vector<std::vector<double>>& f)
{
	double g = 0.0;

	int n = f.size();

	double num = 0.0;
	double den = 0.0;

	// double dtheta = f[1][0] - f[0][0];

	for(int i = 0; i < n; i ++)
	{
		double theta = f[i][0];
		double mu = std::cos(theta);
		double sine = std::sin(theta);

		// std::cout << theta * 180.0 / PI << ", " << f[i][1] << std::endl;

		if(i == 0 || i == n - 1)
		{
			num += f[i][1] * mu * sine;
			den += f[i][1] * sine;
		}
		else
		{
			num += 2.0 * f[i][1] * mu * sine;
			den += 2.0 * f[i][1] * sine;
		}
	}

	g = num / den;

	return g;
}

}