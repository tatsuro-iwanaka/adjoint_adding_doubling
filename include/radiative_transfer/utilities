#pragma once

#include<fstream>
#include<iostream>
#include<map>
#include<sstream>
#include<string>
#include<vector>
#include<algorithm>
#include<cmath>

#include"constants"
#include"types"

namespace radiative_transfer
{
std::string toUpper(std::string);
std::string toLower(std::string);
UnitInfo getUnitInfo(std::string);
double scaleUnit(std::string, std::string);
std::vector<std::string> splitString(std::string, char);
double computeInverseErrorFunction(double, double, int);
std::vector<std::vector<double>> computeGaussLegendreQuadratureNodeWeight(int);
std::vector<std::vector<double>> computeGaussHermiteQuadratureNodeWeight(int);
std::vector<std::vector<double>> computeGaussLaguerreQuadratureNodeWeight(int);
std::vector<std::vector<double>> computeGeneralizedGaussLaguerreQuadratureNodeWeight(int, double);
double computeGaussianQuadrature(std::vector<std::vector<double>>, std::vector<std::vector<double>>);
double computeTrapezoidalIntegration(const std::vector<std::vector<double>>&);
double computeSimpsonIntegration(const std::vector<std::vector<double>>&);
std::vector<std::vector<double>> computeGaussRadauQuadratureNodeWeight(int);
void normalizeWindowFunction(std::vector<double>&);
std::vector<double> interpolateTableLinear(double, const std::vector<std::vector<double>>&, std::vector<double>, std::vector<double>);
std::vector<double> computeLinearRegression(const std::vector<double>&, const std::vector<double>&);

inline std::string toUpper(std::string s)
{
	std::transform(s.begin(), s.end(), s.begin(), [](unsigned char c){return std::toupper(c);});
	return s;
}

inline std::string toLower(std::string s)
{
	std::transform(s.begin(), s.end(), s.begin(), [](unsigned char c){return std::tolower(c);});
	return s;
}

inline UnitInfo getUnitInfo(std::string unit_input)
{
	std::string u = toLower(unit_input);
	// 長さ
	if (u == "m") return { UnitDim::Length, 1.0 };
	if (u == "km") return { UnitDim::Length, 1.0E3 };
	if (u == "cm") return { UnitDim::Length, 1.0E-2 };
	if (u == "mm") return { UnitDim::Length, 1.0E-3 };
	if (u == "um" || u == "micron") return { UnitDim::Length, 1.0E-6 };
	if (u == "nm") return { UnitDim::Length, 1.0E-9 };
	// 面積
	if (u == "m2") return { UnitDim::Area, 1.0 };
	if (u == "km2") return { UnitDim::Area, 1.0E6 };
	if (u == "cm2") return { UnitDim::Area, 1.0E-4 };
	if (u == "mm2") return { UnitDim::Area, 1.0E-6 };
	if (u == "um2" || u == "micron2") return { UnitDim::Area, 1.0E-12 };
	if (u == "nm2") return { UnitDim::Area, 1.0E-18 };
	// 質量
	if (u == "kg") return { UnitDim::Mass, 1.0 };
	if (u == "g") return { UnitDim::Mass, 1.0E-3 };
	// 温度
	if (u == "k") return { UnitDim::Temperature, 1.0};
	//圧力
	if (u == "pa" || u == "pascal") return { UnitDim::Pressure, 1.0};
	if (u == "hpa" || u == "mbar") return { UnitDim::Pressure, 1.0E2};  // 1 hPa=100 Pa
	if (u == "bar") return { UnitDim::Pressure, 1.0E5};  // 1 bar=100 000 Pa
	if (u == "atm") return { UnitDim::Pressure, 101325.0};
	if (u == "torr" || u=="mmhg") return { UnitDim::Pressure, 101325.0 / 760.0};
	// --- 数密度 ---
	if (u == "m-3" || u == "1/m3") return { UnitDim::NumberDensity, 1.0 };
	if (u == "cm-3" || u == "1/cm3") return { UnitDim::NumberDensity, 1.0E6 };
	if (u == "mm-3" || u == "1/mm3") return { UnitDim::NumberDensity, 1.0E9 };
	if (u == "um-3" || u == "1/um3" || u == "micron-3" || u == "1/micron3") return { UnitDim::NumberDensity, 1.0E18 };
	if (u == "nm-3" || u == "1/nm3") return { UnitDim::NumberDensity, 1.0E27 };
	// --- 柱数密度 ---
	if (u == "m-2" || u == "1/m2") return { UnitDim::ColumnNumberDensity, 1.0 };
	if (u == "cm-2" || u == "1/cm2") return { UnitDim::ColumnNumberDensity, 1.0E4 };
	if (u == "mm-2" || u == "1/mm2") return { UnitDim::ColumnNumberDensity, 1.0E6 };
	if (u == "um-2" || u == "1/um2" || u == "micron-2" || u == "1/micron2") return { UnitDim::ColumnNumberDensity, 1.0E12 };
	if (u == "nm-2" || u == "1/nm2") return { UnitDim::ColumnNumberDensity, 1.0E18 };
	// --- 波数 ---
	if (u == "m-1" || u == "1/m") return { UnitDim::Wavenumber, 1.0 };
	if (u == "cm-1" || u == "1/cm" || u == "kayser") return { UnitDim::Wavenumber, 1.0E2 };
	if (u == "km-1" || u == "1/km") return { UnitDim::Wavenumber, 1.0E-3 };
	if (u == "um-1" || u == "1/um" || u == "micron-1"   || u == "1/micron") return { UnitDim::Wavenumber, 1.0E6 };
	if (u == "nm-1" || u == "1/nm") return { UnitDim::Wavenumber, 1.0E9 };
	// 無次元
	if (u == "1" || u == "none" || u == "mol/mol" || u == "dimensionless") return { UnitDim::Dimensionless, 1.0 };
	if (u == "ppm") return { UnitDim::Dimensionless, 1.0E-6 };
	if (u == "ppb") return { UnitDim::Dimensionless, 1.0E-9 };
	if (u == "ppt") return { UnitDim::Dimensionless, 1.0E-12 };
	
	logger::global().fatal("getUnitInfo") << "Unknown unit: " + unit_input;
	throw std::runtime_error("Unknown unit: " + unit_input);
}

inline double scaleUnit(std::string unit_input, std::string unit_output)
{
	UnitInfo inInfo = getUnitInfo(unit_input);
	UnitInfo outInfo = getUnitInfo(unit_output);

	if (inInfo.dim != outInfo.dim)
	{
		logger::global().fatal("scaleUnit") << "Unit dimension mismatch: cannot convert from `" + unit_input + "` to `" + unit_output + "`";
		throw std::runtime_error("Unit dimension mismatch: cannot convert from `" + unit_input + "` to `" + unit_output + "`");
	}
	// input→SI→output の合成倍率
	return inInfo.to_si / outInfo.to_si;
}

inline std::vector<std::string> splitString(std::string str, char del) 
{
	int first = 0;
	int last = str.find_first_of(del);

	std::vector<std::string> result;

	while (first < str.size())
	{
		std::string subStr(str, first, last - first);

		result.push_back(subStr);

		first = last + 1;
		last = str.find_first_of(del, first);

		if (last == std::string::npos)
		{
			last = str.size();
		}
	}

	return result;
}

inline double computeInverseErrorFunction(double y, double tolerance, int max_iterations)
{
	// Initial guess for x
	double x = y;
	
	// Iteratively improve the estimate
	for (int i = 0; i < max_iterations; i ++)
	{
		// Calculate the error function value and its derivative at the current estimate
		double erf_x = std::erf(x);
		double derivative = (2.0 / std::sqrt(PI)) * std::exp(-x * x);
		
		// Newton-Raphson step
		double delta_x = (erf_x - y) / derivative;
		x -= delta_x;
		
		// Check for convergence
		if(std::abs(delta_x) < tolerance)
		{
			break;
		}
	}
	
	return x;
}

inline std::vector<std::vector<double>> computeGaussLegendreQuadratureNodeWeight(int degree)
{
	// 1. ヤコビ行列 J の構築 (N x N)
	Eigen::MatrixXd J = Eigen::MatrixXd::Zero(degree, degree);
	
	// 非対角要素 β_k = k / sqrt(4k^2 - 1) を設定
	for (int k = 1; k < degree; ++k)
	{
		double k_double = static_cast<double>(k);
		double beta_k = k_double / std::sqrt(4.0 * k_double * k_double - 1.0);

		J(k - 1, k) = beta_k;
		J(k, k - 1) = beta_k;
	}

	// 2. 固有値問題の解決
	Eigen::SelfAdjointEigenSolver<Eigen::MatrixXd> es(J);
	
	if (es.info() != Eigen::Success)
	{
		logger::global().fatal("omputeGaussLegendreQuadratureNodeWeight") << "Eigenvalue solution failed for Legendre Jacobi matrix.";
		throw std::runtime_error("Eigenvalue solution failed for Legendre Jacobi matrix.");
	}

	// 3. ノードと重みの抽出 (w_i = 2 * (v_i, 1)^2)
	std::vector<std::vector<double>> node_weight(degree, std::vector<double>(2));
	const Eigen::VectorXd& eigenvalues = es.eigenvalues();
	const Eigen::MatrixXd& eigenvectors = es.eigenvectors();
	
	for (int i = 0; i < degree; ++i)
	{
		// ノード: 固有値がノード x_i
		node_weight[i][0] = eigenvalues(i); 

		// 重み: 固有ベクトルの第1成分の二乗に係数2をかける
		double v_i_1 = eigenvectors(0, i); 
		node_weight[i][1] = 2.0 * v_i_1 * v_i_1;
	}

	// 4. ノードを昇順にソート (省略されたソートロジックをここに挿入)
	std::sort(node_weight.begin(), node_weight.end(), [](const std::vector<double>& a, const std::vector<double>& b){return a[0] < b[0];});

	return node_weight;
}

inline std::vector<std::vector<double>> computeGaussHermiteQuadratureNodeWeight(int degree)
{
	if (degree <= 0)
	{
		logger::global().fatal("computeGaussHermiteQuadratureNodeWeight") << "Degree must be positive for Gaussian-Hermite quadrature.";
		throw std::runtime_error("Degree must be positive for Gaussian-Hermite quadrature.");
	}
	
	// 1. ヤコビ行列 J の構築 (N x Nの対称三重対角行列)
	Eigen::MatrixXd J = Eigen::MatrixXd::Zero(degree, degree);
	
	// J_{k, k+1} = J_{k+1, k} = sqrt(k/2) を設定 (k = 1 to N-1)
	for (int k = 1; k < degree; ++k)
	{
		double sub_diag_value = std::sqrt(static_cast<double>(k) / 2.0);
		J(k - 1, k) = sub_diag_value; // Super-diagonal (i, i+1)
		J(k, k - 1) = sub_diag_value; // Sub-diagonal (i+1, i)
	}

	// 2. 固有値問題の解決
	// SelfAdjointEigenSolver を使用 (Jが対称行列であるため)
	Eigen::SelfAdjointEigenSolver<Eigen::MatrixXd> es(J);
	
	if (es.info() != Eigen::Success)
	{
		// 固有値計算の失敗
		logger::global().fatal("computeGaussHermiteQuadratureNodeWeight") << "Eigenvalue solution failed for Hermite Jacobi matrix.";
		throw std::runtime_error("Eigenvalue solution failed for Hermite Jacobi matrix.");
	}

	// 3. ノードと重みの抽出
	std::vector<std::vector<double>> node_weight(degree, std::vector<double>(2));
	
	// ノードは固有値 (es.eigenvalues())
	// 重みは第1成分 (es.eigenvectors().col(i)(0)) を使う
	const Eigen::VectorXd& eigenvalues = es.eigenvalues();
	const Eigen::MatrixXd& eigenvectors = es.eigenvectors();

	double sqrt_pi = std::sqrt(PI);
	
	for (int i = 0; i < degree; ++i)
	{
		// ノード: 固有値がそのままノード x_i
		node_weight[i][0] = eigenvalues(i); 

		// 重み: w_i = sqrt(pi) * (v_i, 1)^2
		double v_i_1 = eigenvectors(0, i); // 第1成分 (0行 i列)
		node_weight[i][1] = sqrt_pi * v_i_1 * v_i_1;
	}

	// 4. ノードを昇順にソート (Eigenの結果は通常ソートされているが、念のため)
	std::sort(node_weight.begin(), node_weight.end(), [](const std::vector<double>& a, const std::vector<double>& b){return a[0] < b[0];});

	return node_weight;
}

inline std::vector<std::vector<double>> computeGaussLaguerreQuadratureNodeWeight(int degree)
{
	if (degree <= 0)
	{
		logger::global().fatal("computeGaussLaguerreQuadratureNodeWeight") << "Degree must be positive for Gaussian-Laguerre quadrature.";
		throw std::runtime_error("Degree must be positive for Gaussian-Laguerre quadrature.");
	}
	
	// 1. ヤコビ行列 J の構築 (N x Nの対称三重対角行列)
	Eigen::MatrixXd J = Eigen::MatrixXd::Zero(degree, degree);
	
	// J_{i, i} = 2i + 1 を設定 (対角要素)
	// J_{i, i+1} = J_{i+1, i} = i + 1 を設定 (非対角要素)
	for (int i = 0; i < degree; ++i)
	{
		double i_double = static_cast<double>(i);
		
		// 対角要素: J_ii = 2i + 1
		J(i, i) = 2.0 * i_double + 1.0;
		
		if (i < degree - 1)
		{
			// 非対角要素: J_{i, i+1} = i + 1
			double off_diag_value = i_double + 1.0;
			J(i, i + 1) = off_diag_value; 
			J(i + 1, i) = off_diag_value;
		}
	}

	// 2. 固有値問題の解決
	Eigen::SelfAdjointEigenSolver<Eigen::MatrixXd> es(J);
	
	if (es.info() != Eigen::Success)
	{
		logger::global().fatal("computeGaussLaguerreQuadratureNodeWeight") << "Eigenvalue solution failed for Laguerre Jacobi matrix.";
		throw std::runtime_error("Eigenvalue solution failed for Laguerre Jacobi matrix.");
	}

	// 3. ノードと重みの抽出
	std::vector<std::vector<double>> node_weight(degree, std::vector<double>(2));
	
	const Eigen::VectorXd& eigenvalues = es.eigenvalues();
	const Eigen::MatrixXd& eigenvectors = es.eigenvectors();
	
	for (int i = 0; i < degree; ++i)
	{
		// ノード: 固有値がそのままノード x_i
		node_weight[i][0] = eigenvalues(i); 

		// 重み: w_i = (v_i, 1)^2
		double v_i_1 = eigenvectors(0, i); // 第1成分 (0行 i列)
		node_weight[i][1] = v_i_1 * v_i_1;
	}

	// 4. ノードを昇順にソート (ノードは物理的に正の値 x >= 0)
	std::sort(node_weight.begin(), node_weight.end(), [](const std::vector<double>& a, const std::vector<double>& b){return a[0] < b[0];});

	return node_weight;
}

inline std::vector<std::vector<double>> computeGeneralizedGaussLaguerreQuadratureNodeWeight(int degree, double alpha_prime)
{
	if (degree <= 0)
	{
		logger::global().fatal("computeGeneralizedGaussLaguerreQuadratureNodeWeight") << "Degree must be positive for Gaussian-Laguerre quadrature.";
		throw std::runtime_error("Degree must be positive for Gaussian-Laguerre quadrature.");
	}
	
	// 1. ヤコビ行列 J の構築 (N x Nの対称三重対角行列)
	Eigen::MatrixXd J = Eigen::MatrixXd::Zero(degree, degree);
	
	for (int i = 0; i < degree; ++i)
	{
		double i_double = static_cast<double>(i);
		
		// 対角要素: J_ii = 2i + 1 + alpha'
		J(i, i) = 2.0 * i_double + 1.0 + alpha_prime;
		
		if (i < degree - 1)
		{
			// 非対角要素: J_{i, i+1} = J_{i+1, i} = sqrt((i+1)(i+1 + alpha'))
			double k_plus_1 = i_double + 1.0;
			double off_diag_value = std::sqrt(k_plus_1 * (k_plus_1 + alpha_prime));
			
			J(i, i + 1) = off_diag_value; 
			J(i + 1, i) = off_diag_value;
		}
	}

	// 2. 固有値問題の解決
	Eigen::SelfAdjointEigenSolver<Eigen::MatrixXd> es(J);
	
	if (es.info() != Eigen::Success)
	{
		logger::global().fatal("computeGeneralizedGaussLaguerreQuadratureNodeWeight") << "Eigenvalue solution failed for Generalized Laguerre Jacobi matrix.";
		throw std::runtime_error("Eigenvalue solution failed for Generalized Laguerre Jacobi matrix.");
	}

	// 3. ノードと重みの抽出 (w_i = Gamma(alpha'+1) * (v_i, 1)^2)
	std::vector<std::vector<double>> node_weight(degree, std::vector<double>(2));
	
	const Eigen::VectorXd& eigenvalues = es.eigenvalues();
	const Eigen::MatrixXd& eigenvectors = es.eigenvectors();
	
	// 重み計算の定数ファクター: Gamma(alpha' + 1)
	double gamma_factor = std::tgamma(alpha_prime + 1.0);
	
	for (int i = 0; i < degree; ++i)
	{
		// ノード: 固有値がノード x_i
		node_weight[i][0] = eigenvalues(i); 

		// 重み: w_i = Gamma(alpha'+1) * (v_i, 1)^2
		double v_i_1 = eigenvectors(0, i); 
		node_weight[i][1] = gamma_factor * v_i_1 * v_i_1;
	}

	// 4. ノードを昇順にソート
	std::sort(node_weight.begin(), node_weight.end(), [](const std::vector<double>& a, const std::vector<double>& b){return a[0] < b[0];});

	return node_weight;
}

inline double computeGaussianQuadrature(std::vector<std::vector<double>> node_weight, std::vector<std::vector<double>> function_values)
{
	double result = 0.0;
	int number_of_nodes = node_weight.size();

	double min_range = 1.0E300;
	double max_range = -1.0E300;

	// 区間の範囲を計算
	for (int i = 0; i < number_of_nodes; i++)
	{
		if (function_values[i][0] < min_range)
		{
			min_range = function_values[i][0];
		}
		if (function_values[i][0] > max_range)
		{
			max_range = function_values[i][0];
		}

		// 重み × 関数値を積分
		result += node_weight[i][1] * function_values[i][1];
	}

	result *= (max_range - min_range) * 0.5;

	return result;
}

inline double computeTrapezoidalIntegration(const std::vector<std::vector<double>>& f)
{
	int n = f.size();
	/*
		double result = 0.0;
		for(int i = 0; i < n - 1; i ++)
		{
			result += 0.5 * (f[i][1] + f[i + 1][1]) * (f[i + 1][0] - f[i][0]);
		}
	*/
	double result = (f[0][1] + f[n - 1][1]) * 0.5;

	for(int i = 1; i < n - 1; i ++)
	{
		result += f[i][1];
	}

	result *= f[1][0] - f[0][0];

	return result;
}

inline double computeSimpsonIntegration(const std::vector<std::vector<double>>& f)
{
	int n = f.size();

	if(n % 2 == 0)
	{
		std::cout << "ERROR: NUMBER OF DATA SHOULD BE ODD." << std::endl;
	}
	
	double result = 0.0;

	for(int i = 0; i < n; i ++)
	{
		if(i == 0 || i == n - 1)
		{
			result += f[i][1];
		}
		else if(i % 2 == 0)
		{
			result += 2.0 * f[i][1];
		}
		else if(i % 2 == 1)
		{
			result += 4.0 * f[i][1];
		}
	}

	result *= (f[1][0] - f[0][0]) / 3.0;

	return result;
}

inline std::vector<std::vector<double>> computeGaussRadauQuadratureNodeWeight(int n)
{
	assert(n >= 2);
	const int m = n - 1;
	
	const double a = 1.0;
	const double b = 0.0;

	Eigen::MatrixXd J = Eigen::MatrixXd::Zero(m, m);

	for (int k = 0; k < m; ++k)
	{
		J(k, k) = (b * b - a * a) / ((2.0 * k + a + b) * (2.0 * k + a + b + 2.0)); 

		if (k < m - 1)
		{
			double num = 4.0 * (k + 1.0) * (k + a + 1.0) * (k + b + 1.0) * (k + a + b + 1.0);
			double den = (2.0 * k + a + b + 1.0) * (2.0 * k + a + b + 3.0) * std::pow(2.0 * k + a + b + 2.0, 2);
			double e = std::sqrt(num / den);

			J(k, k + 1) = e;
			J(k + 1, k) = e;
		}
	}

	Eigen::SelfAdjointEigenSolver<Eigen::MatrixXd> es(J);
	auto evals = es.eigenvalues();

	std::vector<double> xi(n);
	
	for (int i = 0; i < m; ++i)
	{
		xi[i] = evals(i);
	}

	xi[m] = 1.0;
	
	std::vector<double> Wi(n);
	
	for (int i = 0; i < m; ++i)
	{
		double Pnm1 = std::legendre(n - 1, xi[i]); // P_{n-1}(xi)
		Wi[i] = (1.0 + xi[i]) / (static_cast<double>(n) * static_cast<double>(n) * Pnm1 * Pnm1);
	}
	Wi[m] = 2.0 / (static_cast<double>(n) * static_cast<double>(n));

	std::vector<std::vector<double>> out(n, std::vector<double>(2.0));
	for (int i = 0; i < n; ++i)
	{
		double x01 = 0.5 * (xi[i] + 1.0);
		double w01 = 0.5 * Wi[i];
		out[i][0] = static_cast<double>(x01);
		out[i][1] = static_cast<double>(w01);
	}
	
	return out;
}

inline void normalizeWindowFunction(std::vector<double>& f)
{
	double sum = 0.0;
	for(int i = 0; i < f.size(); i ++)
	{
		sum += f[i];
	}

	for(int i = 0; i < f.size(); i ++)
	{
		f[i] /= sum;
	}

	return;
}

inline std::vector<double> interpolateTableLinear(double x, const std::vector<std::vector<double>>& table, std::vector<double> extrapolation_left = {}, std::vector<double> extrapolation_right = {})
{
	// 0. エラーチェック
	if (table.empty() || table[0].size() < 2)
	{
		return {}; // データがない、またはX列しかない
	}

	// 補間対象の次元数 (列数 - 1)
	size_t num_values = table[0].size() - 1;

	// ヘルパー: 外挿値の決定 (指定がなければ 0.0 埋め)
	auto resolve_extrapolation = [&](const std::vector<double>& user_val) -> std::vector<double>
	{
		if (user_val.size() == num_values)
		{
			return user_val;
		}

		return std::vector<double>(num_values, 0.0);
	};

	// 1. 範囲外チェック (外挿処理)
	if (x < table.front()[0])
	{
		return resolve_extrapolation(extrapolation_left);
	}
	if (x > table.back()[0])
	{
		return resolve_extrapolation(extrapolation_right);
	}

	// 2. 二分探索
	auto it = std::lower_bound(table.begin(), table.end(), x, [](const std::vector<double>& row, double val){return row[0] < val;});

	// 始点と一致する場合
	if (it == table.begin())
	{
		// table.front() の [1] 以降をコピーして返す
		return std::vector<double>(table.front().begin() + 1, table.front().end());
	}

	// 左側のインデックス
	size_t j = std::distance(table.begin(), it) - 1;

	// 3. 補間係数の計算
	double x0 = table[j][0];
	double x1 = table[j + 1][0];

	// x間隔が極小の場合（ゼロ割防止）は左側の値を返す
	if (std::abs(x1 - x0) < 1.0e-9)
	{
		return std::vector<double>(table[j].begin() + 1, table[j].end());
	}

	double r = (x - x0) / (x1 - x0);
	double r_inv = 1.0 - r;

	// 4. 全成分の線形補間ループ
	std::vector<double> result;
	result.reserve(num_values); // メモリ確保の効率化

	// k=1 (2列目) から最後までループ
	const auto& row0 = table[j];
	const auto& row1 = table[j + 1];

	for (size_t k = 1; k <= num_values; ++k)
	{
		double y0 = row0[k];
		double y1 = row1[k];
		result.push_back(r_inv * y0 + r * y1);
	}

	return result;
}

std::vector<double> computeLinearRegression(const std::vector<double>& x, const std::vector<double>& y)
{
	size_t n = x.size();
	if (n < 2)
	{
		return {0.0, y[0]};
	}

	double sum_x = 0.0, sum_y = 0.0, sum_xy = 0.0, sum_xx = 0.0;
	
	for (size_t i = 0; i < n; ++i)
	{
		sum_x += x[i];
		sum_y += y[i];
		sum_xy += x[i] * y[i];
		sum_xx += x[i] * x[i];
	}

	double denominator = n * sum_xx - sum_x * sum_x;
	double slope, intercept;

	if (std::abs(denominator) < 1e-12)
	{
		slope = 0.0; // 特異点回避（実際はありえないが念のため）
		intercept = sum_y / static_cast<double>(n);
	}
	else
	{
		slope = (static_cast<double>(n) * sum_xy - sum_x * sum_y) / denominator;
		intercept = (sum_y - slope * sum_x) / static_cast<double>(n);
	}

	return {slope, intercept};
}

std::vector<size_t> argsort(const std::vector<double>& v)
{
	std::vector<size_t> indices(v.size());
	std::iota(indices.begin(), indices.end(), 0);
	std::sort(indices.begin(), indices.end(), [&v](size_t i, size_t j){return v[i] < v[j];});
	return indices;
}

void sort(std::vector<double>& x, std::vector<double>& y)
{
	if (x.size() != y.size())
	{
		return;
	}

	std::vector<size_t> idx_x = argsort(x);
	std::vector<double> sorted_y = y;
	std::vector<double> sorted_x = x;
	for (size_t i = 0; i < x.size(); ++i)
	{
		x[i] = sorted_x[idx_x[i]];
		y[i] = sorted_y[idx_x[i]];
	}

	return;
}

void sort(std::vector<double>& x, std::vector<double>& y, std::vector<std::vector<double>>& z)
{
	if (x.empty() || y.empty() || z.size() != x.size())
	{
		return;
	}

	if (z[0].size() != y.size())
	{
		return;
	}

	std::vector<size_t> idx_x = argsort(x);

	std::vector<double> sorted_x = x;
	std::vector<std::vector<double>> sorted_z_rows = z;
	for (size_t i = 0; i < x.size(); ++i)
	{
		x[i] = sorted_x[idx_x[i]];
		z[i] = sorted_z_rows[idx_x[i]];
	}
	std::vector<size_t> idx_y = argsort(y);

	std::vector<double> sorted_y = y;
	for (size_t j = 0; j < y.size(); ++j)
	{
		y[j] = sorted_y[idx_y[j]];
	}

	std::vector<double> row_copy(y.size());

	for (size_t i = 0; i < z.size(); ++i)
	{
		row_copy = z[i];

		for (size_t j = 0; j < y.size(); ++j)
		{
			z[i][j] = row_copy[idx_y[j]];
		}
	}

	return;
}


}