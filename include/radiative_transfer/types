#pragma once

#include <map>
#include <vector>
#include <string>
#include <fstream>
#include <Eigen/Dense>
#include <optional>

#include "constants"
#include "hitran"

namespace radiative_transfer
{
enum class UnitDim{Length, Area, Mass, Temperature, Pressure, NumberDensity, ColumnNumberDensity, Wavenumber, Dimensionless};

enum class SpectralCoordinateDimension{Wavenumber, Wavelength, Frequency};
const inline std::map<std::string, SpectralCoordinateDimension> map_spectral_coordinate_dimension =
{
	{"WAVENUMBER",  SpectralCoordinateDimension::Wavenumber},
	{"WAVELENGTH", SpectralCoordinateDimension::Wavelength},
	{"FREQUENCY",  SpectralCoordinateDimension::Frequency}
};

enum class SpectralCoordinateType{Monochrome, Spectrum, Bandpass};
const inline std::map<std::string, SpectralCoordinateType> map_spectral_coordinate_type =
{
	{"MONOCHROME",  SpectralCoordinateType::Monochrome},
	{"SPECTRUM",  SpectralCoordinateType::Spectrum},
	{"BANDPASS", SpectralCoordinateType::Bandpass}
};

enum class VerticalProfileInterpolation{Exponential, Linear};
const inline std::map<std::string, VerticalProfileInterpolation> map_vertical_profile_interpolation =
{
	{"EXPONENTIAL",  VerticalProfileInterpolation::Exponential},
	{"LINEAR", VerticalProfileInterpolation::Linear}
};

enum class ScatterType{Rayleigh, Mie, HenyeyGreenstein, Isotropic};
const inline std::map<std::string, ScatterType> map_scatter_type =
{
	{"RAYLEIGH",  ScatterType::Rayleigh},
	{"MIE", ScatterType::Mie},
	{"HENYEY_GREENSTEIN",  ScatterType::HenyeyGreenstein},
	{"HENYEYGREENSTEIN", ScatterType::HenyeyGreenstein},
	{"HG",  ScatterType::HenyeyGreenstein},
	{"ISOTROPIC", ScatterType::Isotropic}
};

enum class SpeciesState{Molecule, Aerosol};
const inline std::map<std::string, SpeciesState> map_species_state =
{
	{"MOLECULE",  SpeciesState::Molecule},
	{"AEROSOL", SpeciesState::Aerosol}
};

enum class SpeciesType{Absorber, Scatterer, Extinction};
const inline std::map<std::string, SpeciesType> map_species_type =
{
	{"ABSORBER",  SpeciesType::Absorber},
	{"SCATTERER", SpeciesType::Scatterer},
	{"EXTINCTION", SpeciesType::Extinction},
	{"BOTH", SpeciesType::Extinction}
};

enum class ParticleSizeDistribution{Delta, Rectangular, LogNormal, Gamma, ModifiedGamma, PowerLaw};
const inline std::map<std::string, ParticleSizeDistribution> map_particle_size_distribution =
{
	{"DELTA", ParticleSizeDistribution::Delta},
	{"RECTANGULAR", ParticleSizeDistribution::Rectangular},
	{"LOG_NORMAL", ParticleSizeDistribution::LogNormal},
	{"LOGNORMAL", ParticleSizeDistribution::LogNormal},
	{"GAMMA", ParticleSizeDistribution::Gamma},
	{"MODIFIED_GAMMA", ParticleSizeDistribution::ModifiedGamma},
	{"MODIFIEDGAMMA", ParticleSizeDistribution::ModifiedGamma},
	{"POWER_LAW", ParticleSizeDistribution::PowerLaw}
};

enum class VerticalProfileType{MixingRatio, NumberDensity, ColumnNumberDensity};
const inline std::map<std::string, VerticalProfileType> map_vertical_profile_type =
{
	{"MIXING_RATIO",  VerticalProfileType::MixingRatio},
	{"NUMBER_DENSITY", VerticalProfileType::NumberDensity},
	{"NUMBERDENSITY", VerticalProfileType::NumberDensity},
	{"COLUMN_NUMBER_DENSITY", VerticalProfileType::ColumnNumberDensity},
	{"COLUMNNUMBERDENSITY", VerticalProfileType::ColumnNumberDensity}
};

enum class CrossSectionType{External, Constant, HITRAN};
const inline std::map<std::string, CrossSectionType> map_cross_section_type =
{
	{"EXTERNAL",  CrossSectionType::External},
	{"CONSTANT", CrossSectionType::Constant},
	{"HITRAN", CrossSectionType::HITRAN}
};

enum class RefractiveIndexSpectrumType{Constant, External};
const inline std::map<std::string, RefractiveIndexSpectrumType> map_refractive_index_spectrum_type =
{
	{"CONSTANT",  RefractiveIndexSpectrumType::Constant},
	{"EXTERNAL", RefractiveIndexSpectrumType::External}
};

enum class RefractiveIndexVerticalProfile{Constant, Table};
const inline std::map<std::string, RefractiveIndexVerticalProfile> map_refractive_index_vertical_profile_type =
{
	{"CONSTANT", RefractiveIndexVerticalProfile::Constant},
	{"TABLE", RefractiveIndexVerticalProfile::Table}
};

enum class InCellSuperSamplingType{Enable, Disable};
const inline std::map<std::string, InCellSuperSamplingType> map_in_cell_super_sampling_type =
{
	{"ENABLE",  InCellSuperSamplingType::Enable},
	{"DISABLE", InCellSuperSamplingType::Disable}
};

enum class DeltaApproximationType{Disable, d_m1, d_m2, FWHM, Cumulative};
const inline std::map<std::string, DeltaApproximationType> map_delta_approximation_type =
{
	{"NONE",  DeltaApproximationType::Disable},
	{"DISABLE", DeltaApproximationType::Disable},
	{"D_M1", DeltaApproximationType::d_m1},
	{"DM1", DeltaApproximationType::d_m1},
	{"DELTA_M_1", DeltaApproximationType::d_m1},
	{"DELTA_M1", DeltaApproximationType::d_m1},
	{"D_M2", DeltaApproximationType::d_m2},
	{"DM2", DeltaApproximationType::d_m2},
	{"DELTA_M_2", DeltaApproximationType::d_m2},
	{"DELTA_M2", DeltaApproximationType::d_m2},
	{"FWHM", DeltaApproximationType::FWHM},
	{"CUMULATIVE", DeltaApproximationType::Cumulative}
};

enum class VerticalTemperatureProfile{VIRA_EQUATOR, VIRA_45, VIRA_60, Table, External};
const inline std::map<std::string, VerticalTemperatureProfile> map_vertical_temperature_profile =
{
	{"VIRA_EQUATOR",  VerticalTemperatureProfile::VIRA_EQUATOR},
	{"VIRA_45", VerticalTemperatureProfile::VIRA_45},
	{"VIRA_60", VerticalTemperatureProfile::VIRA_60},
	{"TABLE", VerticalTemperatureProfile::Table},
	{"EXTERNAL", VerticalTemperatureProfile::External}
};

enum class VerticalPressureProfile{VIRA_EQUATOR, VIRA_45, VIRA_60, Table, Hydrostatic, External};
const inline std::map<std::string, VerticalPressureProfile> map_vertical_pressure_profile =
{
	{"VIRA_EQUATOR",  VerticalPressureProfile::VIRA_EQUATOR},
	{"VIRA_45", VerticalPressureProfile::VIRA_45},
	{"VIRA_60", VerticalPressureProfile::VIRA_60},
	{"TABLE", VerticalPressureProfile::Table},
	{"HYDROSTATIC", VerticalPressureProfile::Hydrostatic},
	{"EXTERNAL", VerticalPressureProfile::External}
};

enum class VerticalNumberDensityProfile{VIRA_EQUATOR, VIRA_45, VIRA_60, Table, External, IdealGas};
const inline std::map<std::string, VerticalNumberDensityProfile> map_vertical_number_density_profile =
{
	{"VIRA_EQUATOR",  VerticalNumberDensityProfile::VIRA_EQUATOR},
	{"VIRA_45", VerticalNumberDensityProfile::VIRA_45},
	{"VIRA_60", VerticalNumberDensityProfile::VIRA_60},
	{"TABLE", VerticalNumberDensityProfile::Table},
	{"EXTERNAL", VerticalNumberDensityProfile::External},
	{"IDEALGAS", VerticalNumberDensityProfile::IdealGas},
	{"IDEAL_GAS", VerticalNumberDensityProfile::IdealGas},
	{"IDEALGASLAW", VerticalNumberDensityProfile::IdealGas},
	{"IDEAL_GAS_LAW", VerticalNumberDensityProfile::IdealGas}
};

enum class SurfaceType{NoSurface, Lambert};
const inline std::map<std::string, SurfaceType> map_surface_type =
{
	{"NO_SURFACE",  SurfaceType::NoSurface},
	{"NOSURFACE", SurfaceType::NoSurface},
	{"NONE", SurfaceType::NoSurface},
	{"LAMBERT", SurfaceType::Lambert},
	{"LAMBERTIAN", SurfaceType::Lambert}
};


enum class WindowFunctionType{Gauss, Rectangle, External, Table};
const inline std::map<std::string, WindowFunctionType> map_window_function_type =
{
	{"GAUSS",  WindowFunctionType::Gauss},
	{"GAUSSIAN",  WindowFunctionType::Gauss},
	{"RECTANGLE", WindowFunctionType::Rectangle},
	{"RECTANGULAR", WindowFunctionType::Rectangle},
	{"TABLE", WindowFunctionType::Table},
	{"EXTERNAL", WindowFunctionType::External}
};

enum class GridType{Regular, GaussRadau};
const inline std::map<std::string, GridType> map_grid_type =
{
	{"GAUSSRADAU",  GridType::GaussRadau},
	{"GAUSS_RADAU",  GridType::GaussRadau},
	{"REGULAR", GridType::Regular}
};

enum class InstrumentFunctionType{Gauss, Rectangle, Table, External};
const inline std::map<std::string, InstrumentFunctionType> map_instrument_function_type =
{
	{"GAUSS",  InstrumentFunctionType::Gauss},
	{"GAUSSIAN",  InstrumentFunctionType::Gauss},
	{"RECTANGLE", InstrumentFunctionType::Rectangle},
	{"RECTANGULAR", InstrumentFunctionType::Rectangle},
	{"TABLE", InstrumentFunctionType::Table},
	{"EXTERNAL", InstrumentFunctionType::External}
};

enum class IsotopologueType{All, Defined};
const inline std::map<std::string, IsotopologueType> map_isotopologue_type =
{
	{"ALL",  IsotopologueType::All},
	{"HITRAN",  IsotopologueType::All},
	{"DEFINED", IsotopologueType::Defined},
	{"TABLE", IsotopologueType::Defined}
};

enum class IsotopologueAbundanceType{HITRAN, Defined};
const inline std::map<std::string, IsotopologueAbundanceType> map_isotopologue_abundance_type =
{
	{"HITRAN",  IsotopologueAbundanceType::HITRAN},
	{"DEFINED", IsotopologueAbundanceType::Defined},
	{"TABLE", IsotopologueAbundanceType::Defined}
};

enum class JacobianType{Temperature, TotalNumberDensity, SpeciesNumberDensity, SpeciesMixingRatio};

class UnitInfo
{	
	public:
		UnitDim dim;
		double to_si;  // この単位 → SI 基本単位への乗数
};

struct Species
{
	// ヤコビアン計算に必要な最低限を残す
	// 微小変化させるのはこのSpecies
	// これを微小変化させた後に放射計算の準備
	// これを使ってMie計算を行う
	// Mie計算に必要なのは複素屈折率，粒径分布
	// 数密度（混合比）の鉛直分布
	// 複素屈折率の鉛直分布
	// 吸収断面積，散乱断面積
	public:
		std::string name;
		SpeciesState species_state;
		SpeciesType species_type;
		ScatterType scatter_type;

		std::vector<std::vector<double>> particle_size_distribution; // spectral, size_distribution
		std::vector<std::vector<double>> weight_particle_size_distribution; // spectral, weights

		double g_factor;	//g-factor for Henyey-Greenstein function

		double absorption_cross_section;	//m^2/molecule
		double scattering_cross_section;	//m^2/molecule

		std::vector<double> absorption_cross_section_spectrun;	// spectral, m^2/molecule
		std::vector<double> scattering_cross_section_spectrun;	// spectral, m^2/molecule

		std::vector<double> vertical_number_density_profile;	// m-3
		std::vector<double> vertical_mixing_ratio_profile;	// mol/mol
		std::vector<std::vector<double>> refractive_index_vertical_profile; // nr, ni

		hitran::Isotopologue isotopologue;
		std::vector<hitran::Line> lines;
		double abundance = 1.0;
};

struct OpticalLayer
{
	public:
		double planck_function; // IR計算用 プランク関数
		double absorption_coefficient; //m-1
		double scattering_coefficient; //m-1
		double optical_thickness; //dimensionless
		double single_scattering_albedo; //ks/(ks + ka)

		int n_doubling = 0;

		double asymmetry_parameter;

		std::vector<std::vector<double>> scattering_phase_function;	//angle (radian), magnitude (dimensionless)
};

struct RadiativeLayer
{
	public:
		std::vector<Eigen::MatrixXd> reflectance_m_top_cos;
		std::vector<Eigen::MatrixXd> reflectance_m_bottom_cos;
		std::vector<Eigen::MatrixXd> transmittance_m_top_cos;
		std::vector<Eigen::MatrixXd> transmittance_m_bottom_cos;

		std::vector<Eigen::MatrixXd> reflectance_m_top_sin;
		std::vector<Eigen::MatrixXd> reflectance_m_bottom_sin;
		std::vector<Eigen::MatrixXd> transmittance_m_top_sin;
		std::vector<Eigen::MatrixXd> transmittance_m_bottom_sin;

		double optical_thickness; //dimensionless
};

struct AtmosphereModel
{
	public:
		std::vector<Species> species;
		SurfaceType surface_type;
		double surface_temperature;
		double surface_albedo;
		std::vector<double> altitude_bottom;
		std::vector<double> altitude_top;
		std::vector<double> altitude;
		std::vector<double> temperature;
		std::vector<double> pressure;
		std::vector<double> number_density;
		hitran::Diluent diluent;
		// bool enable_atmospheric_emission = false;
};

/*
class AtmosphereModel
{
	private:
		
	public:		
		std::vector<Layer> layers;
		Layer surface_layer;
		Layer result_layer;
		std::vector<Species> species;

		hitran::Diluent diluent = hitran::Diluent(1.0, 0.0, 0.0, 0.0, 0.0);

		// int M = -99;
		// int Ntheta;
		// int Nphi = -99;

		std::optional<int> M;
		std::optional<int> Ntheta;
		std::optional<int> Nphi;
		
		// std::ofstream log_out;

		const int radius_n = 1001;
		const int theta_n = 1001;

		AtmosphereModel(void)
		{
			return;
		}
};

class Layer
{
	private:

	public:
		std::vector<std::vector<std::vector<double>>> reflectance_top;
		std::vector<std::vector<std::vector<double>>> reflectance_bottom;
		std::vector<std::vector<std::vector<double>>> transmittance_top;
		std::vector<std::vector<std::vector<double>>> transmittance_bottom;

		std::vector<Eigen::MatrixXd> reflectance_m_top_cos;
		std::vector<Eigen::MatrixXd> reflectance_m_bottom_cos;
		std::vector<Eigen::MatrixXd> transmittance_m_top_cos;
		std::vector<Eigen::MatrixXd> transmittance_m_bottom_cos;

		std::vector<Eigen::MatrixXd> reflectance_m_top_sin;
		std::vector<Eigen::MatrixXd> reflectance_m_bottom_sin;
		std::vector<Eigen::MatrixXd> transmittance_m_top_sin;
		std::vector<Eigen::MatrixXd> transmittance_m_bottom_sin;

		Eigen::VectorXd source_up;
		Eigen::VectorXd source_down;

		double altitude_bottom; //m
		double altitude_top; //m
		double altitude; //m
		double physical_thickness; //m

		double temperature;	//K
		double pressure;	//Pa

		double planck_function; // IR計算用 プランク関数

		double number_density;	//molecules/m^3
		
		double absorption_coefficient; //m-1
		double scattering_coefficient; //m-1
		double optical_thickness; //dimensionless
		double single_scattering_albedo; //ks/(ks + ka)

		bool enable_atmospheric_emission = false;

		int n_doubling = 0;

		double asymmetry_parameter;

		std::vector<std::vector<double>> scattering_phase_function;	//angle (radian), magnitude (dimensionless)

		std::vector<double> mixing_ratio_species;
		std::vector<double> number_density_species;

		void normalizeScatteringPhaseFunction(void);
		void exportPhaseFunction(std::string);
};

class Species
{
	private:
		std::string name_;
		SpeciesState species_state_ = SpeciesState::Molecule;
		SpeciesType species_type_ = SpeciesType::Absorber;
		ScatterType scatter_type_ = ScatterType::Isotropic;
		VerticalProfileInterpolation vertical_profile_interpolation_ = VerticalProfileInterpolation::Exponential;
		VerticalProfileType vertical_profile_type_ = VerticalProfileType::MixingRatio;
		ParticleSizeDistribution size_distribution_ = ParticleSizeDistribution::Delta;
		RefractiveIndexSpectrumType refractive_index_type_ = RefractiveIndexSpectrumType::Constant;
		CrossSectionType scattering_cross_section_type_ = CrossSectionType::Constant;
		CrossSectionType absorption_cross_section_type_ = CrossSectionType::Constant;

		std::string unit_input_absorption_cross_section_ = "m2";
		std::string unit_input_absorption_wavelength_ = "m";
		std::string unit_input_absorption_wavenumber_ = "m-1";
		UnitDim unit_x_input_absorption_ = UnitDim::Length;

		std::string unit_input_scattering_cross_section_ = "m2";
		std::string unit_input_scattering_wavelength_ = "m";
		std::string unit_input_scattering_wavenumber_ = "m-1";
		UnitDim unit_x_input_scattering_ = UnitDim::Length;

		std::string unit_input_refractive_index_wavelength_ = "m";
		std::string unit_input_refractive_index_wavenumber_ = "m-1";
		UnitDim unit_x_input_refractive_index_ = UnitDim::Length;

		std::string unit_input_radius_ = "m";

		// double scale_cross_section_ = 1.0;

		double size_ = 0.1E-6; // m
		double r_g_ = 0.1E-6; // m
		double sigma_g_ = 0.15E-6; // m
		double r_mean_ = 0.1E-6; // m
		double sigma_ = 0.15E-6; // m
		int n_radius_ = 1001;
		double width_ = 0.15E-6; // m

		double g_factor_;	//g-factor for Henyey-Greenstein function
		
		double nr_ = 1.5;	//real part of refractive index n = nr - i * ni
		double ni_ = 0.0;	//imaginary part of refractive index n = nr - i * ni

		std::vector<std::vector<double>> refractive_index_vertical_profile_; // m, nr, ni
		std::vector<std::vector<double>> absorption_cross_section_vertical_profile_;
		std::vector<std::vector<double>> scattering_cross_section_vertical_profile_;
		
		double absorption_cross_section_ = 0.0;	//m^2/molecule
		double scattering_cross_section_ = 0.0;	//m^2/molecule

		std::vector<std::vector<double>> vertical_profile_;	//m, mol/mol
		bool is_same_layering_atmosphere_ = false;

		std::string filename_scattering_cross_section_;
		std::string filename_absorption_cross_section_;
		std::string filename_refractive_index_;
		std::string filename_size_distribution_;

		std::vector<std::vector<double>> scattering_phase_function_;

		int molecule_id_;
		int local_isotopologue_id_;
		int global_id_;
		std::string filename_hitran_;
		hitran::Isotopologue isotopologue_;
		std::vector<hitran::Line> lines_;
		double abundance_ = 1.0;

	public:
		double computeMixingRatio(double);
		double computeNumberDensity(double);
		std::complex<double> computeRefractiveIndex(double);
};
*/

struct Geometry //for Fourier-AD
{
	public:
		int M;
		int Ntheta;
		int Nphi;

		double d_phi;

		Eigen::VectorXd weight_uh;
		Eigen::VectorXd weight_lh;
		Eigen::VectorXd theta_uh;
		Eigen::VectorXd theta_lh;
		Eigen::VectorXd theta_all;
		Eigen::VectorXd mu_uh;
		Eigen::VectorXd mu_lh;

		Eigen::VectorXd phi;

		Eigen::MatrixXd WMU_uh;
		Eigen::MatrixXd WMU_lh;
};

class Configuration
{
	private:

	public:
		struct Simulation
		{
			std::optional<std::string> simulation_name;
			std::optional<std::string> directory_name;
			std::optional<std::string> logfile_name;
			std::optional<std::string> result_name;

			std::optional<int> n_parallel;
			std::optional<int> n_scattering_angle;
			std::optional<double> tau_initial_layer; // dimensionless

			std::optional<bool> enable_atmospheric_emission;
		};

		struct GeometryConfiguration
		{
			std::optional<int> n_theta;
			std::optional<int> n_phi;
			std::optional<int> n_mode;
			std::optional<GridType> grid_type;
		};

		struct DeltaM
		{
			std::optional<DeltaApproximationType> delta_approximation_type;
			std::optional<InCellSuperSamplingType> icss_type;
			std::optional<int> n_icss_sample; // (3)
			std::optional<double> fwhm_ratio; // for fwhm (0.5)
			std::optional<double> f_target; // for cumulative (0.01)
		};

		struct SpectralCoordinate
		{
			std::optional<SpectralCoordinateDimension> spectral_coordinate_dimension;
			std::optional<SpectralCoordinateType> spectral_coordinate_type;
			std::optional<std::string> unit;
			std::optional<double> mono; // m or m-1, for monochrome
			std::optional<double> min; // m or m-1, for spectrum, bandpass
			std::optional<double> max; // m or m-1, for spectrum, bandpass
			std::optional<int> n_spectral; // (11)
			std::optional<double> increment; // m or m-1
			std::vector<double> specral_grid;
		};

		struct Instrument
		{
			std::optional<InstrumentFunctionType> instrument_function_type;
			std::optional<double> instrument_function_sigma; // sigma
			std::optional<double> instrument_function_center; // center (for bandpass)
			std::optional<double> instrument_function_width; //  width (rectangle)
			std::optional<int> instrument_sampling_count;
			std::optional<std::string> filename_instrument_function;
			std::optional<std::string> instrument_function_unit;
			std::vector<std::vector<double>> instrument_function;
		};

		struct Surface
		{
			std::optional<SurfaceType> type;
			std::optional<double> albedo; // dimensionless
			std::optional<double> temperature;	//K
			std::optional<std::string> unit;
		};

		struct SpeciesConfiguration
		{
			// basic properties
			std::optional<std::string> name; // name
			std::optional<SpeciesState> species_state; // molecule, aerosol
			std::optional<SpeciesType> species_type; // absorber, scatterer, extinction
			std::optional<ScatterType> scatter_type; // rayleigh, mie, ...

			// vertical profile
			std::optional<VerticalProfileInterpolation> vertical_profile_interpolation; // linear, exponential
			// std::optional<VerticalProfileType> vertical_profile_type; // mixing ratio, number density, column density
			std::vector<std::vector<double>> vertical_profile;	//m, abundance
			std::vector<std::optional<std::string>> unit_vertical_profile;
			bool is_same_layering_atmosphere = false;
			
			// cross sections
			std::optional<CrossSectionType> scattering_cross_section_type; // constant, external
			std::optional<CrossSectionType> absorption_cross_section_type; // constant, external, hitran

			// absorption cross section
			std::optional<std::string> unit_input_absorption_cross_section;
			std::optional<std::string> unit_input_absorption_spectral;
			std::optional<double> absorption_cross_section;	//m^2/molecule
			std::optional<std::string> absorption_cross_section_unit;

			// scattering cross section
			std::optional<std::string> unit_input_scattering_cross_section;
			std::optional<std::string> unit_input_scattering_spectral;
			std::optional<double> scattering_cross_section;	//m^2/molecule
			std::optional<std::string> scattering_cross_section_unit;

			// refractive index for mie scattering
			std::optional<std::string> unit_input_refractive_index_spectral;
			std::optional<RefractiveIndexSpectrumType> refractive_index_spectrum_type; // constant, external
			std::optional<RefractiveIndexVerticalProfile> refractive_index_vertical_profile_type; // constant, table
			std::optional<double> nr;	//real part of refractive index n = nr - i * ni
			std::optional<double> ni;	//imaginary part of refractive index n = nr - i * ni
			// 複素屈折率の高度分布
			std::vector<std::vector<double>> refractive_index_vertical_profile; // m, nr, ni
			bool is_refractive_index_same_layering_atmosphere = false;
			std::optional<VerticalProfileInterpolation> refractive_index_vertical_profile_interpolation;
			std::optional<std::string> unit_refractive_index_vertical_profile;

			// size distribution (Mie)
			std::optional<ParticleSizeDistribution> size_distribution; // delta, log-normal, ...
			std::optional<std::string> unit_input_radius;
			std::optional<int> count_radius; // sampling

			// Hovenier (2004)

			// Delta
			std::optional<double> delta_r; // m

			// Rectangular
			std::optional<double> rect_r_mean; // m
			std::optional<double> rect_width; // m

			// Log-Normal (D.7)
			std::optional<double> lnd_r_g; // m
			std::optional<double> lnd_sigma_g; // dimensionless

			// Gamma (D.5)
			std::optional<double> gd_a; // m
			std::optional<double> gd_b; // dimensionless

			// Modified Gamma (D.6)
			std::optional<double> mgd_r_c; // m
			std::optional<double> mgd_alpha; // dimensionless
			std::optional<double> mgd_gamma; // dimensionless

			// Power Law (D.8)
			std::optional<double> pl_delta;  // dimensionless
			std::optional<double> pl_r1;  // m
			std::optional<double> pl_r2; // m

			// for HG
			std::optional<double> g_factor;	//g-factor for Henyey-Greenstein function

			std::optional<std::string> filename_scattering_cross_section;
			std::optional<std::string> filename_absorption_cross_section;
			std::optional<std::string> filename_refractive_index;

			// for hitran
			std::optional<int> molecule_id;
			std::vector<int> local_isotopologue_id;
			std::optional<IsotopologueType> isotopologue_type;
			std::optional<IsotopologueAbundanceType> isotopologue_abundance_type;
			std::vector<double> abundance;
			std::vector<double> scalar;
			std::optional<bool> is_normalize;

		};

		struct Atmosphere
		{
			// std::optional<hitran::Diluent> diluent; // for HITRAN module
			std::vector<std::string> diluent_species;
			std::vector<double> diluent_ratio;
			std::optional<std::string> filename_hitran;
			
			std::optional<VerticalTemperatureProfile> vertical_temperature_profile;
			std::vector<std::vector<double>> temperature_profile; //m, K
			std::vector<std::optional<std::string>> temperature_unit;
			std::optional<VerticalProfileInterpolation> vertical_temperature_interpolation;
			bool is_same_temperature_layering_atmosphere = false;

			std::optional<VerticalPressureProfile> vertical_pressure_profile;
			std::vector<std::vector<double>> pressure_profile; //m, Pa
			std::vector<std::optional<std::string>> pressure_unit;
			std::optional<VerticalProfileInterpolation> vertical_pressure_interpolation;
			bool is_same_pressure_layering_atmosphere = false;

			std::optional<VerticalNumberDensityProfile> vertical_number_density_profile;
			std::vector<std::vector<double>> number_density_profile; //m, m-3
			std::vector<std::optional<std::string>> number_density_unit;
			std::optional<VerticalProfileInterpolation> vertical_number_density_interpolation;
			bool is_same_number_density_layering_atmosphere = false;
			std::optional<UnitDim> unit_dim_number_density;

			std::vector<double> z_center;
			std::vector<double> z_edge;
			std::optional<std::string> z_unit;

			std::vector<SpeciesConfiguration> species_configuration;
		};

		Simulation simulation;
		GeometryConfiguration geometry;
		DeltaM delta_m;
		SpectralCoordinate spectral_coordinate;
		Instrument instrument;
		Surface surface;
		Atmosphere atmosphere;

		// ?
		std::optional<double> wavenumber_min_result; // m-1
		std::optional<double> wavenumber_max_result; // m-1

		// bool is_wavenumber;

		void validateConfiguration(void);
};

class ConfigurationLoader
{
	public:
		static Configuration load(const std::string&);

	private:
		static std::map<std::string, std::string> importYaml_(const std::string&);

		static Configuration::Simulation loadSimulation_(const std::map<std::string, std::string>&);
		static Configuration::Surface loadSurface_(const std::map<std::string, std::string>&);
		static Configuration::Atmosphere loadAtmosphere_(const std::map<std::string, std::string>&);
		static Configuration::GeometryConfiguration loadGeometry_(const std::map<std::string, std::string>&);
		static Configuration::DeltaM loadDeltaM_(const std::map<std::string, std::string>&);
		static Configuration::Instrument loadInstrument_(const std::map<std::string, std::string>&);
		static Configuration::SpectralCoordinate loadSpectralCoordinate_(const std::map<std::string, std::string>&);

		static std::string getRequiredString_(const std::map<std::string, std::string>&, const std::string&);
		static int getRequiredInt_(const std::map<std::string, std::string>&, const std::string&);
		static double getRequiredDouble_(const std::map<std::string, std::string>&, const std::string&);
		static bool getRequiredBool_(const std::map<std::string, std::string>&, const std::string&);

		static std::string getOptionalString_(const std::map<std::string, std::string>&, const std::string&, const std::string&);
		static int getOptionalInt_(const std::map<std::string, std::string>&, const std::string&, int);
		static double getOptionalDouble_(const std::map<std::string, std::string>&, const std::string&, double);
		static bool getOptionalBool_(const std::map<std::string, std::string>&, const std::string&, bool);

		static std::optional<std::string> getOptionalString_(const std::map<std::string, std::string>&, const std::string&);
		static std::optional<int> getOptionalInt_(const std::map<std::string, std::string>&, const std::string&);
		static std::optional<double> getOptionalDouble_(const std::map<std::string, std::string>&, const std::string&);
		static std::optional<bool> getOptionalBool_(const std::map<std::string, std::string>&, const std::string&);

		static bool hasKey_(const std::map<std::string, std::string>&, const std::string&);
		static int countArrayEntries_(const std::map<std::string, std::string>&, const std::string&);

		template<typename EnumT> static std::optional<EnumT> parseEnum_(const std::optional<std::string>&, const std::map<std::string, EnumT>&);
};

class MonochromeData
{
	public:
		std::vector<std::vector<std::vector<double>>> reflectance_top; // e, i, p?

		std::vector<Eigen::MatrixXd> reflectance_m_top_cos; // m, e, i
		std::vector<Eigen::MatrixXd> reflectance_m_top_sin; // m, e, i

		Eigen::VectorXd source_up; // e

		std::vector<double> absorption_coefficient; // altitude
		std::vector<double> scattering_coefficient; // altitude
		std::vector<double> single_scattering_albedo; // altitude
		std::vector<double> optical_thickness; // altitude
		std::vector<double> asymmetry_parameter; // altitude
};

class RadiativeTransferResult
{
	public:
		int Ntheta;
		int Nphi;
		int Nmode;

		std::vector<double> theta_e, theta_i, phi;

		std::vector<double> altitude; // altitude
		std::vector<double> altitude_top; // altitude
		std::vector<double> altitude_bottom; // altitude
		std::vector<double> physical_thickness; // altitude

		std::vector<double> temperature; // altitude
		std::vector<double> pressure; // altitude
		std::vector<double> number_density; // altitude

		std::vector<MonochromeData> spectral_data;

		void exportResultNetCDF(std::string);
};

class RadiativeTransferCalculator
{
	private:
		Geometry geometry_;

		// void initializeLayer_(Layer&);
		// void initializeSurface_(Layer&);
		// void setLayerCondition_(AtmosphereModel&, double);
		// std::vector<std::vector<Eigen::MatrixXd>> computeFourierSeriesCoefficients_(const std::vector<std::vector<std::vector<double>>>&, int);
		// std::vector<std::vector<std::vector<double>>> reconstruct_(const std::vector<std::vector<std::vector<std::vector<double>>>>&);
		// void computeFourierSeriesCoefficients_(Layer&);
		// void reconstructOpticalProperties_(Layer&);
		// void initializeGeometry_(void);
		// void computeAtmosphericProperties_(AtmosphereModel&);
		// void computeSpeciesProperties_(AtmosphereModel&);
		// void validateAtmosphererModel_(const AtmosphereModel&);

	public:
		RadiativeTransferCalculator(const Geometry&);
		RadiativeTransferResult computeMonochrome(const AtmosphereModel&, double, SpectralCoordinateDimension);
};

class ModelBuilder
{
	public:
		static AtmosphereModel buildAtmosphereModel(const Configuration&);
		static Geometry buildGeometry(const Configuration&);

	private:
		static std::vector<Species> buildSpecies_(const Configuration&, const AtmosphereModel&);
		static double interpolateVerticalProfile(double, const std::vector<std::vector<double>>&, VerticalProfileInterpolation);
};

class SpectralCalculator
{
	private:
		Configuration configuration_;
		AtmosphereModel atmosphere_model_;
		RadiativeTransferCalculator radiative_transfer_;

		RadiativeTransferResult convolve_(const RadiativeTransferResult& radiative_transfer_result);
		
	public:
		SpectralCalculator(const Configuration&, const AtmosphereModel&, const RadiativeTransferCalculator&);
		RadiativeTransferResult calculate(void);
};

/*
class RadiativeTransfer
{
	private:
		void initializeLayer(Layer&);
		void initializeSurface(Layer&);
		// void setLayerCondition(void);
		
		void setLayerCondition(AtmosphereModel&, double);

		std::vector<std::vector<Eigen::MatrixXd>> computeFourierSeriesCoefficients(const std::vector<std::vector<std::vector<double>>>&, int);
		std::vector<std::vector<std::vector<double>>> reconstruct(const std::vector<std::vector<std::vector<std::vector<double>>>>&);
		void computeFourierSeriesCoefficients(Layer&);
		void reconstructOpticalProperties(Layer&);

		double computePhaseFunction(const std::vector<std::vector<double>>&, double);

	public:
		// std::vector<double> wavelength;
		// std::vector<std::vector<double>> window_function;

		class Result
		{
			public:
				int Ntheta;
				int Nphi;
				int Nmode;

				std::vector<double> theta_e, theta_i, phi;

				std::vector<std::vector<std::vector<std::vector<double>>>> reflectance_top;

				std::vector<std::vector<Eigen::MatrixXd>> reflectance_m_top_cos;
				std::vector<std::vector<Eigen::MatrixXd>> reflectance_m_top_sin;

				std::vector<Eigen::VectorXd> source_up;

				std::vector<double> wavelength;
				std::vector<double> wavenumber;

				std::vector<double> altitude; // altitude
				std::vector<double> altitude_top; // altitude
				std::vector<double> altitude_bottom; // altitude
				std::vector<double> physical_thickness; // altitude

				std::vector<double> temperature; // altitude
				std::vector<double> pressure; // altitude
				std::vector<double> number_density; // altitude

				std::vector<std::vector<double>> absorption_coefficient; // wavelength, altitude
				std::vector<std::vector<double>> scattering_coefficient; // wavelength, altitude
				std::vector<std::vector<double>> single_scattering_albedo; // wavelength, altitude
				std::vector<std::vector<double>> optical_thickness; // wavelength, altitude
				std::vector<std::vector<double>> asymmetry_parameter; // wavelength, altitude
		};

		int Ntheta;
		int Nphi;
		int M;

		// AtmosphereModel atmosphere_model;
		Geometry geometry;
		
		Result result;

		Configuration configuration;
		std::string config_filename = "config.yaml";

		void importConfiguration(void);
		void initializeGeometry(void);
		void computeAtmosphericProperties(AtmosphereModel&);
		void computeSpeciesProperties(AtmosphereModel&);

		void validateAtmosphererModel(const AtmosphereModel&);

		// void runSpectrum(void);
		void runSpectrum(AtmosphereModel);
		void runMonochrome(AtmosphereModel&, double);
		// void runBandpass(void);
		void runBandpass(AtmosphereModel);
		void run(void);

		void exportResultNetCDF(std::string);
		void exportResultNetCDF(void);
};
*/

class JacobianResult
{
	public:
		int Ntheta, Nphi, Nmode;
		std::vector<double> altitude;

		std::vector<double> emission_zenith_angle;
		std::vector<double> incidence_zenith_angle;
		std::vector<double> emission_azimuth_angle;
		
		std::vector<Eigen::VectorXd> weighting_function_source_up;
		std::vector<Eigen::VectorXd> contribution_function_source_up;

		std::vector<std::vector<std::vector<std::vector<double>>>> weighting_function_reflectance_top;
		std::vector<std::vector<std::vector<std::vector<double>>>> contribution_function_reflectance_top;

		std::vector<std::vector<Eigen::MatrixXd>> weighting_function_reflectance_m_top_cos;
		std::vector<std::vector<Eigen::MatrixXd>> weighting_function_reflectance_m_top_sin;
		std::vector<std::vector<Eigen::MatrixXd>> contribution_function_reflectance_m_top_cos;
		std::vector<std::vector<Eigen::MatrixXd>> contribution_function_reflectance_m_top_sin;

		void initialize(int nlayer)
		{
			altitude.resize(nlayer);
			// emission_zenith_angle.resize(nlayer);

			weighting_function_source_up.resize(nlayer);
			contribution_function_source_up.resize(nlayer);

			weighting_function_reflectance_top.resize(nlayer);
			contribution_function_reflectance_top.resize(nlayer);

			weighting_function_reflectance_m_top_cos.resize(nlayer);
			contribution_function_reflectance_m_top_cos.resize(nlayer);

			weighting_function_reflectance_m_top_sin.resize(nlayer);
			contribution_function_reflectance_m_top_sin.resize(nlayer);

			return;
		}
};

}