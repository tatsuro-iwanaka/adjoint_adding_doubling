#pragma once

#include <map>
#include <vector>
#include <string>
#include <fstream>
#include <Eigen/Dense>
#include <optional>

#include "constants"
#include "hitran"

namespace radiative_transfer
{
enum class UnitDim{Length, Area, Mass, Temperature, Pressure, NumberDensity, ColumnNumberDensity, Wavenumber, Dimensionless};

enum class SpectralCoordinateDimension{Wavenumber, Wavelength, Frequency};
const inline std::map<std::string, SpectralCoordinateDimension> map_spectral_coordinate_dimension =
{
	{"WAVENUMBER",  SpectralCoordinateDimension::Wavenumber},
	{"WAVELENGTH", SpectralCoordinateDimension::Wavelength},
	{"FREQUENCY",  SpectralCoordinateDimension::Frequency}
};

enum class SpectralCoordinateType{Monochrome, Spectrum, Bandpass};
const inline std::map<std::string, SpectralCoordinateType> map_spectral_coordinate_type =
{
	{"MONOCHROME",  SpectralCoordinateType::Monochrome},
	{"SPECTRUM",  SpectralCoordinateType::Spectrum},
	{"BANDPASS", SpectralCoordinateType::Bandpass}
};

enum class VerticalProfileInterpolation{Exponential, Linear};
const inline std::map<std::string, VerticalProfileInterpolation> map_vertical_profile_interpolation =
{
	{"EXPONENTIAL",  VerticalProfileInterpolation::Exponential},
	{"LINEAR", VerticalProfileInterpolation::Linear}
};

enum class ScatterType{Rayleigh, Mie, HenyeyGreenstein, Isotropic};
const inline std::map<std::string, ScatterType> map_scatter_type =
{
	{"RAYLEIGH",  ScatterType::Rayleigh},
	{"MIE", ScatterType::Mie},
	{"HENYEY_GREENSTEIN",  ScatterType::HenyeyGreenstein},
	{"HENYEYGREENSTEIN", ScatterType::HenyeyGreenstein},
	{"HG",  ScatterType::HenyeyGreenstein},
	{"ISOTROPIC", ScatterType::Isotropic}
};

enum class SpeciesState{Molecule, Aerosol};
const inline std::map<std::string, SpeciesState> map_species_state =
{
	{"MOLECULE",  SpeciesState::Molecule},
	{"AEROSOL", SpeciesState::Aerosol}
};

enum class SpeciesType{Absorber, Scatterer, Extinction};
const inline std::map<std::string, SpeciesType> map_species_type =
{
	{"ABSORBER",  SpeciesType::Absorber},
	{"SCATTERER", SpeciesType::Scatterer},
	{"EXTINCTION", SpeciesType::Extinction},
	{"BOTH", SpeciesType::Extinction}
};

enum class ParticleSizeDistribution{Delta, Rectangular, LogNormal, Gamma, ModifiedGamma, PowerLaw};
const inline std::map<std::string, ParticleSizeDistribution> map_particle_size_distribution =
{
	{"DELTA", ParticleSizeDistribution::Delta},
	{"RECTANGULAR", ParticleSizeDistribution::Rectangular},
	{"LOG_NORMAL", ParticleSizeDistribution::LogNormal},
	{"LOGNORMAL", ParticleSizeDistribution::LogNormal},
	{"GAMMA", ParticleSizeDistribution::Gamma},
	{"MODIFIED_GAMMA", ParticleSizeDistribution::ModifiedGamma},
	{"MODIFIEDGAMMA", ParticleSizeDistribution::ModifiedGamma},
	{"POWER_LAW", ParticleSizeDistribution::PowerLaw}
};

enum class VerticalProfileType{MixingRatio, NumberDensity, ColumnNumberDensity};
const inline std::map<std::string, VerticalProfileType> map_vertical_profile_type =
{
	{"MIXING_RATIO",  VerticalProfileType::MixingRatio},
	{"NUMBER_DENSITY", VerticalProfileType::NumberDensity},
	{"NUMBERDENSITY", VerticalProfileType::NumberDensity},
	{"COLUMN_NUMBER_DENSITY", VerticalProfileType::ColumnNumberDensity},
	{"COLUMNNUMBERDENSITY", VerticalProfileType::ColumnNumberDensity}
};

enum class CrossSectionType{External, Constant, HITRAN};
const inline std::map<std::string, CrossSectionType> map_cross_section_type =
{
	{"EXTERNAL",  CrossSectionType::External},
	{"CONSTANT", CrossSectionType::Constant},
	{"HITRAN", CrossSectionType::HITRAN}
};

enum class RefractiveIndexType{Constant, Spectral, Vertical, SpectralVertical};
const inline std::map<std::string, RefractiveIndexType> map_refractive_index_type =
{
	{"CONSTANT", RefractiveIndexType::Constant},
	{"SPECTRAL", RefractiveIndexType::Spectral},
	{"VERTICAL", RefractiveIndexType::Vertical},
	{"SPECTRALVERTICAL", RefractiveIndexType::SpectralVertical},
	{"SPECTRAL_VERTICAL", RefractiveIndexType::SpectralVertical},
	{"VERTICALSPECTRAL", RefractiveIndexType::SpectralVertical},
	{"VERTICAL_SPECTRAL", RefractiveIndexType::SpectralVertical},
	{"BOTH", RefractiveIndexType::SpectralVertical},
	{"COUPLED", RefractiveIndexType::SpectralVertical},
	{"COUPLED2D", RefractiveIndexType::SpectralVertical},
	{"COUPLED_2D", RefractiveIndexType::SpectralVertical},
	{"2D", RefractiveIndexType::SpectralVertical}
};

// enum class RefractiveIndexSpectrumType{Constant, External};
// const inline std::map<std::string, RefractiveIndexSpectrumType> map_refractive_index_spectrum_type =
// {
// 	{"CONSTANT",  RefractiveIndexSpectrumType::Constant},
// 	{"EXTERNAL", RefractiveIndexSpectrumType::External}
// };

// enum class RefractiveIndexVerticalProfile{Constant, Table};
// const inline std::map<std::string, RefractiveIndexVerticalProfile> map_refractive_index_vertical_profile_type =
// {
// 	{"CONSTANT", RefractiveIndexVerticalProfile::Constant},
// 	{"TABLE", RefractiveIndexVerticalProfile::Table}
// };

enum class InCellSuperSamplingType{Enable, Disable};
const inline std::map<std::string, InCellSuperSamplingType> map_in_cell_super_sampling_type =
{
	{"ENABLE",  InCellSuperSamplingType::Enable},
	{"DISABLE", InCellSuperSamplingType::Disable}
};

enum class DeltaApproximationType{Disable, d_m1, d_m2, FWHM, Cumulative};
const inline std::map<std::string, DeltaApproximationType> map_delta_approximation_type =
{
	{"NONE",  DeltaApproximationType::Disable},
	{"DISABLE", DeltaApproximationType::Disable},
	{"D_M1", DeltaApproximationType::d_m1},
	{"DM1", DeltaApproximationType::d_m1},
	{"DELTA_M_1", DeltaApproximationType::d_m1},
	{"DELTA_M1", DeltaApproximationType::d_m1},
	{"D_M2", DeltaApproximationType::d_m2},
	{"DM2", DeltaApproximationType::d_m2},
	{"DELTA_M_2", DeltaApproximationType::d_m2},
	{"DELTA_M2", DeltaApproximationType::d_m2},
	{"FWHM", DeltaApproximationType::FWHM},
	{"CUMULATIVE", DeltaApproximationType::Cumulative}
};

enum class VerticalTemperatureProfile{VIRA_EQUATOR, VIRA_45, VIRA_60, Table, External};
const inline std::map<std::string, VerticalTemperatureProfile> map_vertical_temperature_profile =
{
	{"VIRA_EQUATOR",  VerticalTemperatureProfile::VIRA_EQUATOR},
	{"VIRA_45", VerticalTemperatureProfile::VIRA_45},
	{"VIRA_60", VerticalTemperatureProfile::VIRA_60},
	{"TABLE", VerticalTemperatureProfile::Table},
	{"EXTERNAL", VerticalTemperatureProfile::External}
};

enum class VerticalPressureProfile{VIRA_EQUATOR, VIRA_45, VIRA_60, Table, Hydrostatic, External};
const inline std::map<std::string, VerticalPressureProfile> map_vertical_pressure_profile =
{
	{"VIRA_EQUATOR",  VerticalPressureProfile::VIRA_EQUATOR},
	{"VIRA_45", VerticalPressureProfile::VIRA_45},
	{"VIRA_60", VerticalPressureProfile::VIRA_60},
	{"TABLE", VerticalPressureProfile::Table},
	{"HYDROSTATIC", VerticalPressureProfile::Hydrostatic},
	{"EXTERNAL", VerticalPressureProfile::External}
};

enum class VerticalNumberDensityProfile{VIRA_EQUATOR, VIRA_45, VIRA_60, Table, External, IdealGas};
const inline std::map<std::string, VerticalNumberDensityProfile> map_vertical_number_density_profile =
{
	{"VIRA_EQUATOR",  VerticalNumberDensityProfile::VIRA_EQUATOR},
	{"VIRA_45", VerticalNumberDensityProfile::VIRA_45},
	{"VIRA_60", VerticalNumberDensityProfile::VIRA_60},
	{"TABLE", VerticalNumberDensityProfile::Table},
	{"EXTERNAL", VerticalNumberDensityProfile::External},
	{"IDEALGAS", VerticalNumberDensityProfile::IdealGas},
	{"IDEAL_GAS", VerticalNumberDensityProfile::IdealGas},
	{"IDEALGASLAW", VerticalNumberDensityProfile::IdealGas},
	{"IDEAL_GAS_LAW", VerticalNumberDensityProfile::IdealGas}
};

enum class SurfaceType{NoSurface, Lambert};
const inline std::map<std::string, SurfaceType> map_surface_type =
{
	{"NO_SURFACE",  SurfaceType::NoSurface},
	{"NOSURFACE", SurfaceType::NoSurface},
	{"NONE", SurfaceType::NoSurface},
	{"LAMBERT", SurfaceType::Lambert},
	{"LAMBERTIAN", SurfaceType::Lambert}
};


enum class WindowFunctionType{Gauss, Rectangle, External, Table};
const inline std::map<std::string, WindowFunctionType> map_window_function_type =
{
	{"GAUSS",  WindowFunctionType::Gauss},
	{"GAUSSIAN",  WindowFunctionType::Gauss},
	{"RECTANGLE", WindowFunctionType::Rectangle},
	{"RECTANGULAR", WindowFunctionType::Rectangle},
	{"TABLE", WindowFunctionType::Table},
	{"EXTERNAL", WindowFunctionType::External}
};

enum class GridType{Regular, GaussRadau};
const inline std::map<std::string, GridType> map_grid_type =
{
	{"GAUSSRADAU",  GridType::GaussRadau},
	{"GAUSS_RADAU",  GridType::GaussRadau},
	{"REGULAR", GridType::Regular}
};

enum class InstrumentFunctionType{Delta, Gauss, Rectangle, External};
const inline std::map<std::string, InstrumentFunctionType> map_instrument_function_type =
{
	{"NONE",  InstrumentFunctionType::Delta},
	{"DELTA",  InstrumentFunctionType::Delta},
	{"GAUSS",  InstrumentFunctionType::Gauss},
	{"GAUSSIAN",  InstrumentFunctionType::Gauss},
	{"RECTANGLE", InstrumentFunctionType::Rectangle},
	{"RECTANGULAR", InstrumentFunctionType::Rectangle},
	{"EXTERNAL", InstrumentFunctionType::External}
};

enum class IsotopologueType{All, Defined};
const inline std::map<std::string, IsotopologueType> map_isotopologue_type =
{
	{"ALL",  IsotopologueType::All},
	{"HITRAN",  IsotopologueType::All},
	{"DEFINED", IsotopologueType::Defined},
	{"TABLE", IsotopologueType::Defined}
};

enum class IsotopologueAbundanceType{HITRAN, Defined};
const inline std::map<std::string, IsotopologueAbundanceType> map_isotopologue_abundance_type =
{
	{"HITRAN",  IsotopologueAbundanceType::HITRAN},
	{"DEFINED", IsotopologueAbundanceType::Defined},
	{"TABLE", IsotopologueAbundanceType::Defined}
};

enum class JacobianType{Temperature, TotalNumberDensity, SpeciesNumberDensity, SpeciesMixingRatio};

class UnitInfo
{	
	public:
		UnitDim dim;
		double to_si;  // この単位 → SI 基本単位への乗数
};

struct Species
{
	// ヤコビアン計算に必要な最低限を残す
	// 微小変化させるのはこのSpecies
	// これを微小変化させた後に放射計算の準備
	// これを使ってMie計算を行う
	// Mie計算に必要なのは複素屈折率，粒径分布
	// 数密度（混合比）の鉛直分布
	// 複素屈折率の鉛直分布
	// 吸収断面積，散乱断面積
	public:
		std::string name;
		SpeciesState species_state;
		SpeciesType species_type;
		ScatterType scatter_type;

		std::vector<std::vector<double>> particle_size_distribution; // spectral, size_distribution
		std::vector<std::vector<double>> weight_particle_size_distribution; // spectral, weights

		double g_factor;	//g-factor for Henyey-Greenstein function

		// double absorption_cross_section;	//m^2/molecule
		// double scattering_cross_section;	//m^2/molecule

		std::vector<std::vector<double>> absorption_cross_section_spectrum; // spectral, m^2/molecule
		std::vector<std::vector<double>> scattering_cross_section_spectrum; // spectral, m^2/molecule
		std::vector<std::vector<std::vector<double>>> refractive_index; // altitude, spectral, nr, ni

		std::vector<double> vertical_number_density_profile;	// m-3
		std::vector<double> vertical_mixing_ratio_profile;	// mol/mol
		// std::vector<std::vector<double>> refractive_index_vertical_profile; // nr, ni

		bool is_hitran;
		hitran::Isotopologue isotopologue;
		std::vector<hitran::Line> lines;
};

struct OpticalLayer
{
	public:
		double planck_function; // IR計算用 プランク関数
		double absorption_coefficient; //m-1
		double scattering_coefficient; //m-1
		double optical_thickness; //dimensionless
		double single_scattering_albedo; //ks/(ks + ka)

		bool enable_atmospheric_emission;

		// for surface
		double surface_albedo;

		double asymmetry_parameter;

		std::vector<std::vector<double>> scattering_phase_function;	//angle (radian), magnitude (dimensionless)
};

struct RadiativeLayer
{
	public:
		std::vector<Eigen::MatrixXd> reflectance_m_top_cos;
		std::vector<Eigen::MatrixXd> reflectance_m_bottom_cos;
		std::vector<Eigen::MatrixXd> transmittance_m_top_cos;
		std::vector<Eigen::MatrixXd> transmittance_m_bottom_cos;

		std::vector<Eigen::MatrixXd> reflectance_m_top_sin;
		std::vector<Eigen::MatrixXd> reflectance_m_bottom_sin;
		std::vector<Eigen::MatrixXd> transmittance_m_top_sin;
		std::vector<Eigen::MatrixXd> transmittance_m_bottom_sin;

		Eigen::MatrixXd source_up;
		Eigen::MatrixXd source_down;

		int n_doubling;

		bool enable_atmospheric_emission;

		// std::vector<std::vector<std::vector<double>>> reflectance_top;
		// std::vector<std::vector<std::vector<double>>> reflectance_bottom;
		// std::vector<std::vector<std::vector<double>>> transmittance_top;
		// std::vector<std::vector<std::vector<double>>> transmittance_bottom;

		double optical_thickness; //dimensionless
};

struct AtmosphereModel
{
	public:
		std::vector<Species> species;
		SurfaceType surface_type;
		double surface_temperature;
		double surface_albedo;
		bool enable_atmospheric_emission;
		std::vector<double> altitude_bottom;
		std::vector<double> altitude_top;
		std::vector<double> altitude;
		std::vector<double> temperature;
		std::vector<double> pressure;
		std::vector<double> number_density;
		hitran::Diluent diluent;
		// bool enable_atmospheric_emission = false;
};

struct Geometry //for Fourier-AD
{
	public:
		int M;
		int Ntheta;
		int Nphi;

		double d_phi;

		Eigen::VectorXd weight_uh;
		Eigen::VectorXd weight_lh;
		Eigen::VectorXd theta_uh;
		Eigen::VectorXd theta_lh;
		Eigen::VectorXd theta_all;
		Eigen::VectorXd mu_uh;
		Eigen::VectorXd mu_lh;

		Eigen::VectorXd phi;

		Eigen::MatrixXd WMU_uh;
		Eigen::MatrixXd WMU_lh;
};

class Configuration
{
	private:

	public:
		struct Simulation
		{
			std::optional<std::string> simulation_name;
			std::optional<std::string> directory_name;
			std::optional<std::string> logfile_name;
			std::optional<std::string> result_name;

			std::optional<int> n_parallel;
			std::optional<int> n_scattering_angle;
			std::optional<double> tau_initial_layer; // dimensionless

			std::optional<bool> enable_atmospheric_emission;
		};

		struct GeometryConfiguration
		{
			std::optional<int> n_theta;
			std::optional<int> n_phi;
			std::optional<int> n_mode;
			std::optional<GridType> grid_type;
		};

		struct DeltaM
		{
			std::optional<DeltaApproximationType> delta_approximation_type;
			std::optional<InCellSuperSamplingType> icss_type;
			std::optional<int> n_icss_sample; // (3)
			std::optional<double> fwhm_ratio; // for fwhm (0.5)
			std::optional<double> f_target; // for cumulative (0.01)
		};

		struct SpectralCoordinate
		{
			std::optional<SpectralCoordinateDimension> spectral_coordinate_dimension;
			std::optional<SpectralCoordinateType> spectral_coordinate_type;
			std::optional<std::string> unit;
			std::optional<double> mono; // m or m-1, for monochrome
			std::optional<double> min; // m or m-1, for spectrum
			std::optional<double> max; // m or m-1, for spectrum
			std::optional<int> n_spectral; // (11)
			std::optional<double> increment; // m or m-1
			// std::vector<double> spectral_grid;
		};

		struct Instrument
		{
			// slit function for spectrum calculation
			// カーネルを指定する場合はmin/maxだけ．over_sampling_countからサンプリングは自動で決定
			std::optional<InstrumentFunctionType> convolution_kernel_type;
			std::optional<double> kernel_width; // for rectangular
			std::optional<double> kernel_sigma; // for gaussian
			std::optional<double> kernel_cut_off_sigma; // for gaussian
			std::optional<int> over_sampling_count;

			// banspass filter for bandpass calculation
			std::optional<InstrumentFunctionType> filter_function_type;
			std::optional<double> filter_sigma; // for gaussian
			std::optional<double> filter_center; // for delta/gaussian/rectangular
			std::optional<double> filter_width; // for rectangular
			std::optional<double> filter_cut_off_sigma; // for gaussian
			std::optional<int> sampling_count;
			std::optional<std::string> filename_filter_function;
			std::optional<std::string> varname_spectral;
			std::optional<std::string> varname_transmittance;

			// std::optional<InstrumentFunctionType> instrument_function_type;
			// std::optional<double> instrument_function_sigma; // sigma
			// std::optional<double> instrument_function_center; // center (for bandpass)
			// std::optional<double> instrument_function_width; //  width (rectangle)
			// std::optional<int> instrument_sampling_count;
			// std::optional<std::string> filename_instrument_function;
			// std::optional<std::string> instrument_function_unit;
			// std::vector<std::vector<double>> instrument_function;

			// banspass filter for bandpass calculation
		};

		struct Surface
		{
			std::optional<SurfaceType> type;
			std::optional<double> albedo; // dimensionless
			std::optional<double> temperature;	//K
			std::optional<std::string> unit;
		};

		struct SpeciesConfiguration
		{
			// basic properties
			std::optional<std::string> name; // name
			std::optional<SpeciesState> species_state; // molecule, aerosol
			std::optional<SpeciesType> species_type; // absorber, scatterer, extinction
			std::optional<ScatterType> scatter_type; // rayleigh, mie, ...

			// vertical profile
			std::optional<VerticalProfileInterpolation> vertical_profile_interpolation; // linear, exponential
			// std::optional<VerticalProfileType> vertical_profile_type; // mixing ratio, number density, column density
			std::vector<std::vector<double>> vertical_profile;	//m, abundance
			std::vector<std::optional<std::string>> unit_vertical_profile;
			bool is_same_layering_atmosphere = false;
			
			// cross sections
			std::optional<CrossSectionType> scattering_cross_section_type; // constant, external
			std::optional<CrossSectionType> absorption_cross_section_type; // constant, external, hitran

			// absorption cross section
			std::optional<std::string> filename_absorption_cross_section;
			std::optional<std::string> varname_absorption_cross_section_spectral;
			std::optional<std::string> varname_absorption_cross_section;
			// std::optional<std::string> unit_input_absorption_cross_section;
			// std::optional<std::string> unit_input_absorption_spectral;
			std::optional<double> absorption_cross_section;	//m^2/molecule
			std::optional<std::string> absorption_cross_section_unit;

			// scattering cross section
			std::optional<std::string> filename_scattering_cross_section;
			std::optional<std::string> varname_scattering_cross_section_spectral;
			std::optional<std::string> varname_scattering_cross_section;
			// std::optional<std::string> unit_input_scattering_cross_section;
			// std::optional<std::string> unit_input_scattering_spectral;
			std::optional<double> scattering_cross_section;	//m^2/molecule
			std::optional<std::string> scattering_cross_section_unit;


			// refractive index for mie scattering
			std::optional<RefractiveIndexType> refractive_index_type; // constant, spectral, vertical, 2d
			// constant用
			std::optional<double> nr;	//real part of refractive index n = nr - i * ni
			std::optional<double> ni;	//imaginary part of refractive index n = nr - i * ni

			// spectral用
			// std::optional<std::string> unit_input_refractive_index_spectral;
			std::optional<std::string> filename_refractive_index_spectral;
			std::optional<std::string> varname_refractive_index_spectral_spectral;
			std::optional<std::string> varname_refractive_index_spectral_nr;
			std::optional<std::string> varname_refractive_index_spectral_ni;

			// vertical用
			bool is_refractive_index_same_layering_atmosphere = false;
			std::optional<VerticalProfileInterpolation> refractive_index_vertical_profile_interpolation;

			std::vector<std::vector<double>> refractive_index_vertical_profile; // altitude, spectral, nr, ni
			std::optional<std::string> unit_refractive_index_vertical_profile;

			// spectral_vertical用
			std::optional<std::string> filename_refractive_index_spectral_vertical;
			std::optional<std::string> varname_refractive_index_spectral_vertical_altitude;
			std::optional<std::string> varname_refractive_index_spectral_vertical_spectral;
			std::optional<std::string> varname_refractive_index_spectral_vertical_nr;
			std::optional<std::string> varname_refractive_index_spectral_vertical_ni;
			// std::vector<std::optional<std::string>> unit_refractive_index_spectral_vertical; // altitude, spectral


			// 粒径分布関数 (Mie)
			std::optional<ParticleSizeDistribution> size_distribution; // delta, log-normal, ...
			std::optional<std::string> unit_input_radius;
			std::optional<int> count_radius; // sampling

			// Hovenier (2004)
			// Delta
			std::optional<double> delta_r; // m

			// Rectangular
			std::optional<double> rect_r_mean; // m
			std::optional<double> rect_width; // m

			// Log-Normal (D.7)
			std::optional<double> lnd_r_g; // m
			std::optional<double> lnd_sigma_g; // dimensionless

			// Gamma (D.5)
			std::optional<double> gd_a; // m
			std::optional<double> gd_b; // dimensionless

			// Modified Gamma (D.6)
			std::optional<double> mgd_r_c; // m
			std::optional<double> mgd_alpha; // dimensionless
			std::optional<double> mgd_gamma; // dimensionless

			// Power Law (D.8)
			std::optional<double> pl_delta;  // dimensionless
			std::optional<double> pl_r1;  // m
			std::optional<double> pl_r2; // m

			// for HG
			std::optional<double> g_factor;	//g-factor for Henyey-Greenstein function

			// for hitran
			std::optional<int> molecule_id;
			std::vector<int> local_isotopologue_id;
			std::optional<IsotopologueType> isotopologue_type;
			std::optional<IsotopologueAbundanceType> isotopologue_abundance_type;
			std::vector<double> abundance;
			std::vector<double> scalar;
			std::optional<bool> is_normalize;

		};

		struct Atmosphere
		{
			// std::optional<hitran::Diluent> diluent; // for HITRAN module
			std::vector<std::string> diluent_species;
			std::vector<double> diluent_ratio;
			std::optional<std::string> filename_hitran;
			
			std::optional<VerticalTemperatureProfile> vertical_temperature_profile;
			std::vector<std::vector<double>> temperature_profile; //m, K
			std::vector<std::optional<std::string>> temperature_unit;
			std::optional<VerticalProfileInterpolation> vertical_temperature_interpolation;
			bool is_same_temperature_layering_atmosphere = false;

			std::optional<VerticalPressureProfile> vertical_pressure_profile;
			std::vector<std::vector<double>> pressure_profile; //m, Pa
			std::vector<std::optional<std::string>> pressure_unit;
			std::optional<VerticalProfileInterpolation> vertical_pressure_interpolation;
			bool is_same_pressure_layering_atmosphere = false;

			std::optional<VerticalNumberDensityProfile> vertical_number_density_profile;
			std::vector<std::vector<double>> number_density_profile; //m, m-3
			std::vector<std::optional<std::string>> number_density_unit;
			std::optional<VerticalProfileInterpolation> vertical_number_density_interpolation;
			bool is_same_number_density_layering_atmosphere = false;
			std::optional<UnitDim> unit_dim_number_density;

			std::vector<double> z_center;
			std::vector<double> z_edge;
			std::optional<std::string> z_unit;

			std::vector<SpeciesConfiguration> species_configuration;
		};

		Simulation simulation;
		GeometryConfiguration geometry;
		DeltaM delta_m;
		SpectralCoordinate spectral_coordinate;
		Instrument instrument;
		Surface surface;
		Atmosphere atmosphere;

		// bool is_wavenumber;

		void validateConfiguration(void);
};

struct SpectralInformation
{
	public:
		std::vector<double> spectral_grid; // m or m-1
		SpectralCoordinateDimension spectral_dimension; // wavelength or wavenumber
		SpectralCoordinateType spectral_coordinate_type;
		std::vector<double> convolution_kernel; // size = over_sampling_count;
		std::vector<double> filter_function; // size = spectral_grid.size()
		std::vector<double> filter_weight;

		// instrumentの情報のことも格納
};

struct DeltaApproximation
{
	public:
		DeltaApproximationType delta_approximation_type;
		InCellSuperSamplingType icss_type;
		int n_icss_sample;
		double fwhm_ratio;
		double f_target;
};

class ConfigurationLoader
{
	public:
		static Configuration load(const std::string&);

	private:
		static std::map<std::string, std::string> importYaml_(const std::string&);

		static Configuration::Simulation loadSimulation_(const std::map<std::string, std::string>&);
		static Configuration::Surface loadSurface_(const std::map<std::string, std::string>&);
		static Configuration::Atmosphere loadAtmosphere_(const std::map<std::string, std::string>&);
		static Configuration::GeometryConfiguration loadGeometry_(const std::map<std::string, std::string>&);
		static Configuration::DeltaM loadDeltaM_(const std::map<std::string, std::string>&);
		static Configuration::Instrument loadInstrument_(const std::map<std::string, std::string>&);
		static Configuration::SpectralCoordinate loadSpectralCoordinate_(const std::map<std::string, std::string>&);

		static std::string getRequiredString_(const std::map<std::string, std::string>&, const std::string&);
		static int getRequiredInt_(const std::map<std::string, std::string>&, const std::string&);
		static double getRequiredDouble_(const std::map<std::string, std::string>&, const std::string&);
		static bool getRequiredBool_(const std::map<std::string, std::string>&, const std::string&);

		static std::string getOptionalString_(const std::map<std::string, std::string>&, const std::string&, const std::string&);
		static int getOptionalInt_(const std::map<std::string, std::string>&, const std::string&, int);
		static double getOptionalDouble_(const std::map<std::string, std::string>&, const std::string&, double);
		static bool getOptionalBool_(const std::map<std::string, std::string>&, const std::string&, bool);

		static std::optional<std::string> getOptionalString_(const std::map<std::string, std::string>&, const std::string&);
		static std::optional<int> getOptionalInt_(const std::map<std::string, std::string>&, const std::string&);
		static std::optional<double> getOptionalDouble_(const std::map<std::string, std::string>&, const std::string&);
		static std::optional<bool> getOptionalBool_(const std::map<std::string, std::string>&, const std::string&);

		static bool hasKey_(const std::map<std::string, std::string>&, const std::string&);
		static int countArrayEntries_(const std::map<std::string, std::string>&, const std::string&);

		template<typename EnumT> static std::optional<EnumT> parseEnum_(const std::optional<std::string>&, const std::map<std::string, EnumT>&);
};

struct MonochromeData
{
	public:
		// std::vector<std::vector<std::vector<double>>> reflectance_top; // e, i, p?

		std::vector<Eigen::MatrixXd> reflectance_m_top_cos; // m, e, i
		std::vector<Eigen::MatrixXd> reflectance_m_top_sin; // m, e, i

		Eigen::VectorXd source_up; // e

		std::vector<double> absorption_coefficient; // altitude
		std::vector<double> scattering_coefficient; // altitude
		std::vector<double> single_scattering_albedo; // altitude
		std::vector<double> optical_thickness; // altitude
		std::vector<double> asymmetry_parameter; // altitude
};

struct RadiativeTransferResult
{
	public:
		int Ntheta;
		int Nphi;
		int Nmode;

		std::vector<double> theta_e, theta_i, phi;

		std::vector<double> altitude; // altitude
		std::vector<double> altitude_top; // altitude
		std::vector<double> altitude_bottom; // altitude
		std::vector<double> physical_thickness; // altitude

		std::vector<double> temperature; // altitude
		std::vector<double> pressure; // altitude
		std::vector<double> number_density; // altitude

		std::vector<MonochromeData> spectral_data;
};

class RadiativeTransferSolver
{
	private:
		Geometry geometry_;
		DeltaApproximation delta_approximation_;
		
		double initial_optical_thickness_;

		RadiativeLayer initializeAtmosphericLayer_(const OpticalLayer&);
		RadiativeLayer initializeSurfaceLayer_(const OpticalLayer&);

		std::vector<OpticalLayer> setAtmosphericLayerCondition_(const AtmosphereModel&, double, SpectralCoordinateDimension, int);
		OpticalLayer setSurfaceLayerCondition_(const AtmosphereModel&, double, SpectralCoordinateDimension);

		void computeDeltaApproximation_(OpticalLayer&);

	public:
		RadiativeTransferSolver();
		RadiativeTransferSolver(const Geometry&);

		void geometry(const Geometry&); // setter
		void delta_approximation(const DeltaApproximation&); // setter

		MonochromeData computeMonochrome(const AtmosphereModel&, double, SpectralCoordinateDimension, double);
		std::vector<std::vector<std::vector<double>>> reconstruct(const std::vector<std::vector<std::vector<std::vector<double>>>>&);
		// void reconstructOpticalProperties(RadiativeLayer&);
		std::vector<std::vector<Eigen::MatrixXd>> computeFourierSeriesCoefficients(const std::vector<std::vector<std::vector<double>>>&);
		// void computeFourierSeriesCoefficients(RadiativeLayer&);
};

class ModelBuilder
{
	public:
		static AtmosphereModel buildAtmosphereModel(const Configuration&, const SpectralInformation&);
		static Geometry buildGeometry(const Configuration&);
		static SpectralInformation buildSpectral(const Configuration&);
		static DeltaApproximation buildDeltaApproximation(const Configuration&);

	private:
		static std::vector<Species> buildSpecies_(const Configuration&, const AtmosphereModel&, const SpectralInformation&);
		static double interpolateVerticalProfile(double, const std::vector<std::vector<double>>&, VerticalProfileInterpolation);
};

class RadiativeTransfer
{
	private:
		Configuration configuration_;
		AtmosphereModel atmosphere_model_;
		RadiativeTransferSolver radiative_transfer_solver_;
		SpectralInformation spectral_;
		Geometry geometry_;
		DeltaApproximation delta_approximation_;
		RadiativeTransferResult result_;

		std::string config_filename_;

		RadiativeTransferResult convolve_(const RadiativeTransferResult& radiative_transfer_result);
		
	public:
		RadiativeTransfer();
		RadiativeTransfer(const std::string&);
		void loadConfiguration(void);
		void run(void);
		void exportResultNetCDF(void);
		RadiativeTransferResult result(void);
};

class JacobianResult
{
	public:
		int Ntheta, Nphi, Nmode;
		std::vector<double> altitude;

		std::vector<double> emission_zenith_angle;
		std::vector<double> incidence_zenith_angle;
		std::vector<double> emission_azimuth_angle;
		
		std::vector<Eigen::VectorXd> weighting_function_source_up;
		std::vector<Eigen::VectorXd> contribution_function_source_up;

		std::vector<std::vector<std::vector<std::vector<double>>>> weighting_function_reflectance_top;
		std::vector<std::vector<std::vector<std::vector<double>>>> contribution_function_reflectance_top;

		std::vector<std::vector<Eigen::MatrixXd>> weighting_function_reflectance_m_top_cos;
		std::vector<std::vector<Eigen::MatrixXd>> weighting_function_reflectance_m_top_sin;
		std::vector<std::vector<Eigen::MatrixXd>> contribution_function_reflectance_m_top_cos;
		std::vector<std::vector<Eigen::MatrixXd>> contribution_function_reflectance_m_top_sin;

		void initialize(int nlayer)
		{
			altitude.resize(nlayer);
			// emission_zenith_angle.resize(nlayer);

			weighting_function_source_up.resize(nlayer);
			contribution_function_source_up.resize(nlayer);

			weighting_function_reflectance_top.resize(nlayer);
			contribution_function_reflectance_top.resize(nlayer);

			weighting_function_reflectance_m_top_cos.resize(nlayer);
			contribution_function_reflectance_m_top_cos.resize(nlayer);

			weighting_function_reflectance_m_top_sin.resize(nlayer);
			contribution_function_reflectance_m_top_sin.resize(nlayer);

			return;
		}
};

}