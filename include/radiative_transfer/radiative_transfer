#pragma once

#include<complex>
#include<random>
#include<filesystem>
#include<fstream>
#include<omp.h>
#include<iomanip>
#include<thread>
#include<chrono>
#include<netcdf>

#include<ctime>
#include<sstream>

#include<Eigen/Dense>

#include"constants"
#include"types"
#include"atmosphere"
#include"configuration"
#include"solver"
#include"export"
#include"geometry"
#include"utilities"

namespace radiative_transfer
{

JacobianResult computeJacobian(std::string, JacobianType, double);
JacobianResult computeJacobianSpecies(std::string, JacobianType, int, double);
JacobianResult computeJacobianRefractiveIndex(std::string, std::vector<int>, double);

inline void RadiativeTransfer::importConfiguration(void)
{
	try
	{
		configuration.importConfiguration(config_filename);
	}
	catch(const std::exception &e)
	{
		std::cerr << "Configuration import failed: " << e.what() << std::endl;
	}

	std::filesystem::create_directory(configuration.directory_name + "result");
	// std::filesystem::create_directory(configuration.directory_name + "log");

	return;
}

inline void RadiativeTransfer::exportResultNetCDF(void)
{
	try
	{
		exportResultNetCDF(configuration.result_name);
	}
	catch(const std::exception &e)
	{
		std::cerr << "Calculation result export failed: " << e.what() << std::endl;
	}


	return;
}

/*
inline void RadiativeTransfer::runSpectrum(void)
{
	initializeGeometry();

	int n_x;
	if(configuration.is_wavenumber == true)
	{
		n_x = configuration.wavenumber_list.size();
		result.wavenumber.resize(n_x);
	}
	else
	{
		n_x = configuration.wavelength_list.size();
		result.wavelength.resize(n_x);
	}

	result.Ntheta = Ntheta;
	result.Nmode = M;

	for(int i = 0; i < Ntheta; i ++)
	{
		result.theta_e.push_back(geometry.theta_uh(i));
		result.theta_i.push_back(PI - geometry.theta_lh(i));
	}

	result.absorption_coefficient.resize(n_x);
	result.scattering_coefficient.resize(n_x);
	result.single_scattering_albedo.resize(n_x);
	result.optical_thickness.resize(n_x);
	result.asymmetry_parameter.resize(n_x);

	result.reflectance_top.resize(n_x);
	result.reflectance_m_top_cos.resize(n_x);
	result.reflectance_m_top_sin.resize(n_x);
	result.source_up.resize(n_x);

	#pragma omp parallel for
	for(int n_lambda = 0; n_lambda < n_x; n_lambda ++)
	{
		#pragma omp critical
		{
			if(configuration.is_wavenumber == true)
			{
				std::cout << "Wavenumber: " << configuration.wavenumber_list[n_lambda] << " m-1 (" << n_lambda + 1 << " / " << configuration.wavenumber_list.size() << ")" << std::endl;
			}
			else
			{
				std::cout << "Wavelength: " << configuration.wavelength_list[n_lambda] << " m (" << n_lambda + 1 << " / " << configuration.wavelength_list.size() << ")" << std::endl;
			}
		}

		AtmosphereModel atmosphere_model;

		computeAtmosphericProperties(atmosphere_model);
		computeSpeciesProperties(atmosphere_model);
				
		if(configuration.is_wavenumber == true)
		{
			double wavenumber = configuration.wavenumber_list[n_lambda];
			result.wavenumber[n_lambda] = wavenumber;
			runMonochrome(atmosphere_model, wavenumber);
		}
		else
		{
			double wavelength = configuration.wavelength_list[n_lambda];
			result.wavelength[n_lambda] = wavelength;
			runMonochrome(atmosphere_model, 1.0 / wavelength);
		}

		if(n_lambda == 0)
		{
			std::vector<double> z, z_top, z_bottom, dz, T, P, ND;
			for(int i = 0; i < atmosphere_model.layers.size(); i ++)
			{
				z.push_back(atmosphere_model.layers[i].altitude);
				z_top.push_back(atmosphere_model.layers[i].altitude_top);
				z_bottom.push_back(atmosphere_model.layers[i].altitude_bottom);
				dz.push_back(atmosphere_model.layers[i].physical_thickness);
				T.push_back(atmosphere_model.layers[i].temperature);
				P.push_back(atmosphere_model.layers[i].pressure);
				ND.push_back(atmosphere_model.layers[i].number_density);
			}

			result.altitude = z;
			result.altitude_bottom = z_bottom;
			result.altitude_top = z_top;
			result.physical_thickness = dz;
			result.temperature = T;
			result.pressure = P;
			result.number_density = ND;
		}

		result.absorption_coefficient[n_lambda].resize(atmosphere_model.layers.size());
		result.scattering_coefficient[n_lambda].resize(atmosphere_model.layers.size());
		result.single_scattering_albedo[n_lambda].resize(atmosphere_model.layers.size());
		result.optical_thickness[n_lambda].resize(atmosphere_model.layers.size());
		result.asymmetry_parameter[n_lambda].resize(atmosphere_model.layers.size());

		for(int i = 0; i < atmosphere_model.layers.size(); i ++)
		{
			result.optical_thickness[n_lambda][i] = atmosphere_model.layers[i].optical_thickness;
			result.scattering_coefficient[n_lambda][i] = atmosphere_model.layers[i].scattering_coefficient;
			result.absorption_coefficient[n_lambda][i] = atmosphere_model.layers[i].absorption_coefficient;
			result.single_scattering_albedo[n_lambda][i] = atmosphere_model.layers[i].single_scattering_albedo;
			result.asymmetry_parameter[n_lambda][i] = atmosphere_model.layers[i].asymmetry_parameter;
		}

		reconstructOpticalProperties(atmosphere_model.result_layer);

		result.reflectance_top[n_lambda] = atmosphere_model.result_layer.reflectance_top;
		result.reflectance_m_top_cos[n_lambda] = atmosphere_model.result_layer.reflectance_m_top_cos;
		result.reflectance_m_top_sin[n_lambda] = atmosphere_model.result_layer.reflectance_m_top_sin;
		result.source_up[n_lambda] = atmosphere_model.result_layer.source_up;
	}

	if(configuration.is_instrument)
	{
		// std::cout << "instrument" << std::endl;

		int n_lsf;
		double dx = configuration.instrument_function_width / double(configuration.n_over_sample);

		if(configuration.instrument_function_type == InstrumentFunction::Rectangle)
		{
			n_lsf = configuration.n_over_sample + 1;
		}
		else if(configuration.instrument_function_type == InstrumentFunction::Gauss)
		{
			n_lsf = 2 * 5 * configuration.n_over_sample + 1;
		}

		std::vector<double> lsf_kernel(n_lsf);

		if(configuration.instrument_function_type == InstrumentFunction::Rectangle)
		{
			for(int i = 0; i < n_lsf; i ++)
			{
				lsf_kernel[i] = 1.0;
			}
		}
		else if(configuration.instrument_function_type == InstrumentFunction::Gauss)
		{
			int n_center = (n_lsf - 1) / 2;
			double sigma = configuration.instrument_function_width;
						
			for(int i = 0; i < n_lsf; i ++)
			{
				double x = dx * double(i - n_center);

				lsf_kernel[i] = std::exp(-x * x / (2.0 * sigma * sigma));
			}
		}

		// normalization
		double sum = 0.0;
		for(int i = 0; i < n_lsf; i ++)
		{
			sum += lsf_kernel[i];
		}

		for(int i = 0; i < n_lsf; i ++)
		{
			lsf_kernel[i] /= sum;
		}

		auto result_tmp = result;

		for(int n_wn = 0; n_wn < n_x; n_wn ++)
		{
			result.reflectance_top[n_wn] = std::vector<std::vector<std::vector<double>>>(Ntheta, std::vector<std::vector<double>>(Ntheta, std::vector<double>(Nphi, 0.0)));
			result.reflectance_m_top_cos[n_wn] = std::vector<Eigen::MatrixXd>(M + 1, Eigen::MatrixXd::Zero(Ntheta, Ntheta));
			result.reflectance_m_top_sin[n_wn] = std::vector<Eigen::MatrixXd>(M + 1, Eigen::MatrixXd::Zero(Ntheta, Ntheta));
			result.source_up[n_wn] = Eigen::VectorXd::Zero(Ntheta);
			
			int n_start = std::max(0, n_wn - (n_lsf - 1) / 2);
			int n_end = std::min(n_x - 1, n_wn + (n_lsf - 1) / 2);

			for(int i = n_start; i <= n_end; i ++)
			{
				int n_kn = (n_lsf - 1) / 2 + i - n_wn;

				for(int ne = 0; ne < Ntheta; ne ++)
				{
					for(int ni = 0; ni < Ntheta; ni ++)
					{
						for(int np = 0; np < Nphi; np ++)
						{
							result.reflectance_top[n_wn][ne][ni][np] += result_tmp.reflectance_top[i][ne][ni][np] * lsf_kernel[n_kn];
						}
					}
				}

				for(int nm = 0; nm <= M; nm ++)
				{
					result.reflectance_m_top_cos[n_wn][nm] += result_tmp.reflectance_m_top_cos[i][nm] * lsf_kernel[n_kn];
					result.reflectance_m_top_sin[n_wn][nm] += result_tmp.reflectance_m_top_sin[i][nm] * lsf_kernel[n_kn];
				}
				
				result.source_up[n_wn] += result_tmp.source_up[i] * lsf_kernel[n_kn];
			}
		}
	
		for(int n_wn = 0; n_wn < n_x; n_wn ++)
		{
			if(result.wavenumber[n_wn] < configuration.wavenumber_min_result || result.wavenumber[n_wn] > configuration.wavenumber_max_result)
			{
				result.reflectance_top.erase(result.reflectance_top.begin() + n_wn);
				result.reflectance_m_top_cos.erase(result.reflectance_m_top_cos.begin() + n_wn);
				result.reflectance_m_top_sin.erase(result.reflectance_m_top_sin.begin() + n_wn);
				result.source_up.erase(result.source_up.begin() + n_wn);
				result.wavenumber.erase(result.wavenumber.begin() + n_wn);
				result.absorption_coefficient.erase(result.absorption_coefficient.begin() + n_wn);
				result.scattering_coefficient.erase(result.scattering_coefficient.begin() + n_wn);
				result.single_scattering_albedo.erase(result.single_scattering_albedo.begin() + n_wn);
				result.optical_thickness.erase(result.optical_thickness.begin() + n_wn);
				result.asymmetry_parameter.erase(result.asymmetry_parameter.begin() + n_wn);

				n_wn --;
				n_x --;
			}
		}
	}

	return;
}
*/

inline void RadiativeTransfer::runSpectrum(AtmosphereModel atmosphere_model)
{
	int n_x;
	if(configuration.is_wavenumber == true)
	{
		n_x = configuration.wavenumber_list.size();
		result.wavenumber.resize(n_x);
	}
	else
	{
		n_x = configuration.wavelength_list.size();
		result.wavelength.resize(n_x);
	}

	result.Ntheta = Ntheta;
	result.Nmode = M;
	result.Nphi = Nphi;

	for(int i = 0; i < Ntheta; i ++)
	{
		result.theta_e.push_back(geometry.theta_uh(i));
		result.theta_i.push_back(PI - geometry.theta_lh(i));
	}

	result.phi = std::vector<double>(geometry.phi.data(), geometry.phi.data() + geometry.phi.size());

	result.absorption_coefficient.resize(n_x);
	result.scattering_coefficient.resize(n_x);
	result.single_scattering_albedo.resize(n_x);
	result.optical_thickness.resize(n_x);
	result.asymmetry_parameter.resize(n_x);

	result.reflectance_top.resize(n_x);
	result.reflectance_m_top_cos.resize(n_x);
	result.reflectance_m_top_sin.resize(n_x);
	result.source_up.resize(n_x);

	#pragma omp parallel for num_threads(configuration.n_parallel)
	for(int n_lambda = 0; n_lambda < n_x; n_lambda ++)
	{
		#pragma omp critical
		{
			if(configuration.is_wavenumber == true)
			{
				std::cout << "Wavenumber: " << configuration.wavenumber_list[n_lambda] << " m-1 (" << n_lambda + 1 << " / " << configuration.wavenumber_list.size() << ")" << std::endl;
			}
			else
			{
				std::cout << "Wavelength: " << configuration.wavelength_list[n_lambda] << " m (" << n_lambda + 1 << " / " << configuration.wavelength_list.size() << ")" << std::endl;
			}
		}

		AtmosphereModel atmos_model = atmosphere_model;
				
		if(configuration.is_wavenumber == true)
		{
			double wavenumber = configuration.wavenumber_list[n_lambda];
			result.wavenumber[n_lambda] = wavenumber;
			runMonochrome(atmos_model, wavenumber);
		}
		else
		{
			double wavelength = configuration.wavelength_list[n_lambda];
			result.wavelength[n_lambda] = wavelength;
			runMonochrome(atmos_model, 1.0 / wavelength);
		}

		if(n_lambda == 0)
		{
			std::vector<double> z, z_top, z_bottom, dz, T, P, ND;
			for(int i = 0; i < atmos_model.layers.size(); i ++)
			{
				z.push_back(atmos_model.layers[i].altitude);
				z_top.push_back(atmos_model.layers[i].altitude_top);
				z_bottom.push_back(atmos_model.layers[i].altitude_bottom);
				dz.push_back(atmos_model.layers[i].physical_thickness);
				T.push_back(atmos_model.layers[i].temperature);
				P.push_back(atmos_model.layers[i].pressure);
				ND.push_back(atmos_model.layers[i].number_density);
			}

			result.altitude = z;
			result.altitude_bottom = z_bottom;
			result.altitude_top = z_top;
			result.physical_thickness = dz;
			result.temperature = T;
			result.pressure = P;
			result.number_density = ND;
		}

		result.absorption_coefficient[n_lambda].resize(atmos_model.layers.size());
		result.scattering_coefficient[n_lambda].resize(atmos_model.layers.size());
		result.single_scattering_albedo[n_lambda].resize(atmos_model.layers.size());
		result.optical_thickness[n_lambda].resize(atmos_model.layers.size());
		result.asymmetry_parameter[n_lambda].resize(atmos_model.layers.size());

		for(int i = 0; i < atmos_model.layers.size(); i ++)
		{
			result.optical_thickness[n_lambda][i] = atmos_model.layers[i].optical_thickness;
			result.scattering_coefficient[n_lambda][i] = atmos_model.layers[i].scattering_coefficient;
			result.absorption_coefficient[n_lambda][i] = atmos_model.layers[i].absorption_coefficient;
			result.single_scattering_albedo[n_lambda][i] = atmos_model.layers[i].single_scattering_albedo;
			result.asymmetry_parameter[n_lambda][i] = atmos_model.layers[i].asymmetry_parameter;
		}

		reconstructOpticalProperties(atmos_model.result_layer);

		result.reflectance_top[n_lambda] = atmos_model.result_layer.reflectance_top;
		result.reflectance_m_top_cos[n_lambda] = atmos_model.result_layer.reflectance_m_top_cos;
		result.reflectance_m_top_sin[n_lambda] = atmos_model.result_layer.reflectance_m_top_sin;
		result.source_up[n_lambda] = atmos_model.result_layer.source_up;
	}

	if(configuration.is_instrument)
	{
		// std::cout << "instrument" << std::endl;

		int n_lsf;
		double dx = configuration.instrument_function_width / double(configuration.n_sample);

		if(configuration.instrument_function_type == InstrumentFunction::Rectangle)
		{
			n_lsf = configuration.n_sample + 1;
		}
		else if(configuration.instrument_function_type == InstrumentFunction::Gauss)
		{
			n_lsf = 2 * 5 * configuration.n_sample + 1;
		}

		std::vector<double> lsf_kernel(n_lsf);

		if(configuration.instrument_function_type == InstrumentFunction::Rectangle)
		{
			for(int i = 0; i < n_lsf; i ++)
			{
				lsf_kernel[i] = 1.0;
			}
		}
		else if(configuration.instrument_function_type == InstrumentFunction::Gauss)
		{
			int n_center = (n_lsf - 1) / 2;
			double sigma = configuration.instrument_function_width;
						
			for(int i = 0; i < n_lsf; i ++)
			{
				double x = dx * double(i - n_center);

				lsf_kernel[i] = std::exp(-x * x / (2.0 * sigma * sigma));
			}
		}

		// normalization
		double sum = 0.0;
		for(int i = 0; i < n_lsf; i ++)
		{
			sum += lsf_kernel[i];
		}

		for(int i = 0; i < n_lsf; i ++)
		{
			lsf_kernel[i] /= sum;
		}

		auto result_tmp = result;

		for(int n_wn = 0; n_wn < n_x; n_wn ++)
		{
			result.reflectance_top[n_wn] = std::vector<std::vector<std::vector<double>>>(Ntheta, std::vector<std::vector<double>>(Ntheta, std::vector<double>(Nphi, 0.0)));
			result.reflectance_m_top_cos[n_wn] = std::vector<Eigen::MatrixXd>(M + 1, Eigen::MatrixXd::Zero(Ntheta, Ntheta));
			result.reflectance_m_top_sin[n_wn] = std::vector<Eigen::MatrixXd>(M + 1, Eigen::MatrixXd::Zero(Ntheta, Ntheta));
			result.source_up[n_wn] = Eigen::VectorXd::Zero(Ntheta);
			
			int n_start = std::max(0, n_wn - (n_lsf - 1) / 2);
			int n_end = std::min(n_x - 1, n_wn + (n_lsf - 1) / 2);

			for(int i = n_start; i <= n_end; i ++)
			{
				int n_kn = (n_lsf - 1) / 2 + i - n_wn;

				for(int ne = 0; ne < Ntheta; ne ++)
				{
					for(int ni = 0; ni < Ntheta; ni ++)
					{
						for(int np = 0; np < Nphi; np ++)
						{
							result.reflectance_top[n_wn][ne][ni][np] += result_tmp.reflectance_top[i][ne][ni][np] * lsf_kernel[n_kn];
						}
					}
				}

				for(int nm = 0; nm <= M; nm ++)
				{
					result.reflectance_m_top_cos[n_wn][nm] += result_tmp.reflectance_m_top_cos[i][nm] * lsf_kernel[n_kn];
					result.reflectance_m_top_sin[n_wn][nm] += result_tmp.reflectance_m_top_sin[i][nm] * lsf_kernel[n_kn];
				}
				
				result.source_up[n_wn] += result_tmp.source_up[i] * lsf_kernel[n_kn];
			}
		}
	
		for(int n_wn = 0; n_wn < n_x; n_wn ++)
		{
			if(result.wavenumber[n_wn] < configuration.wavenumber_min_result || result.wavenumber[n_wn] > configuration.wavenumber_max_result)
			{
				result.reflectance_top.erase(result.reflectance_top.begin() + n_wn);
				result.reflectance_m_top_cos.erase(result.reflectance_m_top_cos.begin() + n_wn);
				result.reflectance_m_top_sin.erase(result.reflectance_m_top_sin.begin() + n_wn);
				result.source_up.erase(result.source_up.begin() + n_wn);
				result.wavenumber.erase(result.wavenumber.begin() + n_wn);
				result.absorption_coefficient.erase(result.absorption_coefficient.begin() + n_wn);
				result.scattering_coefficient.erase(result.scattering_coefficient.begin() + n_wn);
				result.single_scattering_albedo.erase(result.single_scattering_albedo.begin() + n_wn);
				result.optical_thickness.erase(result.optical_thickness.begin() + n_wn);
				result.asymmetry_parameter.erase(result.asymmetry_parameter.begin() + n_wn);

				n_wn --;
				n_x --;
			}
		}
	}

	return;
}

inline void RadiativeTransfer::runMonochrome(AtmosphereModel& atmosphere_model, double wavenumber)
{
	//call computeAtmosphericProperties, computeSpeciesProperties, initializeGeometry, setLayerCondition first
	// std::cout << "thru" << std::endl;

	// std::cout << atmosphere_model.layers.size() << std::endl;

	for(int nlayer = 0; nlayer < atmosphere_model.layers.size(); nlayer ++)
	{
		initializeLayer(atmosphere_model.layers[nlayer]);
	}

	if(configuration.surface_type != SurfaceType::NoSurface)
	{
		initializeSurface(atmosphere_model.surface_layer);
	}

	// std::cout << "thru" << std::endl;

	for(int nlayer = 0; nlayer < atmosphere_model.layers.size(); nlayer ++)
	{
		auto layer = atmosphere_model.layers[nlayer];
		
		for(int nadd = 0; nadd < layer.n_doubling; nadd ++)
		{
			layer = doubleLayer(layer, geometry);
		}

		atmosphere_model.layers[nlayer] = layer;

		if(nlayer == 0)
		{
			if(configuration.surface_type == SurfaceType::NoSurface)
			{
				atmosphere_model.result_layer = layer;
			}
			else
			{
				atmosphere_model.result_layer = addLayer(atmosphere_model.surface_layer, layer, geometry);
			}
		}
		else
		{
			atmosphere_model.result_layer = addLayer(atmosphere_model.result_layer, layer, geometry);
		}
	}
	
	return;
}

/*
inline void RadiativeTransfer::runBandpass(void)
{
	initializeGeometry();

	int n_x;
	if(configuration.is_wavenumber == true)
	{
		n_x = configuration.wavenumber_list.size();
		result.wavenumber.resize(n_x);
	}
	else
	{
		n_x = configuration.wavelength_list.size();
		result.wavelength.resize(n_x);
	}

	result.Ntheta = Ntheta;
	result.Nmode = M;

	for(int i = 0; i < Ntheta; i ++)
	{
		result.theta_e.push_back(geometry.theta_uh(i));
		result.theta_i.push_back(PI - geometry.theta_lh(i));
	}

	result.absorption_coefficient.resize(n_x);
	result.scattering_coefficient.resize(n_x);
	result.single_scattering_albedo.resize(n_x);
	result.optical_thickness.resize(n_x);
	result.asymmetry_parameter.resize(n_x);

	result.reflectance_top.resize(n_x);
	result.reflectance_m_top_cos.resize(n_x);
	result.reflectance_m_top_sin.resize(n_x);
	result.source_up.resize(n_x);

	#pragma omp parallel for
	for(int n_lambda = 0; n_lambda < n_x; n_lambda ++)
	{
		#pragma omp critical
		{
			if(configuration.is_wavenumber == true)
			{
				std::cout << "Wavenumber: " << configuration.wavenumber_list[n_lambda] << " m-1 (" << n_lambda + 1 << " / " << configuration.wavenumber_list.size() << ")" << std::endl;
			}
			else
			{
				std::cout << "Wavelength: " << configuration.wavelength_list[n_lambda] << " m (" << n_lambda + 1 << " / " << configuration.wavelength_list.size() << ")" << std::endl;
			}
		}

		AtmosphereModel atmosphere_model;

		computeAtmosphericProperties(atmosphere_model);
		computeSpeciesProperties(atmosphere_model);
				
		if(configuration.is_wavenumber == true)
		{
			double wavenumber = configuration.wavenumber_list[n_lambda];
			result.wavenumber[n_lambda] = wavenumber;
			runMonochrome(atmosphere_model, wavenumber);
		}
		else
		{
			double wavelength = configuration.wavelength_list[n_lambda];
			result.wavelength[n_lambda] = wavelength;
			runMonochrome(atmosphere_model, 1.0 / wavelength);
		}

		if(n_lambda == 0)
		{
			std::vector<double> z, z_top, z_bottom, dz, T, P, ND;
			for(int i = 0; i < atmosphere_model.layers.size(); i ++)
			{
				z.push_back(atmosphere_model.layers[i].altitude);
				z_top.push_back(atmosphere_model.layers[i].altitude_top);
				z_bottom.push_back(atmosphere_model.layers[i].altitude_bottom);
				dz.push_back(atmosphere_model.layers[i].physical_thickness);
				T.push_back(atmosphere_model.layers[i].temperature);
				P.push_back(atmosphere_model.layers[i].pressure);
				ND.push_back(atmosphere_model.layers[i].number_density);
			}

			result.altitude = z;
			result.altitude_bottom = z_bottom;
			result.altitude_top = z_top;
			result.physical_thickness = dz;
			result.temperature = T;
			result.pressure = P;
			result.number_density = ND;
		}

		result.absorption_coefficient[n_lambda].resize(atmosphere_model.layers.size());
		result.scattering_coefficient[n_lambda].resize(atmosphere_model.layers.size());
		result.single_scattering_albedo[n_lambda].resize(atmosphere_model.layers.size());
		result.optical_thickness[n_lambda].resize(atmosphere_model.layers.size());
		result.asymmetry_parameter[n_lambda].resize(atmosphere_model.layers.size());

		for(int i = 0; i < atmosphere_model.layers.size(); i ++)
		{
			result.optical_thickness[n_lambda][i] = atmosphere_model.layers[i].optical_thickness;
			result.scattering_coefficient[n_lambda][i] = atmosphere_model.layers[i].scattering_coefficient;
			result.absorption_coefficient[n_lambda][i] = atmosphere_model.layers[i].absorption_coefficient;
			result.single_scattering_albedo[n_lambda][i] = atmosphere_model.layers[i].single_scattering_albedo;
			result.asymmetry_parameter[n_lambda][i] = atmosphere_model.layers[i].asymmetry_parameter;
		}

		reconstructOpticalProperties(atmosphere_model.result_layer);

		result.reflectance_top[n_lambda] = atmosphere_model.result_layer.reflectance_top;
		result.reflectance_m_top_cos[n_lambda] = atmosphere_model.result_layer.reflectance_m_top_cos;
		result.reflectance_m_top_sin[n_lambda] = atmosphere_model.result_layer.reflectance_m_top_sin;
		result.source_up[n_lambda] = atmosphere_model.result_layer.source_up;
	}

	auto result_tmp = result;

	int n_layer = result.altitude.size();

	result.absorption_coefficient.resize(1, std::vector<double>(n_layer, 0.0));
	result.scattering_coefficient.resize(1, std::vector<double>(n_layer, 0.0));
	result.single_scattering_albedo.resize(1, std::vector<double>(n_layer, 0.0));
	result.optical_thickness.resize(1, std::vector<double>(n_layer, 0.0));
	result.asymmetry_parameter.resize(1, std::vector<double>(n_layer, 0.0));

	result.reflectance_top.resize(1, std::vector<std::vector<std::vector<double>>>(Ntheta, std::vector<std::vector<double>>(Ntheta, std::vector<double>(Nphi, 0.0))));
	result.reflectance_m_top_cos.resize(1, std::vector<Eigen::MatrixXd>(M + 1, Eigen::MatrixXd::Zero(Ntheta, Ntheta)));
	result.reflectance_m_top_sin.resize(1, std::vector<Eigen::MatrixXd>(M + 1, Eigen::MatrixXd::Zero(Ntheta, Ntheta)));
	result.source_up.resize(1, Eigen::VectorXd::Zero(Ntheta));

	double wavenumber_mean = 0.0;
	double wavelength_mean = 0.0;

	for(int i = 0; i < n_x; i ++)
	{
		for(int j = 0; j < n_layer; j ++)
		{
			result.absorption_coefficient[0][j] += result_tmp.absorption_coefficient[i][j] * configuration.window_function[i];
			result.scattering_coefficient[0][j] += result_tmp.scattering_coefficient[i][j] * configuration.window_function[i];
			// result.single_scattering_albedo[0][j] += result_tmp.single_scattering_albedo[i][j] * configuration.window_function[i];
			// result.optical_thickness[0][j] += result_tmp.optical_thickness[i][j] * configuration.window_function[i];
			result.asymmetry_parameter[0][j] += result_tmp.asymmetry_parameter[i][j] * result_tmp.scattering_coefficient[i][j] * configuration.window_function[i];
		}

		for(int j = 0; j < Ntheta; j ++)
		{
			result.source_up[0](j) += result_tmp.source_up[i](j) * configuration.window_function[i];

			for(int k = 0; k < Ntheta; k ++)
			{
				for(int l = 0; l < Nphi; l ++)
				{
					result.reflectance_top[0][j][k][l] += result_tmp.reflectance_top[i][j][k][l] * configuration.window_function[i];
				}
			}
		}

		for(int j = 0; j <= M; j ++)
		{
			for(int k = 0; k < Ntheta; k ++)
			{
				for(int l = 0; l < Ntheta; l ++)
				{
					result.reflectance_m_top_cos[0][j](k, l) += result_tmp.reflectance_m_top_cos[i][j](k, l) * configuration.window_function[i];
					result.reflectance_m_top_sin[0][j](k, l) += result_tmp.reflectance_m_top_sin[i][j](k, l) * configuration.window_function[i];
				}
			}
		}

		wavenumber_mean += (configuration.is_wavenumber == true ? configuration.wavenumber_list[i] : 1.0 / configuration.wavelength_list[i]) * configuration.window_function[i];
		wavelength_mean += (configuration.is_wavenumber == true ? 1.0 / configuration.wavenumber_list[i] : configuration.wavelength_list[i]) * configuration.window_function[i];
	}

	for(int j = 0; j < n_layer; j ++)
	{
		result.single_scattering_albedo[0][j] = result.scattering_coefficient[0][j] / (result.scattering_coefficient[0][j] + result.absorption_coefficient[0][j]);
		result.asymmetry_parameter[0][j] /= result.scattering_coefficient[0][j];
		result.optical_thickness[0][j] = (result.scattering_coefficient[0][j] + result.absorption_coefficient[0][j]) * result.physical_thickness[j];
	}

	result.wavenumber = {wavenumber_mean};
	result.wavelength = {wavelength_mean};
	
	return;
}
*/

inline void RadiativeTransfer::runBandpass(AtmosphereModel atmosphere_model)
{
	int n_x;
	if(configuration.is_wavenumber == true)
	{
		n_x = configuration.wavenumber_list.size();
		result.wavenumber.resize(n_x);
	}
	else
	{
		n_x = configuration.wavelength_list.size();
		result.wavelength.resize(n_x);
	}

	result.Ntheta = Ntheta;
	result.Nmode = M;
	result.Nphi = Nphi;

	for(int i = 0; i < Ntheta; i ++)
	{
		result.theta_e.push_back(geometry.theta_uh(i));
		result.theta_i.push_back(PI - geometry.theta_lh(i));
	}

	result.phi = std::vector<double>(geometry.phi.data(), geometry.phi.data() + geometry.phi.size());

	result.absorption_coefficient.resize(n_x);
	result.scattering_coefficient.resize(n_x);
	result.single_scattering_albedo.resize(n_x);
	result.optical_thickness.resize(n_x);
	result.asymmetry_parameter.resize(n_x);

	result.reflectance_top.resize(n_x);
	result.reflectance_m_top_cos.resize(n_x);
	result.reflectance_m_top_sin.resize(n_x);
	result.source_up.resize(n_x);

	#pragma omp parallel for num_threads(configuration.n_parallel)
	for(int n_lambda = 0; n_lambda < n_x; n_lambda ++)
	{
		#pragma omp critical
		{
			if(configuration.is_wavenumber == true)
			{
				std::cout << "Wavenumber: " << configuration.wavenumber_list[n_lambda] << " m-1 (" << n_lambda + 1 << " / " << configuration.wavenumber_list.size() << ")" << std::endl;
			}
			else
			{
				std::cout << "Wavelength: " << configuration.wavelength_list[n_lambda] << " m (" << n_lambda + 1 << " / " << configuration.wavelength_list.size() << ")" << std::endl;
			}
		}

		AtmosphereModel atmos_model = atmosphere_model;
				
		if(configuration.is_wavenumber == true)
		{
			double wavenumber = configuration.wavenumber_list[n_lambda];
			result.wavenumber[n_lambda] = wavenumber;
			runMonochrome(atmos_model, wavenumber);
		}
		else
		{
			double wavelength = configuration.wavelength_list[n_lambda];
			result.wavelength[n_lambda] = wavelength;
			runMonochrome(atmos_model, 1.0 / wavelength);
		}

		// std::cout << "thru." << std::endl;

		if(n_lambda == 0)
		{
			std::vector<double> z, z_top, z_bottom, dz, T, P, ND;
			for(int i = 0; i < atmos_model.layers.size(); i ++)
			{
				z.push_back(atmos_model.layers[i].altitude);
				z_top.push_back(atmos_model.layers[i].altitude_top);
				z_bottom.push_back(atmos_model.layers[i].altitude_bottom);
				dz.push_back(atmos_model.layers[i].physical_thickness);
				T.push_back(atmos_model.layers[i].temperature);
				P.push_back(atmos_model.layers[i].pressure);
				ND.push_back(atmos_model.layers[i].number_density);
			}

			result.altitude = z;
			result.altitude_bottom = z_bottom;
			result.altitude_top = z_top;
			result.physical_thickness = dz;
			result.temperature = T;
			result.pressure = P;
			result.number_density = ND;
		}

		result.absorption_coefficient[n_lambda].resize(atmos_model.layers.size());
		result.scattering_coefficient[n_lambda].resize(atmos_model.layers.size());
		result.single_scattering_albedo[n_lambda].resize(atmos_model.layers.size());
		result.optical_thickness[n_lambda].resize(atmos_model.layers.size());
		result.asymmetry_parameter[n_lambda].resize(atmos_model.layers.size());

		for(int i = 0; i < atmos_model.layers.size(); i ++)
		{
			result.optical_thickness[n_lambda][i] = atmos_model.layers[i].optical_thickness;
			result.scattering_coefficient[n_lambda][i] = atmos_model.layers[i].scattering_coefficient;
			result.absorption_coefficient[n_lambda][i] = atmos_model.layers[i].absorption_coefficient;
			result.single_scattering_albedo[n_lambda][i] = atmos_model.layers[i].single_scattering_albedo;
			result.asymmetry_parameter[n_lambda][i] = atmos_model.layers[i].asymmetry_parameter;
		}

		reconstructOpticalProperties(atmos_model.result_layer);

		result.reflectance_top[n_lambda] = atmos_model.result_layer.reflectance_top;
		result.reflectance_m_top_cos[n_lambda] = atmos_model.result_layer.reflectance_m_top_cos;
		result.reflectance_m_top_sin[n_lambda] = atmos_model.result_layer.reflectance_m_top_sin;
		result.source_up[n_lambda] = atmos_model.result_layer.source_up;
	}

	auto result_tmp = result;

	int n_layer = result.altitude.size();

	result.absorption_coefficient.resize(1, std::vector<double>(n_layer, 0.0));
	result.scattering_coefficient.resize(1, std::vector<double>(n_layer, 0.0));
	result.single_scattering_albedo.resize(1, std::vector<double>(n_layer, 0.0));
	result.optical_thickness.resize(1, std::vector<double>(n_layer, 0.0));
	result.asymmetry_parameter.resize(1, std::vector<double>(n_layer, 0.0));

	result.reflectance_top.resize(1, std::vector<std::vector<std::vector<double>>>(Ntheta, std::vector<std::vector<double>>(Ntheta, std::vector<double>(Nphi, 0.0))));
	result.reflectance_m_top_cos.resize(1, std::vector<Eigen::MatrixXd>(M + 1, Eigen::MatrixXd::Zero(Ntheta, Ntheta)));
	result.reflectance_m_top_sin.resize(1, std::vector<Eigen::MatrixXd>(M + 1, Eigen::MatrixXd::Zero(Ntheta, Ntheta)));
	result.source_up.resize(1, Eigen::VectorXd::Zero(Ntheta));

	double wavenumber_mean = 0.0;
	double wavelength_mean = 0.0;

	for(int i = 0; i < n_x; i ++)
	{
		for(int j = 0; j < n_layer; j ++)
		{
			result.absorption_coefficient[0][j] += result_tmp.absorption_coefficient[i][j] * configuration.window_function[i];
			result.scattering_coefficient[0][j] += result_tmp.scattering_coefficient[i][j] * configuration.window_function[i];
			// result.single_scattering_albedo[0][j] += result_tmp.single_scattering_albedo[i][j] * configuration.window_function[i];
			// result.optical_thickness[0][j] += result_tmp.optical_thickness[i][j] * configuration.window_function[i];
			result.asymmetry_parameter[0][j] += result_tmp.asymmetry_parameter[i][j] * result_tmp.scattering_coefficient[i][j] * configuration.window_function[i];
		}

		for(int j = 0; j < Ntheta; j ++)
		{
			result.source_up[0](j) += result_tmp.source_up[i](j) * configuration.window_function[i];

			for(int k = 0; k < Ntheta; k ++)
			{
				for(int l = 0; l < Nphi; l ++)
				{
					result.reflectance_top[0][j][k][l] += result_tmp.reflectance_top[i][j][k][l] * configuration.window_function[i];
				}
			}
		}

		for(int j = 0; j <= M; j ++)
		{
			for(int k = 0; k < Ntheta; k ++)
			{
				for(int l = 0; l < Ntheta; l ++)
				{
					result.reflectance_m_top_cos[0][j](k, l) += result_tmp.reflectance_m_top_cos[i][j](k, l) * configuration.window_function[i];
					result.reflectance_m_top_sin[0][j](k, l) += result_tmp.reflectance_m_top_sin[i][j](k, l) * configuration.window_function[i];
				}
			}
		}

		wavenumber_mean += (configuration.is_wavenumber == true ? configuration.wavenumber_list[i] : 1.0 / configuration.wavelength_list[i]) * configuration.window_function[i];
		wavelength_mean += (configuration.is_wavenumber == true ? 1.0 / configuration.wavenumber_list[i] : configuration.wavelength_list[i]) * configuration.window_function[i];
	}

	for(int j = 0; j < n_layer; j ++)
	{
		result.single_scattering_albedo[0][j] = result.scattering_coefficient[0][j] / (result.scattering_coefficient[0][j] + result.absorption_coefficient[0][j]);
		result.asymmetry_parameter[0][j] /= result.scattering_coefficient[0][j];
		result.optical_thickness[0][j] = (result.scattering_coefficient[0][j] + result.absorption_coefficient[0][j]) * result.physical_thickness[j];
	}

	result.wavenumber = {wavenumber_mean};
	result.wavelength = {wavelength_mean};
	
	return;
}

inline void RadiativeTransfer::run(void)
{
	if(configuration.wavenumber_type == WavenumberType::Bandpass || configuration.wavelength_type == WavelengthType::Bandpass)
	{
		configuration.importConfiguration(config_filename);
		AtmosphereModel atmosphere_model;
		computeAtmosphericProperties(atmosphere_model);
		computeSpeciesProperties(atmosphere_model);
		initializeGeometry();
		runBandpass(atmosphere_model);
	}
	else if(configuration.wavenumber_type == WavenumberType::Spectrum || configuration.wavelength_type == WavelengthType::Spectrum)
	{
		configuration.importConfiguration(config_filename);
		AtmosphereModel atmosphere_model;
		computeAtmosphericProperties(atmosphere_model);
		computeSpeciesProperties(atmosphere_model);
		initializeGeometry();
		runSpectrum(atmosphere_model);
	}
	else if(configuration.wavenumber_type == WavenumberType::Monochrome || configuration.wavelength_type == WavelengthType::Monochrome)
	{
		configuration.importConfiguration(config_filename);
		AtmosphereModel atmosphere_model;
		computeAtmosphericProperties(atmosphere_model);
		computeSpeciesProperties(atmosphere_model);
		initializeGeometry();
		configuration.is_instrument = false;
		runSpectrum(atmosphere_model);
	}

	return;
}

/*
inline JacobianResult computeJacobianSpecies(std::string config_filename, JacobianType jacobian_type, int n_species, double delta = 0.01)
{
	JacobianResult result;

	Configuration cfg;

	try
	{
		cfg.importConfiguration(config_filename);
	}
	catch(const std::exception &e)
	{
		std::cerr << "Configuration import failed: " << e.what() << std::endl;
	}

	double wavenumber = cfg.is_wavenumber == true ? cfg.wavenumber_list[0] : 1.0 / cfg.wavelength_list[0];

	if((cfg.is_wavenumber == true && cfg.wavenumber_type == WavenumberType::Monochrome) || (cfg.is_wavenumber == false && cfg.wavelength_type == WavelengthType::Monochrome))
	{
		int n_layer;

		if(cfg.z_edge.size() > 0)
		{
			n_layer = cfg.z_edge.size() - 1;
		}
		else if(cfg.z_center.size() > 0)
		{
			n_layer = cfg.z_center.size();
		}
		else
		{
			throw std::runtime_error("Altitude coordinate not specified.");
		}

		result.initialize(n_layer);

		//results.resize(n_layer);

		if(jacobian_type == JacobianType::Temperature)
		{
			#pragma omp parallel for
			for(int nl = 0; nl < n_layer; nl ++)
			{
				#pragma omp critical
				{
					std::cout << "Layer " << nl << std::endl;
				}
				
				AtmosphereModel atmosphere_model_plus;
				RadiativeTransfer rtm_plus;
				rtm_plus.configuration = cfg;
				rtm_plus.computeAtmosphericProperties(atmosphere_model_plus);
				double temperature_base = atmosphere_model_plus.layers[nl].temperature;
				atmosphere_model_plus.layers[nl].temperature *= (1.0 + delta);
				rtm_plus.computeSpeciesProperties(atmosphere_model_plus);
				rtm_plus.initializeGeometry();
				rtm_plus.runMonochrome(atmosphere_model_plus, wavenumber);

				AtmosphereModel atmosphere_model_minus;
				RadiativeTransfer rtm_minus;
				rtm_minus.configuration = cfg;
				rtm_minus.computeAtmosphericProperties(atmosphere_model_minus);
				atmosphere_model_minus.layers[nl].temperature *= (1.0 - delta);
				rtm_minus.computeSpeciesProperties(atmosphere_model_minus);
				rtm_minus.initializeGeometry();
				rtm_minus.runMonochrome(atmosphere_model_minus, wavenumber);

				if(nl == 0)
				{
					result.emission_zenith_angle = std::vector<double>(rtm_plus.geometry.theta_uh.data(), rtm_plus.geometry.theta_uh.data() + rtm_plus.geometry.theta_uh.size());
				}

				result.altitude[nl] = atmosphere_model_plus.layers[nl].altitude;
				result.weighting_function[nl] = (atmosphere_model_plus.result_layer.source_up - atmosphere_model_minus.result_layer.source_up) / (2.0 * delta * temperature_base);
				result.contribution_function[nl] = (atmosphere_model_plus.result_layer.source_up - atmosphere_model_minus.result_layer.source_up) / (2.0 * delta * temperature_base) * temperature_base;
			}
		}
		else if(jacobian_type == JacobianType::TotalNumberDensity)
		{
			#pragma omp parallel for
			for(int nl = 0; nl < n_layer; nl ++)
			{
				#pragma omp critical
				{
					std::cout << "Layer " << nl << std::endl;
				}
				
				AtmosphereModel atmosphere_model_plus;
				RadiativeTransfer rtm_plus;
				rtm_plus.configuration = cfg;
				rtm_plus.computeAtmosphericProperties(atmosphere_model_plus);
				double number_density_base = atmosphere_model_plus.layers[nl].number_density;
				atmosphere_model_plus.layers[nl].number_density *= (1.0 + delta);
				rtm_plus.computeSpeciesProperties(atmosphere_model_plus);
				rtm_plus.initializeGeometry();
				rtm_plus.runMonochrome(atmosphere_model_plus, wavenumber);

				AtmosphereModel atmosphere_model_minus;
				RadiativeTransfer rtm_minus;
				rtm_minus.configuration = cfg;
				rtm_minus.computeAtmosphericProperties(atmosphere_model_minus);
				atmosphere_model_minus.layers[nl].number_density *= (1.0 - delta);
				rtm_minus.computeSpeciesProperties(atmosphere_model_minus);
				rtm_minus.initializeGeometry();
				rtm_minus.runMonochrome(atmosphere_model_minus, wavenumber);

				if(nl == 0)
				{
					result.emission_zenith_angle = std::vector<double>(rtm_plus.geometry.theta_uh.data(), rtm_plus.geometry.theta_uh.data() + rtm_plus.geometry.theta_uh.size());
				}

				result.altitude[nl] = atmosphere_model_plus.layers[nl].altitude;
				result.weighting_function[nl] = (atmosphere_model_plus.result_layer.source_up - atmosphere_model_minus.result_layer.source_up) / (2.0 * delta * number_density_base);
				result.contribution_function[nl] = (atmosphere_model_plus.result_layer.source_up - atmosphere_model_minus.result_layer.source_up) / (2.0 * delta * number_density_base) * number_density_base;
			}
		}
		else if(jacobian_type == JacobianType::SpeciesNumberDensity)
		{
			#pragma omp parallel for
			for(int nl = 0; nl < n_layer; nl ++)
			{
				#pragma omp critical
				{
					std::cout << "Layer " << nl << std::endl;
				}
				
				AtmosphereModel atmosphere_model_plus;
				RadiativeTransfer rtm_plus;
				rtm_plus.configuration = cfg;
				rtm_plus.computeAtmosphericProperties(atmosphere_model_plus);
				rtm_plus.computeSpeciesProperties(atmosphere_model_plus);
				double number_density_base = atmosphere_model_plus.layers[nl].number_density_species[n_species];
				atmosphere_model_plus.layers[nl].number_density_species[n_species] *= (1.0 + delta);
				rtm_plus.initializeGeometry();
				rtm_plus.runMonochrome(atmosphere_model_plus, wavenumber);

				AtmosphereModel atmosphere_model_minus;
				RadiativeTransfer rtm_minus;
				rtm_minus.configuration = cfg;
				rtm_minus.computeAtmosphericProperties(atmosphere_model_minus);
				rtm_minus.computeSpeciesProperties(atmosphere_model_minus);
				atmosphere_model_minus.layers[nl].number_density_species[n_species] *= (1.0 - delta);
				rtm_minus.initializeGeometry();
				rtm_minus.runMonochrome(atmosphere_model_minus, wavenumber);

				if(nl == 0)
				{
					result.emission_zenith_angle = std::vector<double>(rtm_plus.geometry.theta_uh.data(), rtm_plus.geometry.theta_uh.data() + rtm_plus.geometry.theta_uh.size());
				}

				result.altitude[nl] = atmosphere_model_plus.layers[nl].altitude;
				result.weighting_function[nl] = (atmosphere_model_plus.result_layer.source_up - atmosphere_model_minus.result_layer.source_up) / (2.0 * delta * number_density_base);
				result.contribution_function[nl] = (atmosphere_model_plus.result_layer.source_up - atmosphere_model_minus.result_layer.source_up) / (2.0 * delta * number_density_base) * number_density_base;
			}
		}
		else if(jacobian_type == JacobianType::SpeciesMixingRatio)
		{
			#pragma omp parallel for
			for(int nl = 0; nl < n_layer; nl ++)
			{
				#pragma omp critical
				{
					std::cout << "Layer " << nl << std::endl;
				}
				
				AtmosphereModel atmosphere_model_plus;
				RadiativeTransfer rtm_plus;
				rtm_plus.configuration = cfg;
				rtm_plus.computeAtmosphericProperties(atmosphere_model_plus);
				rtm_plus.computeSpeciesProperties(atmosphere_model_plus);
				double mixing_ratio_base = atmosphere_model_plus.layers[nl].mixing_ratio_species[n_species];
				atmosphere_model_plus.layers[nl].mixing_ratio_species[n_species] *= (1.0 + delta);
				atmosphere_model_plus.layers[nl].number_density_species[n_species] = atmosphere_model_plus.layers[nl].number_density * atmosphere_model_plus.layers[nl].mixing_ratio_species[n_species];
				rtm_plus.initializeGeometry();
				rtm_plus.runMonochrome(atmosphere_model_plus, wavenumber);

				AtmosphereModel atmosphere_model_minus;
				RadiativeTransfer rtm_minus;
				rtm_minus.configuration = cfg;
				rtm_minus.computeAtmosphericProperties(atmosphere_model_minus);
				rtm_minus.computeSpeciesProperties(atmosphere_model_minus);
				atmosphere_model_minus.layers[nl].mixing_ratio_species[n_species] *= (1.0 - delta);
				atmosphere_model_minus.layers[nl].number_density_species[n_species] = atmosphere_model_minus.layers[nl].number_density * atmosphere_model_minus.layers[nl].mixing_ratio_species[n_species];
				rtm_minus.initializeGeometry();
				rtm_minus.runMonochrome(atmosphere_model_minus, wavenumber);

				if(nl == 0)
				{
					result.emission_zenith_angle = std::vector<double>(rtm_plus.geometry.theta_uh.data(), rtm_plus.geometry.theta_uh.data() + rtm_plus.geometry.theta_uh.size());
				}

				result.altitude[nl] = atmosphere_model_plus.layers[nl].altitude;
				result.weighting_function[nl] = (atmosphere_model_plus.result_layer.source_up - atmosphere_model_minus.result_layer.source_up) / (2.0 * delta * mixing_ratio_base);
				result.contribution_function[nl] = (atmosphere_model_plus.result_layer.source_up - atmosphere_model_minus.result_layer.source_up) / (2.0 * delta * mixing_ratio_base) * mixing_ratio_base;
			}
		}
	}
	else
	{
		throw std::runtime_error("Computing spectral Jacobian is currently not supported.");
	}

	return result;
}
*/

inline JacobianResult computeJacobian(std::string config_filename, JacobianType jacobian_type, double delta = 0.01)
{
	if(jacobian_type == JacobianType::SpeciesMixingRatio || jacobian_type == JacobianType::SpeciesNumberDensity)
	{
		throw std::runtime_error("Use computeJacobianSpecies.");
	}

	return computeJacobianSpecies(config_filename, jacobian_type, 0, delta);
}

inline JacobianResult computeJacobianSpecies(std::string config_filename, JacobianType jacobian_type, int n_species, double delta = 0.01)
{
	JacobianResult result;

	Configuration cfg;

	try
	{
		cfg.importConfiguration(config_filename);
	}
	catch(const std::exception &e)
	{
		std::cerr << "Configuration import failed: " << e.what() << std::endl;
	}

	if((cfg.wavenumber_type == WavenumberType::Spectrum) || (cfg.wavenumber_type == WavenumberType::Spectrum) || (cfg.wavenumber_type == WavenumberType::Table) || (cfg.wavenumber_type == WavenumberType::Table))
	{
		throw std::runtime_error("Use monochrome or bandpass for the jacobian calculations.");
	}
	else
	{
		int n_layer;

		if(cfg.z_edge.size() > 0)
		{
			n_layer = cfg.z_edge.size() - 1;
		}
		else if(cfg.z_center.size() > 0)
		{
			n_layer = cfg.z_center.size();
		}
		else
		{
			std::cout << cfg.z_edge.size() << ", " << cfg.z_center.size() << std::endl;
			throw std::runtime_error("Altitude coordinate not specified.");
		}

		result.initialize(n_layer);

		//results.resize(n_layer);

		if(jacobian_type == JacobianType::Temperature)
		{
			#pragma omp parallel for
			for(int nl = 0; nl < n_layer; nl ++)
			{
				#pragma omp critical
				{
					std::cout << "Layer " << nl << std::endl;
				}
				
				AtmosphereModel atmosphere_model_plus;
				RadiativeTransfer rtm_plus;
				rtm_plus.configuration = cfg;
				rtm_plus.computeAtmosphericProperties(atmosphere_model_plus);
				double temperature_base = atmosphere_model_plus.layers[nl].temperature;
				atmosphere_model_plus.layers[nl].temperature *= (1.0 + delta);
				rtm_plus.computeSpeciesProperties(atmosphere_model_plus);
				rtm_plus.initializeGeometry();
				if(cfg.wavenumber_type == WavenumberType::Bandpass || cfg.wavelength_type == WavelengthType::Bandpass)
				{
					rtm_plus.runBandpass(atmosphere_model_plus);
				}
				else if(cfg.wavenumber_type == WavenumberType::Monochrome || cfg.wavelength_type == WavelengthType::Monochrome)
				{
					rtm_plus.configuration.is_instrument = false;
					rtm_plus.runSpectrum(atmosphere_model_plus);
				}

				AtmosphereModel atmosphere_model_minus;
				RadiativeTransfer rtm_minus;
				rtm_minus.configuration = cfg;
				rtm_minus.computeAtmosphericProperties(atmosphere_model_minus);
				atmosphere_model_minus.layers[nl].temperature *= (1.0 - delta);
				rtm_minus.computeSpeciesProperties(atmosphere_model_minus);
				rtm_minus.initializeGeometry();
				if(cfg.wavenumber_type == WavenumberType::Bandpass || cfg.wavelength_type == WavelengthType::Bandpass)
				{
					rtm_minus.runBandpass(atmosphere_model_minus);
				}
				else if(cfg.wavenumber_type == WavenumberType::Monochrome || cfg.wavelength_type == WavelengthType::Monochrome)
				{
					rtm_minus.configuration.is_instrument = false;
					rtm_minus.runSpectrum(atmosphere_model_minus);
				}

				if(nl == 0)
				{
					result.Ntheta = rtm_plus.Ntheta;
					result.Nphi = rtm_plus.Nphi;
					result.Nmode = rtm_plus.M;
					result.emission_zenith_angle = std::vector<double>(rtm_plus.geometry.theta_uh.data(), rtm_plus.geometry.theta_uh.data() + rtm_plus.geometry.theta_uh.size());
					result.incidence_zenith_angle = std::vector<double>(rtm_plus.geometry.theta_uh.data(), rtm_plus.geometry.theta_uh.data() + rtm_plus.geometry.theta_uh.size());
					result.emission_azimuth_angle = std::vector<double>(rtm_plus.geometry.phi.data(), rtm_plus.geometry.phi.data() + rtm_plus.geometry.phi.size());
				}

				result.altitude[nl] = atmosphere_model_plus.layers[nl].altitude;

				result.weighting_function_source_up[nl] = Eigen::VectorXd::Zero(rtm_plus.Ntheta);
				result.contribution_function_source_up[nl] = Eigen::VectorXd::Zero(rtm_plus.Ntheta);
				result.weighting_function_reflectance_top[nl] = std::vector<std::vector<std::vector<double>>>(rtm_plus.Ntheta, std::vector<std::vector<double>>(rtm_plus.Ntheta, std::vector<double>(rtm_plus.Nphi, 0.0)));
				result.contribution_function_reflectance_top[nl] = std::vector<std::vector<std::vector<double>>>(rtm_plus.Ntheta, std::vector<std::vector<double>>(rtm_plus.Ntheta, std::vector<double>(rtm_plus.Nphi, 0.0)));
				result.weighting_function_reflectance_m_top_cos[nl] = std::vector<Eigen::MatrixXd>(rtm_plus.M + 1, Eigen::MatrixXd::Zero(rtm_plus.Ntheta, rtm_plus.Ntheta));
				result.contribution_function_reflectance_m_top_cos[nl] = std::vector<Eigen::MatrixXd>(rtm_plus.M + 1, Eigen::MatrixXd::Zero(rtm_plus.Ntheta, rtm_plus.Ntheta));
				result.weighting_function_reflectance_m_top_sin[nl] = std::vector<Eigen::MatrixXd>(rtm_plus.M + 1, Eigen::MatrixXd::Zero(rtm_plus.Ntheta, rtm_plus.Ntheta));
				result.contribution_function_reflectance_m_top_sin[nl] = std::vector<Eigen::MatrixXd>(rtm_plus.M + 1, Eigen::MatrixXd::Zero(rtm_plus.Ntheta, rtm_plus.Ntheta));

				result.weighting_function_source_up[nl] = (rtm_plus.result.source_up[0] - rtm_minus.result.source_up[0]) / (2.0 * delta * temperature_base);
				result.contribution_function_source_up[nl] = (rtm_plus.result.source_up[0] - rtm_minus.result.source_up[0]) / (2.0 * delta * temperature_base) * temperature_base;

				for(int i = 0; i < rtm_plus.Ntheta; i ++)
				{
					for(int j = 0; j < rtm_plus.Ntheta; j ++)
					{
						for(int k = 0; k < rtm_plus.Nphi; k ++)
						{
							result.weighting_function_reflectance_top[nl][i][j][k] = (rtm_plus.result.reflectance_top[0][i][j][k] - rtm_minus.result.reflectance_top[0][i][j][k]) / (2.0 * delta * temperature_base);
							result.contribution_function_reflectance_top[nl][i][j][k] = (rtm_plus.result.reflectance_top[0][i][j][k] - rtm_minus.result.reflectance_top[0][i][j][k]) / (2.0 * delta * temperature_base) * temperature_base;
						}
					}
				}

				for(int i = 0; i <= rtm_plus.M; i ++)
				{
					result.weighting_function_reflectance_m_top_cos[nl][i] = (rtm_plus.result.reflectance_m_top_cos[0][i] - rtm_minus.result.reflectance_m_top_cos[0][i]) / (2.0 * delta * temperature_base);
					result.contribution_function_reflectance_m_top_cos[nl][i] = (rtm_plus.result.reflectance_m_top_cos[0][i] - rtm_minus.result.reflectance_m_top_cos[0][i]) / (2.0 * delta * temperature_base) * temperature_base;
					result.weighting_function_reflectance_m_top_sin[nl][i] = (rtm_plus.result.reflectance_m_top_sin[0][i] - rtm_minus.result.reflectance_m_top_sin[0][i]) / (2.0 * delta * temperature_base);
					result.contribution_function_reflectance_m_top_sin[nl][i] = (rtm_plus.result.reflectance_m_top_sin[0][i] - rtm_minus.result.reflectance_m_top_sin[0][i]) / (2.0 * delta * temperature_base) * temperature_base;
				}
			}
		}
		else if(jacobian_type == JacobianType::TotalNumberDensity)
		{
			#pragma omp parallel for
			for(int nl = 0; nl < n_layer; nl ++)
			{
				#pragma omp critical
				{
					std::cout << "Layer " << nl << std::endl;
				}
				
				AtmosphereModel atmosphere_model_plus;
				RadiativeTransfer rtm_plus;
				rtm_plus.configuration = cfg;
				rtm_plus.computeAtmosphericProperties(atmosphere_model_plus);
				double number_density_base = atmosphere_model_plus.layers[nl].number_density;
				atmosphere_model_plus.layers[nl].number_density *= (1.0 + delta);
				rtm_plus.computeSpeciesProperties(atmosphere_model_plus);
				rtm_plus.initializeGeometry();
				if(cfg.wavenumber_type == WavenumberType::Bandpass || cfg.wavelength_type == WavelengthType::Bandpass)
				{
					rtm_plus.runBandpass(atmosphere_model_plus);
				}
				else if(cfg.wavenumber_type == WavenumberType::Monochrome || cfg.wavelength_type == WavelengthType::Monochrome)
				{
					rtm_plus.configuration.is_instrument = false;
					rtm_plus.runSpectrum(atmosphere_model_plus);
				}

				AtmosphereModel atmosphere_model_minus;
				RadiativeTransfer rtm_minus;
				rtm_minus.configuration = cfg;
				rtm_minus.computeAtmosphericProperties(atmosphere_model_minus);
				atmosphere_model_minus.layers[nl].number_density *= (1.0 - delta);
				rtm_minus.computeSpeciesProperties(atmosphere_model_minus);
				rtm_minus.initializeGeometry();
				if(cfg.wavenumber_type == WavenumberType::Bandpass || cfg.wavelength_type == WavelengthType::Bandpass)
				{
					rtm_minus.runBandpass(atmosphere_model_minus);
				}
				else if(cfg.wavenumber_type == WavenumberType::Monochrome || cfg.wavelength_type == WavelengthType::Monochrome)
				{
					rtm_minus.configuration.is_instrument = false;
					rtm_minus.runSpectrum(atmosphere_model_minus);
				}

				if(nl == 0)
				{
					result.Ntheta = rtm_plus.Ntheta;
					result.Nphi = rtm_plus.Nphi;
					result.Nmode = rtm_plus.M;
					result.emission_zenith_angle = std::vector<double>(rtm_plus.geometry.theta_uh.data(), rtm_plus.geometry.theta_uh.data() + rtm_plus.geometry.theta_uh.size());
					result.incidence_zenith_angle = std::vector<double>(rtm_plus.geometry.theta_uh.data(), rtm_plus.geometry.theta_uh.data() + rtm_plus.geometry.theta_uh.size());
					result.emission_azimuth_angle = std::vector<double>(rtm_plus.geometry.phi.data(), rtm_plus.geometry.phi.data() + rtm_plus.geometry.phi.size());
				}

				result.altitude[nl] = atmosphere_model_plus.layers[nl].altitude;

				result.weighting_function_source_up[nl] = Eigen::VectorXd::Zero(rtm_plus.Ntheta);
				result.contribution_function_source_up[nl] = Eigen::VectorXd::Zero(rtm_plus.Ntheta);
				result.weighting_function_reflectance_top[nl] = std::vector<std::vector<std::vector<double>>>(rtm_plus.Ntheta, std::vector<std::vector<double>>(rtm_plus.Ntheta, std::vector<double>(rtm_plus.Nphi, 0.0)));
				result.contribution_function_reflectance_top[nl] = std::vector<std::vector<std::vector<double>>>(rtm_plus.Ntheta, std::vector<std::vector<double>>(rtm_plus.Ntheta, std::vector<double>(rtm_plus.Nphi, 0.0)));
				result.weighting_function_reflectance_m_top_cos[nl] = std::vector<Eigen::MatrixXd>(rtm_plus.M + 1, Eigen::MatrixXd::Zero(rtm_plus.Ntheta, rtm_plus.Ntheta));
				result.contribution_function_reflectance_m_top_cos[nl] = std::vector<Eigen::MatrixXd>(rtm_plus.M + 1, Eigen::MatrixXd::Zero(rtm_plus.Ntheta, rtm_plus.Ntheta));
				result.weighting_function_reflectance_m_top_sin[nl] = std::vector<Eigen::MatrixXd>(rtm_plus.M + 1, Eigen::MatrixXd::Zero(rtm_plus.Ntheta, rtm_plus.Ntheta));
				result.contribution_function_reflectance_m_top_sin[nl] = std::vector<Eigen::MatrixXd>(rtm_plus.M + 1, Eigen::MatrixXd::Zero(rtm_plus.Ntheta, rtm_plus.Ntheta));

				result.weighting_function_source_up[nl] = (rtm_plus.result.source_up[0] - rtm_minus.result.source_up[0]) / (2.0 * delta * number_density_base);
				result.contribution_function_source_up[nl] = (rtm_plus.result.source_up[0] - rtm_minus.result.source_up[0]) / (2.0 * delta * number_density_base) * number_density_base;

				for(int i = 0; i < rtm_plus.Ntheta; i ++)
				{
					for(int j = 0; j < rtm_plus.Ntheta; j ++)
					{
						for(int k = 0; k < rtm_plus.Nphi; k ++)
						{
							result.weighting_function_reflectance_top[nl][i][j][k] = (rtm_plus.result.reflectance_top[0][i][j][k] - rtm_minus.result.reflectance_top[0][i][j][k]) / (2.0 * delta * number_density_base);
							result.contribution_function_reflectance_top[nl][i][j][k] = (rtm_plus.result.reflectance_top[0][i][j][k] - rtm_minus.result.reflectance_top[0][i][j][k]) / (2.0 * delta * number_density_base) * number_density_base;
						}
					}
				}

				for(int i = 0; i <= rtm_plus.M; i ++)
				{
					result.weighting_function_reflectance_m_top_cos[nl][i] = (rtm_plus.result.reflectance_m_top_cos[0][i] - rtm_minus.result.reflectance_m_top_cos[0][i]) / (2.0 * delta * number_density_base);
					result.contribution_function_reflectance_m_top_cos[nl][i] = (rtm_plus.result.reflectance_m_top_cos[0][i] - rtm_minus.result.reflectance_m_top_cos[0][i]) / (2.0 * delta * number_density_base) * number_density_base;
					result.weighting_function_reflectance_m_top_sin[nl][i] = (rtm_plus.result.reflectance_m_top_sin[0][i] - rtm_minus.result.reflectance_m_top_sin[0][i]) / (2.0 * delta * number_density_base);
					result.contribution_function_reflectance_m_top_sin[nl][i] = (rtm_plus.result.reflectance_m_top_sin[0][i] - rtm_minus.result.reflectance_m_top_sin[0][i]) / (2.0 * delta * number_density_base) * number_density_base;
				}
			}
		}
		else if(jacobian_type == JacobianType::SpeciesNumberDensity)
		{
			#pragma omp parallel for
			for(int nl = 0; nl < n_layer; nl ++)
			{
				#pragma omp critical
				{
					std::cout << "Layer " << nl << std::endl;
				}
				
				AtmosphereModel atmosphere_model_plus;
				RadiativeTransfer rtm_plus;
				rtm_plus.configuration = cfg;
				rtm_plus.computeAtmosphericProperties(atmosphere_model_plus);
				rtm_plus.computeSpeciesProperties(atmosphere_model_plus);
				double number_density_base = atmosphere_model_plus.layers[nl].number_density_species[n_species];
				atmosphere_model_plus.layers[nl].number_density_species[n_species] *= (1.0 + delta);
				rtm_plus.initializeGeometry();
				if(cfg.wavenumber_type == WavenumberType::Bandpass || cfg.wavelength_type == WavelengthType::Bandpass)
				{
					rtm_plus.runBandpass(atmosphere_model_plus);
				}
				else if(cfg.wavenumber_type == WavenumberType::Monochrome || cfg.wavelength_type == WavelengthType::Monochrome)
				{
					rtm_plus.configuration.is_instrument = false;
					rtm_plus.runSpectrum(atmosphere_model_plus);
				}

				AtmosphereModel atmosphere_model_minus;
				RadiativeTransfer rtm_minus;
				rtm_minus.configuration = cfg;
				rtm_minus.computeAtmosphericProperties(atmosphere_model_minus);
				rtm_minus.computeSpeciesProperties(atmosphere_model_minus);
				atmosphere_model_minus.layers[nl].number_density_species[n_species] *= (1.0 - delta);
				rtm_minus.initializeGeometry();
				if(cfg.wavenumber_type == WavenumberType::Bandpass || cfg.wavelength_type == WavelengthType::Bandpass)
				{
					rtm_minus.runBandpass(atmosphere_model_minus);
				}
				else if(cfg.wavenumber_type == WavenumberType::Monochrome || cfg.wavelength_type == WavelengthType::Monochrome)
				{
					rtm_minus.configuration.is_instrument = false;
					rtm_minus.runSpectrum(atmosphere_model_minus);
				}

				if(nl == 0)
				{
					result.Ntheta = rtm_plus.Ntheta;
					result.Nphi = rtm_plus.Nphi;
					result.Nmode = rtm_plus.M;
					result.emission_zenith_angle = std::vector<double>(rtm_plus.geometry.theta_uh.data(), rtm_plus.geometry.theta_uh.data() + rtm_plus.geometry.theta_uh.size());
					result.incidence_zenith_angle = std::vector<double>(rtm_plus.geometry.theta_uh.data(), rtm_plus.geometry.theta_uh.data() + rtm_plus.geometry.theta_uh.size());
					result.emission_azimuth_angle = std::vector<double>(rtm_plus.geometry.phi.data(), rtm_plus.geometry.phi.data() + rtm_plus.geometry.phi.size());
				}

				result.altitude[nl] = atmosphere_model_plus.layers[nl].altitude;

				result.weighting_function_source_up[nl] = Eigen::VectorXd::Zero(rtm_plus.Ntheta);
				result.contribution_function_source_up[nl] = Eigen::VectorXd::Zero(rtm_plus.Ntheta);
				result.weighting_function_reflectance_top[nl] = std::vector<std::vector<std::vector<double>>>(rtm_plus.Ntheta, std::vector<std::vector<double>>(rtm_plus.Ntheta, std::vector<double>(rtm_plus.Nphi, 0.0)));
				result.contribution_function_reflectance_top[nl] = std::vector<std::vector<std::vector<double>>>(rtm_plus.Ntheta, std::vector<std::vector<double>>(rtm_plus.Ntheta, std::vector<double>(rtm_plus.Nphi, 0.0)));
				result.weighting_function_reflectance_m_top_cos[nl] = std::vector<Eigen::MatrixXd>(rtm_plus.M + 1, Eigen::MatrixXd::Zero(rtm_plus.Ntheta, rtm_plus.Ntheta));
				result.contribution_function_reflectance_m_top_cos[nl] = std::vector<Eigen::MatrixXd>(rtm_plus.M + 1, Eigen::MatrixXd::Zero(rtm_plus.Ntheta, rtm_plus.Ntheta));
				result.weighting_function_reflectance_m_top_sin[nl] = std::vector<Eigen::MatrixXd>(rtm_plus.M + 1, Eigen::MatrixXd::Zero(rtm_plus.Ntheta, rtm_plus.Ntheta));
				result.contribution_function_reflectance_m_top_sin[nl] = std::vector<Eigen::MatrixXd>(rtm_plus.M + 1, Eigen::MatrixXd::Zero(rtm_plus.Ntheta, rtm_plus.Ntheta));

				result.weighting_function_source_up[nl] = (rtm_plus.result.source_up[0] - rtm_minus.result.source_up[0]) / (2.0 * delta * number_density_base);
				result.contribution_function_source_up[nl] = (rtm_plus.result.source_up[0] - rtm_minus.result.source_up[0]) / (2.0 * delta * number_density_base) * number_density_base;

				for(int i = 0; i < rtm_plus.Ntheta; i ++)
				{
					for(int j = 0; j < rtm_plus.Ntheta; j ++)
					{
						for(int k = 0; k < rtm_plus.Nphi; k ++)
						{
							result.weighting_function_reflectance_top[nl][i][j][k] = (rtm_plus.result.reflectance_top[0][i][j][k] - rtm_minus.result.reflectance_top[0][i][j][k]) / (2.0 * delta * number_density_base);
							result.contribution_function_reflectance_top[nl][i][j][k] = (rtm_plus.result.reflectance_top[0][i][j][k] - rtm_minus.result.reflectance_top[0][i][j][k]) / (2.0 * delta * number_density_base) * number_density_base;
						}
					}
				}

				for(int i = 0; i <= rtm_plus.M; i ++)
				{
					result.weighting_function_reflectance_m_top_cos[nl][i] = (rtm_plus.result.reflectance_m_top_cos[0][i] - rtm_minus.result.reflectance_m_top_cos[0][i]) / (2.0 * delta * number_density_base);
					result.contribution_function_reflectance_m_top_cos[nl][i] = (rtm_plus.result.reflectance_m_top_cos[0][i] - rtm_minus.result.reflectance_m_top_cos[0][i]) / (2.0 * delta * number_density_base) * number_density_base;
					result.weighting_function_reflectance_m_top_sin[nl][i] = (rtm_plus.result.reflectance_m_top_sin[0][i] - rtm_minus.result.reflectance_m_top_sin[0][i]) / (2.0 * delta * number_density_base);
					result.contribution_function_reflectance_m_top_sin[nl][i] = (rtm_plus.result.reflectance_m_top_sin[0][i] - rtm_minus.result.reflectance_m_top_sin[0][i]) / (2.0 * delta * number_density_base) * number_density_base;
				}
			}
		}
		else if(jacobian_type == JacobianType::SpeciesMixingRatio)
		{
			#pragma omp parallel for
			for(int nl = 0; nl < n_layer; nl ++)
			{
				#pragma omp critical
				{
					std::cout << "Layer " << nl << std::endl;
				}
				
				AtmosphereModel atmosphere_model_plus;
				RadiativeTransfer rtm_plus;
				rtm_plus.configuration = cfg;
				rtm_plus.computeAtmosphericProperties(atmosphere_model_plus);
				rtm_plus.computeSpeciesProperties(atmosphere_model_plus);
				double mixing_ratio_base = atmosphere_model_plus.layers[nl].mixing_ratio_species[n_species];
				atmosphere_model_plus.layers[nl].mixing_ratio_species[n_species] *= (1.0 + delta);
				atmosphere_model_plus.layers[nl].number_density_species[n_species] = atmosphere_model_plus.layers[nl].number_density * atmosphere_model_plus.layers[nl].mixing_ratio_species[n_species];
				rtm_plus.initializeGeometry();
				if(cfg.wavenumber_type == WavenumberType::Bandpass || cfg.wavelength_type == WavelengthType::Bandpass)
				{
					rtm_plus.runBandpass(atmosphere_model_plus);
				}
				else if(cfg.wavenumber_type == WavenumberType::Monochrome || cfg.wavelength_type == WavelengthType::Monochrome)
				{
					rtm_plus.configuration.is_instrument = false;
					rtm_plus.runSpectrum(atmosphere_model_plus);
				}

				AtmosphereModel atmosphere_model_minus;
				RadiativeTransfer rtm_minus;
				rtm_minus.configuration = cfg;
				rtm_minus.computeAtmosphericProperties(atmosphere_model_minus);
				rtm_minus.computeSpeciesProperties(atmosphere_model_minus);
				atmosphere_model_minus.layers[nl].mixing_ratio_species[n_species] *= (1.0 - delta);
				atmosphere_model_minus.layers[nl].number_density_species[n_species] = atmosphere_model_minus.layers[nl].number_density * atmosphere_model_minus.layers[nl].mixing_ratio_species[n_species];
				rtm_minus.initializeGeometry();
				if(cfg.wavenumber_type == WavenumberType::Bandpass || cfg.wavelength_type == WavelengthType::Bandpass)
				{
					rtm_minus.runBandpass(atmosphere_model_minus);
				}
				else if(cfg.wavenumber_type == WavenumberType::Monochrome || cfg.wavelength_type == WavelengthType::Monochrome)
				{
					rtm_minus.configuration.is_instrument = false;
					rtm_minus.runSpectrum(atmosphere_model_minus);
				}

				if(nl == 0)
				{
					result.Ntheta = rtm_plus.Ntheta;
					result.Nphi = rtm_plus.Nphi;
					result.Nmode = rtm_plus.M;
					result.emission_zenith_angle = std::vector<double>(rtm_plus.geometry.theta_uh.data(), rtm_plus.geometry.theta_uh.data() + rtm_plus.geometry.theta_uh.size());
					result.incidence_zenith_angle = std::vector<double>(rtm_plus.geometry.theta_uh.data(), rtm_plus.geometry.theta_uh.data() + rtm_plus.geometry.theta_uh.size());
					result.emission_azimuth_angle = std::vector<double>(rtm_plus.geometry.phi.data(), rtm_plus.geometry.phi.data() + rtm_plus.geometry.phi.size());
				}

				result.altitude[nl] = atmosphere_model_plus.layers[nl].altitude;

				result.weighting_function_source_up[nl] = Eigen::VectorXd::Zero(rtm_plus.Ntheta);
				result.contribution_function_source_up[nl] = Eigen::VectorXd::Zero(rtm_plus.Ntheta);
				result.weighting_function_reflectance_top[nl] = std::vector<std::vector<std::vector<double>>>(rtm_plus.Ntheta, std::vector<std::vector<double>>(rtm_plus.Ntheta, std::vector<double>(rtm_plus.Nphi, 0.0)));
				result.contribution_function_reflectance_top[nl] = std::vector<std::vector<std::vector<double>>>(rtm_plus.Ntheta, std::vector<std::vector<double>>(rtm_plus.Ntheta, std::vector<double>(rtm_plus.Nphi, 0.0)));
				result.weighting_function_reflectance_m_top_cos[nl] = std::vector<Eigen::MatrixXd>(rtm_plus.M + 1, Eigen::MatrixXd::Zero(rtm_plus.Ntheta, rtm_plus.Ntheta));
				result.contribution_function_reflectance_m_top_cos[nl] = std::vector<Eigen::MatrixXd>(rtm_plus.M + 1, Eigen::MatrixXd::Zero(rtm_plus.Ntheta, rtm_plus.Ntheta));
				result.weighting_function_reflectance_m_top_sin[nl] = std::vector<Eigen::MatrixXd>(rtm_plus.M + 1, Eigen::MatrixXd::Zero(rtm_plus.Ntheta, rtm_plus.Ntheta));
				result.contribution_function_reflectance_m_top_sin[nl] = std::vector<Eigen::MatrixXd>(rtm_plus.M + 1, Eigen::MatrixXd::Zero(rtm_plus.Ntheta, rtm_plus.Ntheta));

				result.weighting_function_source_up[nl] = (rtm_plus.result.source_up[0] - rtm_minus.result.source_up[0]) / (2.0 * delta * mixing_ratio_base);
				result.contribution_function_source_up[nl] = (rtm_plus.result.source_up[0] - rtm_minus.result.source_up[0]) / (2.0 * delta * mixing_ratio_base) * mixing_ratio_base;

				for(int i = 0; i < rtm_plus.Ntheta; i ++)
				{
					for(int j = 0; j < rtm_plus.Ntheta; j ++)
					{
						for(int k = 0; k < rtm_plus.Nphi; k ++)
						{
							result.weighting_function_reflectance_top[nl][i][j][k] = (rtm_plus.result.reflectance_top[0][i][j][k] - rtm_minus.result.reflectance_top[0][i][j][k]) / (2.0 * delta * mixing_ratio_base);
							result.contribution_function_reflectance_top[nl][i][j][k] = (rtm_plus.result.reflectance_top[0][i][j][k] - rtm_minus.result.reflectance_top[0][i][j][k]) / (2.0 * delta * mixing_ratio_base) * mixing_ratio_base;
						}
					}
				}

				for(int i = 0; i <= rtm_plus.M; i ++)
				{
					result.weighting_function_reflectance_m_top_cos[nl][i] = (rtm_plus.result.reflectance_m_top_cos[0][i] - rtm_minus.result.reflectance_m_top_cos[0][i]) / (2.0 * delta * mixing_ratio_base);
					result.contribution_function_reflectance_m_top_cos[nl][i] = (rtm_plus.result.reflectance_m_top_cos[0][i] - rtm_minus.result.reflectance_m_top_cos[0][i]) / (2.0 * delta * mixing_ratio_base) * mixing_ratio_base;
					result.weighting_function_reflectance_m_top_sin[nl][i] = (rtm_plus.result.reflectance_m_top_sin[0][i] - rtm_minus.result.reflectance_m_top_sin[0][i]) / (2.0 * delta * mixing_ratio_base);
					result.contribution_function_reflectance_m_top_sin[nl][i] = (rtm_plus.result.reflectance_m_top_sin[0][i] - rtm_minus.result.reflectance_m_top_sin[0][i]) / (2.0 * delta * mixing_ratio_base) * mixing_ratio_base;
				}
			}
		}
	}

	return result;
}

inline JacobianResult computeJacobianRefractiveIndex(std::string config_filename, std::vector<int> n_species, double delta = 0.01)
{
	JacobianResult result;

	Configuration cfg;

	try
	{
		cfg.importConfiguration(config_filename);
	}
	catch(const std::exception &e)
	{
		std::cerr << "Configuration import failed: " << e.what() << std::endl;
	}

	if((cfg.wavenumber_type == WavenumberType::Spectrum) || (cfg.wavenumber_type == WavenumberType::Spectrum) || (cfg.wavenumber_type == WavenumberType::Table) || (cfg.wavenumber_type == WavenumberType::Table))
	{
		throw std::runtime_error("Use monochrome or bandpass for the jacobian calculations.");
	}
	else
	{
		int n_layer;

		if(cfg.z_edge.size() > 0)
		{
			n_layer = cfg.z_edge.size() - 1;
		}
		else if(cfg.z_center.size() > 0)
		{
			n_layer = cfg.z_center.size();
		}
		else
		{
			std::cout << cfg.z_edge.size() << ", " << cfg.z_center.size() << std::endl;
			throw std::runtime_error("Altitude coordinate not specified.");
		}

		result.initialize(n_layer);

		//results.resize(n_layer);

		#pragma omp parallel for
		for(int nl = 0; nl < n_layer; nl ++)
		{
			#pragma omp critical
			{
				std::cout << "Layer " << nl << std::endl;
			}
			
			AtmosphereModel atmosphere_model_plus;
			RadiativeTransfer rtm_plus;
			rtm_plus.configuration = cfg;
			rtm_plus.computeAtmosphericProperties(atmosphere_model_plus);
			rtm_plus.computeSpeciesProperties(atmosphere_model_plus);
			double ni_base = atmosphere_model_plus.species[n_species[0]].ni;

			for(int i = 0; i < n_species.size(); i ++)
			{
				atmosphere_model_plus.species.push_back(atmosphere_model_plus.species[n_species[i]]);
				atmosphere_model_plus.species[atmosphere_model_plus.species.size() - 1].ni = ni_base * (1.0 + delta);

				for(int j = 0; j < n_layer; j ++)
				{
					if(j != nl)
					{
						atmosphere_model_plus.layers[j].mixing_ratio_species[atmosphere_model_plus.species.size() - 1] = 0.0;
						atmosphere_model_plus.layers[j].number_density_species[atmosphere_model_plus.species.size() - 1] = 0.0;
					}
				}

				atmosphere_model_plus.layers[nl].mixing_ratio_species[n_species[i]] = 0.0;
				atmosphere_model_plus.layers[nl].number_density_species[n_species[i]] = 0.0;
			}
			
			// atmosphere_model_plus.layers[nl].mixing_ratio_species[n_species] *= (1.0 + delta);
			// atmosphere_model_plus.layers[nl].number_density_species[n_species] = atmosphere_model_plus.layers[nl].number_density * atmosphere_model_plus.layers[nl].mixing_ratio_species[n_species];
			rtm_plus.initializeGeometry();
			if(cfg.wavenumber_type == WavenumberType::Bandpass || cfg.wavelength_type == WavelengthType::Bandpass)
			{
				rtm_plus.runBandpass(atmosphere_model_plus);
			}
			else if(cfg.wavenumber_type == WavenumberType::Monochrome || cfg.wavelength_type == WavelengthType::Monochrome)
			{
				rtm_plus.configuration.is_instrument = false;
				rtm_plus.runSpectrum(atmosphere_model_plus);
			}

			AtmosphereModel atmosphere_model_minus;
			RadiativeTransfer rtm_minus;
			rtm_minus.configuration = cfg;
			rtm_minus.computeAtmosphericProperties(atmosphere_model_minus);
			rtm_minus.computeSpeciesProperties(atmosphere_model_minus);
			
			for(int i = 0; i < n_species.size(); i ++)
			{
				atmosphere_model_minus.species.push_back(atmosphere_model_minus.species[n_species[i]]);
				atmosphere_model_minus.species[atmosphere_model_minus.species.size() - 1].ni = ni_base * (1.0 - delta);

				for(int j = 0; j < n_layer; j ++)
				{
					if(j != nl)
					{
						atmosphere_model_minus.layers[j].mixing_ratio_species[atmosphere_model_minus.species.size() - 1] = 0.0;
						atmosphere_model_minus.layers[j].number_density_species[atmosphere_model_minus.species.size() - 1] = 0.0;
					}
				}

				atmosphere_model_minus.layers[nl].mixing_ratio_species[n_species[i]] = 0.0;
				atmosphere_model_minus.layers[nl].number_density_species[n_species[i]] = 0.0;
			}

			// atmosphere_model_minus.layers[nl].mixing_ratio_species[n_species] *= (1.0 - delta);
			// atmosphere_model_minus.layers[nl].number_density_species[n_species] = atmosphere_model_minus.layers[nl].number_density * atmosphere_model_minus.layers[nl].mixing_ratio_species[n_species];
			rtm_minus.initializeGeometry();
			if(cfg.wavenumber_type == WavenumberType::Bandpass || cfg.wavelength_type == WavelengthType::Bandpass)
			{
				rtm_minus.runBandpass(atmosphere_model_minus);
			}
			else if(cfg.wavenumber_type == WavenumberType::Monochrome || cfg.wavelength_type == WavelengthType::Monochrome)
			{
				rtm_minus.configuration.is_instrument = false;
				rtm_minus.runSpectrum(atmosphere_model_minus);
			}

			if(nl == 0)
			{
				result.Ntheta = rtm_plus.Ntheta;
				result.Nphi = rtm_plus.Nphi;
				result.Nmode = rtm_plus.M;
				result.emission_zenith_angle = std::vector<double>(rtm_plus.geometry.theta_uh.data(), rtm_plus.geometry.theta_uh.data() + rtm_plus.geometry.theta_uh.size());
				result.incidence_zenith_angle = std::vector<double>(rtm_plus.geometry.theta_uh.data(), rtm_plus.geometry.theta_uh.data() + rtm_plus.geometry.theta_uh.size());
				result.emission_azimuth_angle = std::vector<double>(rtm_plus.geometry.phi.data(), rtm_plus.geometry.phi.data() + rtm_plus.geometry.phi.size());
			}

			result.altitude[nl] = atmosphere_model_plus.layers[nl].altitude;

			result.weighting_function_source_up[nl] = Eigen::VectorXd::Zero(rtm_plus.Ntheta);
			result.contribution_function_source_up[nl] = Eigen::VectorXd::Zero(rtm_plus.Ntheta);
			result.weighting_function_reflectance_top[nl] = std::vector<std::vector<std::vector<double>>>(rtm_plus.Ntheta, std::vector<std::vector<double>>(rtm_plus.Ntheta, std::vector<double>(rtm_plus.Nphi, 0.0)));
			result.contribution_function_reflectance_top[nl] = std::vector<std::vector<std::vector<double>>>(rtm_plus.Ntheta, std::vector<std::vector<double>>(rtm_plus.Ntheta, std::vector<double>(rtm_plus.Nphi, 0.0)));
			result.weighting_function_reflectance_m_top_cos[nl] = std::vector<Eigen::MatrixXd>(rtm_plus.M + 1, Eigen::MatrixXd::Zero(rtm_plus.Ntheta, rtm_plus.Ntheta));
			result.contribution_function_reflectance_m_top_cos[nl] = std::vector<Eigen::MatrixXd>(rtm_plus.M + 1, Eigen::MatrixXd::Zero(rtm_plus.Ntheta, rtm_plus.Ntheta));
			result.weighting_function_reflectance_m_top_sin[nl] = std::vector<Eigen::MatrixXd>(rtm_plus.M + 1, Eigen::MatrixXd::Zero(rtm_plus.Ntheta, rtm_plus.Ntheta));
			result.contribution_function_reflectance_m_top_sin[nl] = std::vector<Eigen::MatrixXd>(rtm_plus.M + 1, Eigen::MatrixXd::Zero(rtm_plus.Ntheta, rtm_plus.Ntheta));

			result.weighting_function_source_up[nl] = (rtm_plus.result.source_up[0] - rtm_minus.result.source_up[0]) / (2.0 * delta * ni_base);
			result.contribution_function_source_up[nl] = (rtm_plus.result.source_up[0] - rtm_minus.result.source_up[0]) / (2.0 * delta * ni_base) * ni_base;

			for(int i = 0; i < rtm_plus.Ntheta; i ++)
			{
				for(int j = 0; j < rtm_plus.Ntheta; j ++)
				{
					for(int k = 0; k < rtm_plus.Nphi; k ++)
					{
						result.weighting_function_reflectance_top[nl][i][j][k] = (rtm_plus.result.reflectance_top[0][i][j][k] - rtm_minus.result.reflectance_top[0][i][j][k]) / (2.0 * delta * ni_base);
						result.contribution_function_reflectance_top[nl][i][j][k] = (rtm_plus.result.reflectance_top[0][i][j][k] - rtm_minus.result.reflectance_top[0][i][j][k]) / (2.0 * delta * ni_base) * ni_base;
					}
				}
			}

			for(int i = 0; i <= rtm_plus.M; i ++)
			{
				result.weighting_function_reflectance_m_top_cos[nl][i] = (rtm_plus.result.reflectance_m_top_cos[0][i] - rtm_minus.result.reflectance_m_top_cos[0][i]) / (2.0 * delta * ni_base);
				result.contribution_function_reflectance_m_top_cos[nl][i] = (rtm_plus.result.reflectance_m_top_cos[0][i] - rtm_minus.result.reflectance_m_top_cos[0][i]) / (2.0 * delta * ni_base) * ni_base;
				result.weighting_function_reflectance_m_top_sin[nl][i] = (rtm_plus.result.reflectance_m_top_sin[0][i] - rtm_minus.result.reflectance_m_top_sin[0][i]) / (2.0 * delta * ni_base);
				result.contribution_function_reflectance_m_top_sin[nl][i] = (rtm_plus.result.reflectance_m_top_sin[0][i] - rtm_minus.result.reflectance_m_top_sin[0][i]) / (2.0 * delta * ni_base) * ni_base;
			}
		}
	}

	return result;
}


}