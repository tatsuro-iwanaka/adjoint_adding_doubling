#pragma once

#include <complex>
#include <random>
#include <filesystem>
#include <fstream>
#include <omp.h>
#include <iomanip>
#include <thread>
#include <chrono>
#include <netcdf>
#include <cmath>
#include <vector>

#include <ctime>
#include <sstream>

#include <Eigen/Dense>

#include"constants"
#include"types"
#include"atmosphere"
#include"configuration"
#include"solver"
#include"export"
#include"geometry"
#include"utilities"

namespace radiative_transfer
{

inline void OpticalLayer::clear(void)
{
	scattering_phase_function.clear();	//angle (radian), magnitude (dimensionless)
	is_scattering_species.clear();
	species_scattering_phase_function.clear(); // species, scattering_angle
	species_absorption_cross_section.clear(); // species
	species_scattering_cross_section.clear();

	return;
}

inline void RadiativeLayer::clear(void)
{
	reflectance_m_top_cos.clear();
	reflectance_m_bottom_cos.clear();
	transmittance_m_top_cos.clear();
	transmittance_m_bottom_cos.clear();

	reflectance_m_top_sin.clear();
	reflectance_m_bottom_sin.clear();
	transmittance_m_top_sin.clear();
	transmittance_m_bottom_sin.clear();

	source_up.resize(0, 0);
	source_down.resize(0, 0);

	return;
}

inline RadiativeTransferSolver::RadiativeTransferSolver()
{
	return;
}

inline RadiativeTransferSolver::RadiativeTransferSolver(const Geometry& geometry_input)
{
	geometry(geometry_);
}

inline void RadiativeTransferSolver::geometry(const Geometry& geometry_input)
{
	geometry_ = geometry_input;
}

inline void RadiativeTransferSolver::delta_approximation(const DeltaApproximation& delta_approximation_input)
{
	delta_approximation_ = delta_approximation_input;
}

inline MonochromeData RadiativeTransferSolver::computeMonochrome(const AtmosphereModel& atmosphere_model, double spectral, SpectralCoordinateDimension dimension, double initial_optical_thickness = 1.0E-6, int n_scattering_angle = 1001)
{
	initial_optical_thickness_ = initial_optical_thickness;
	n_scattering_angle_ = n_scattering_angle;

	double wavelength;
	double wavenumber;

	if(dimension == SpectralCoordinateDimension::Wavenumber)
	{
		wavelength = 1.0 / spectral;
		wavenumber = spectral;
	}
	else if(dimension == SpectralCoordinateDimension::Wavelength)
	{
		wavelength = spectral;
		wavenumber = 1.0 / spectral;
	}
	else
	{
		logger::global().fatal("RadiativeTransferCalculator::computeMonochrome") << "Frequency calculation is not currently supported.";
		throw std::runtime_error("[RadiativeTransferCalculator::computeMonochrome] Frequency calculation is not currently supported.");
	}

	int n_layer = atmosphere_model.altitude.size();

	logger::global().info("RadiativeTransferSolver::computeMonochrome") << "Setting atmosphere condition for " << spectral << (dimension == SpectralCoordinateDimension::Wavenumber ? "m-1" : "m") << ".";
	
	auto atmosphere_layer_opt = setAtmosphericLayerCondition_(atmosphere_model, spectral, dimension);
	std::vector<RadiativeLayer> atmosphere_layer_rad(n_layer);
	RadiativeLayer result_layer_rad;

	MonochromeData result;
	result.absorption_coefficient.resize(n_layer);
	result.scattering_coefficient.resize(n_layer);
	result.optical_thickness.resize(n_layer);
	result.single_scattering_albedo.resize(n_layer);
	result.asymmetry_parameter.resize(n_layer);

	result.scattering_phase_function.resize(n_layer);
	result.species_absorption_cross_section.resize(n_layer);
	result.species_scattering_cross_section.resize(n_layer);
	result.species_scattering_phase_function.resize(n_layer);
	result.is_scattering_species = atmosphere_layer_opt[0].is_scattering_species;

	logger::global().info("RadiativeTransferSolver::computeMonochrome") << "Setting surface condition for " << spectral << (dimension == SpectralCoordinateDimension::Wavenumber ? "m-1" : "m") << ".";

	if(atmosphere_model.surface_type != SurfaceType::NoSurface)
	{
		auto surface_layer_opt = setSurfaceLayerCondition_(atmosphere_model, spectral, dimension);
		result_layer_rad = initializeSurfaceLayer_(surface_layer_opt);
	}

	for(int i = 0; i < n_layer; ++i)
	{
		atmosphere_layer_rad[i] = initializeAtmosphericLayer_(atmosphere_layer_opt[i]);
		computeDeltaApproximation_(atmosphere_layer_opt[i]);

		result.absorption_coefficient[i] = atmosphere_layer_opt[i].absorption_coefficient;
		result.scattering_coefficient[i] = atmosphere_layer_opt[i].scattering_coefficient;
		result.optical_thickness[i] = atmosphere_layer_opt[i].optical_thickness;
		result.single_scattering_albedo[i] = atmosphere_layer_opt[i].single_scattering_albedo;
		result.asymmetry_parameter[i] = atmosphere_layer_opt[i].asymmetry_parameter;

		result.scattering_phase_function[i] = atmosphere_layer_opt[i].scattering_phase_function;
		result.species_absorption_cross_section[i] = atmosphere_layer_opt[i].species_absorption_cross_section;
		result.species_scattering_cross_section[i] = atmosphere_layer_opt[i].species_scattering_cross_section;
		result.species_scattering_phase_function[i] = atmosphere_layer_opt[i].species_scattering_phase_function;

		int n_doubling = atmosphere_layer_rad[i].n_doubling;

		logger::global().info("RadiativeTransferSolver::computeMonochrome") << "Doubling layer " << i << " for " << spectral << (dimension == SpectralCoordinateDimension::Wavenumber ? "m-1" : "m") << ".";
		
		for(int j = 0; j < n_doubling; ++j)
		{
			atmosphere_layer_rad[i] = doubleLayer(atmosphere_layer_rad[i], geometry_);
			// doubling;
		}

		logger::global().info("RadiativeTransferSolver::computeMonochrome") << "Adding layer " << i << " for " << spectral << (dimension == SpectralCoordinateDimension::Wavenumber ? "m-1" : "m") << ".";
		
		if(atmosphere_model.surface_type == SurfaceType::NoSurface && i == 0)
		{
			result_layer_rad = atmosphere_layer_rad[i];
		}
		else
		{
			result_layer_rad = addLayer(result_layer_rad, atmosphere_layer_rad[i], geometry_);
		}

		atmosphere_layer_rad[i].clear();
		atmosphere_layer_opt[i].clear();
	}

	result.reflectance_m_top_cos = result_layer_rad.reflectance_m_top_cos;
	result.reflectance_m_top_sin = result_layer_rad.reflectance_m_top_sin;
	result.source_up = result_layer_rad.source_up;

	return result;
}

inline void RadiativeTransferSolver::computeDeltaApproximation_(OpticalLayer& layer)
{
	if (delta_approximation_.delta_approximation_type == DeltaApproximationType::Disable)
	{
		return;
	}
	
	const auto& P = layer.scattering_phase_function;
	if (P.empty()) return;

	// --- 1. モーメント計算と正規化 (台形則を使用) ---
	double norm = 0.0;
	double m1 = 0.0; // Asymmetry parameter (g)
	double m2 = 0.0; // 2nd moment
	std::vector<double> cumsum(P.size());

	for (size_t i = 0; i < P.size() - 1; ++i)
	{
		double theta0 = P[i][0];
		double theta1 = P[i+1][0];
		double val0 = P[i][1];
		double val1 = P[i+1][1];
		double dtheta = theta1 - theta0;

		// 被積分関数: P(θ) * sin(θ)
		double f0 = val0 * std::sin(theta0);
		double f1 = val1 * std::sin(theta1);
		double w = 0.5 * (f0 + f1) * dtheta; // 台形則

		norm += w;
		
		// g = ∫ P cosθ sinθ dθ / norm
		m1 += 0.5 * (f0 * std::cos(theta0) + f1 * std::cos(theta1)) * dtheta;
		
		// m2 = ∫ P * 0.5(3cos^2-1) sinθ dθ / norm
		double leg2_0 = 0.5 * (3.0 * std::cos(theta0) * std::cos(theta0) - 1.0);
		double leg2_1 = 0.5 * (3.0 * std::cos(theta1) * std::cos(theta1) - 1.0);
		m2 += 0.5 * (f0 * leg2_0 + f1 * leg2_1) * dtheta;

		cumsum[i] = norm; // iまでの積分値
	}
	cumsum.back() = norm; // 最後の点を埋める

	if (norm <= 1.0e-50) norm = 1.0; // ゼロ割防止

	// 正規化されたモーメント
	double g_asy = m1 / norm;
	double f_2nd = m2 / norm;

	// --- 2. カットオフ率 f の決定 ---
	double f = 0.0;

	switch (delta_approximation_.delta_approximation_type)
	{
		case DeltaApproximationType::d_m1: // Delta-Eddington (f = g^2)
			f = g_asy * g_asy;
			break;

		case DeltaApproximationType::d_m2: // Delta-M (f = m2)
			f = f_2nd;
			break;

		case DeltaApproximationType::Cumulative:
		{
			// ターゲット累積比率を超える場所を探す
			auto it = std::lower_bound(cumsum.begin(), cumsum.end(), delta_approximation_.f_target * norm);
			size_t idx = std::distance(cumsum.begin(), it);
			if (idx >= cumsum.size()) 
			{
				idx = cumsum.size() - 1;
			}
			f = cumsum[idx] / norm;
			break;
		}

		case DeltaApproximationType::FWHM:
		{
			// 簡易的かつ堅牢なFWHM探索
			// ピーク値
			double H = P[0][1];
			
			// バックグラウンド (後方散乱の平均値などで代用)
			// 90度以降の最小値をバックグラウンドとするのが安全
			double B = H;
			for(size_t k = 0; k < P.size(); ++k) {
				if(P[k][0] > PI/2.0 && P[k][1] < B) B = P[k][1];
			}
			
			// 閾値
			double T = B + delta_approximation_.fwhm_ratio * (H - B);
			
			// 閾値を下回る最初の点を探す
			size_t kc = 0;
			for(size_t k = 0; k < P.size(); ++k)
			{
				if(P[k][1] <= T)
				{
					kc = k;
					break;
				}
			}

			f = cumsum[kc] / norm;
			break;
		}
		default:
			break;
	}

	// f のクリッピング (物理的にあり得ない値を防ぐ)
	f = std::clamp(f, 0.0, 0.99999);

	// --- 3. 光学的パラメータのスケーリング ---
	double tau0 = layer.optical_thickness;
	double omega0 = layer.single_scattering_albedo;
	
	double denom = 1.0 - omega0 * f;
	if (std::abs(denom) < 1.0e-12) denom = 1.0e-12; // 安全策

	layer.optical_thickness = (1.0 - omega0 * f) * tau0;
	layer.single_scattering_albedo = (1.0 - f) * omega0 / denom;

	// --- 4. 位相関数の変形 (Truncation & Renormalization) ---
	
	// カットオフ角度のインデックスを再探索
	// (fが決まれば、それに対応する k_cut を正確に決める必要がある)
	size_t k_cut = 0;
	for (size_t k = 0; k < cumsum.size(); ++k)
	{
		if (cumsum[k] / norm >= f)
		{
			k_cut = k;
			break;
		}
	}

	double A_c = cumsum[k_cut]; // 実際にカットされる領域の面積 (未正規化)
	double alpha = 0.0;
	
	if (A_c > 1.0e-50) {
		alpha = (f * norm) / A_c; // 目標の削除量 (f*norm) に対する比率
	}
	alpha = std::clamp(alpha, 0.0, 1.0);

	double renormalize_factor = 1.0 / (1.0 - f);

	for (size_t i = 0; i < P.size(); ++i)
	{
		double Pold = P[i][1];
		double Pnew = Pold;

		if (i <= k_cut)
		{
			// 前方ピーク部分を縮小 (Cut)
			Pnew *= (1.0 - alpha);
		}
		
		// 全体を拡大 (Renormalize)
		Pnew *= renormalize_factor;

		layer.scattering_phase_function[i][1] = Pnew;
	}
	
	// 更新された位相関数から非対称因子を再計算
	// (TMS法などでは g もスケーリング式があるが、数値計算的には再積分が確実)
	layer.asymmetry_parameter = computeAsymmetryParameter(layer.scattering_phase_function);
}

inline RadiativeTransfer::RadiativeTransfer()
{
	return;
}

inline RadiativeTransfer::RadiativeTransfer(const std::string& config_filename)
{
	config_filename_ = config_filename;

	loadConfiguration();
}

inline void RadiativeTransfer::loadConfiguration(void)
{
	configuration_ = ConfigurationLoader::load(config_filename_);
	configuration_.validateConfiguration();
	simulation_ = ModelBuilder::buildSimulation(configuration_);
	logger::global().info("RadiativeTransfer::RadiativeTransfer") << "Radiative transfer calculation started.";
	spectral_ = ModelBuilder::buildSpectral(configuration_);
	geometry_ = ModelBuilder::buildGeometry(configuration_);
	atmosphere_model_ = ModelBuilder::buildAtmosphereModel(configuration_, spectral_);
	delta_approximation_ = ModelBuilder::buildDeltaApproximation(configuration_);
	result_.Ntheta = geometry_.Ntheta;
	result_.Nphi = geometry_.Nphi;
	result_.Nmode = geometry_.M;

	result_.theta_e.resize(geometry_.Ntheta);
	result_.theta_i.resize(geometry_.Ntheta);
	result_.phi.resize(geometry_.Nphi);

	for(int i = 0; i < geometry_.Ntheta; ++i)
	{
		result_.theta_e[i] = geometry_.theta_uh(i);
		result_.theta_i[i] = PI - geometry_.theta_lh(i);
	}

	for(int i = 0; i < geometry_.Nphi; ++i)
	{
		result_.phi[i] = geometry_.phi(i);
	}

	result_.altitude = atmosphere_model_.altitude;
	result_.altitude_top = atmosphere_model_.altitude_top;
	result_.altitude_bottom = atmosphere_model_.altitude_bottom;
	result_.physical_thickness.resize(result_.altitude.size());
	result_.temperature = atmosphere_model_.temperature;
	result_.pressure = atmosphere_model_.pressure;
	result_.number_density = atmosphere_model_.number_density;

	for(int i = 0; i < result_.altitude.size(); ++i)
	{
		result_.physical_thickness[i] = result_.altitude_top[i] - result_.altitude_bottom[i];
	}

	return;
}

inline void RadiativeTransfer::run(void)
{
	radiative_transfer_solver_.geometry(geometry_);
	radiative_transfer_solver_.delta_approximation(delta_approximation_);
	double initial_layer = configuration_.simulation.tau_initial_layer.value();
	
	int n_spectral = spectral_.spectral_grid.size();
	result_.spectral_data.resize(n_spectral);

	#pragma omp parallel for num_threads(simulation_.n_parallel)
	for(int i = 0; i < n_spectral; ++i)
	{
		double spectral = spectral_.spectral_grid[i];
		
		logger::global().info("RadiativeTransfer::run") << "Computing " << spectral << (spectral_.spectral_dimension == SpectralCoordinateDimension::Wavelength ? " m" : " m-1");

		result_.spectral_data[i] = radiative_transfer_solver_.computeMonochrome(atmosphere_model_, spectral, spectral_.spectral_dimension, initial_layer, simulation_.n_scattering_angle);
	}

	logger::global().info("RadiativeTransfer::run") << "Spectral calculation finished.";

	if(spectral_.spectral_coordinate_type == SpectralCoordinateType::Monochrome)
	{
		;
	}
	else if(spectral_.spectral_coordinate_type == SpectralCoordinateType::Spectrum)
	{
		// 1. サイズとインデックスの準備
		size_t n_kernel = spectral_.convolution_kernel.size();
		int n_pad = (n_kernel - 1) / 2;
		
		size_t n_total = result_.spectral_data.size();
		size_t n_output = n_total - 2 * n_pad; // 出力されるべき有効点数

		// 新しい結果格納用ベクタ (最初から必要なサイズだけ確保)
		std::vector<MonochromeData> convolved_data;
		convolved_data.reserve(n_output);

		std::vector<double> new_grid;
		new_grid.reserve(n_output);

		// 2. 有効範囲のループ (i は 出力データのインデックス 0 ~ N-1)
		for(size_t i = 0; i < n_output; ++i)
		{
			// 元データの対応する中心インデックス
			size_t center_idx = i + n_pad;

			// ベースとなるデータをコピー (高度プロファイルなどは中心波長のものを継承)
			MonochromeData data = result_.spectral_data[center_idx];

			// 3. 放射量をゼロ初期化 (積算のため)
			data.source_up.setZero();

			for(auto& mat : data.reflectance_m_top_cos)
			{
				mat.setZero();
			}

			for(auto& mat : data.reflectance_m_top_sin)
			{
				mat.setZero();
			}

			// 4. 畳み込み積算
			for(size_t k = 0; k < n_kernel; ++k)
			{
				// カーネルに対応する元データのインデックス
				// center_idx - n_pad + k  =>  i + k
				size_t src_idx = i + k;
				
				double w = spectral_.convolution_kernel[k];
				const auto& src_data = result_.spectral_data[src_idx];

				// 積算 (Eigenの最適化が効く)
				data.source_up += src_data.source_up * w;

				for(int m = 0; m <= result_.Nmode; ++m)
				{
					data.reflectance_m_top_cos[m] += src_data.reflectance_m_top_cos[m] * w;
					data.reflectance_m_top_sin[m] += src_data.reflectance_m_top_sin[m] * w;
				}
			}

			// 計算済みデータを新しいリストに追加
			convolved_data.push_back(std::move(data));
			new_grid.push_back(spectral_.spectral_grid[center_idx]);
		}

		// 5. 結果の入れ替え (Move Semantics)
		// 古い巨大データはここで破棄され、新しいデータに置き換わる
		result_.spectral_data = convolved_data;
		result_.spectral_grid = new_grid;
		result_.spectral_dimension = spectral_.spectral_dimension;
		spectral_.spectral_grid = new_grid;
	}
	else if(spectral_.spectral_coordinate_type == SpectralCoordinateType::Bandpass)
	{
		int n_spectral = spectral_.spectral_grid.size();
		int n_layer = atmosphere_model_.altitude.size();

		double denom = 0.0;

		for(int i = 0; i < n_spectral; ++i)
		{
			denom += spectral_.filter_weight[i];
		}

		double spectral = 0.0;

		MonochromeData data;
		data.source_up = Eigen::VectorXd::Zero(geometry_.Ntheta);
		data.absorption_coefficient.resize(n_layer, 0.0);
		data.scattering_coefficient.resize(n_layer, 0.0);
		data.single_scattering_albedo.resize(n_layer, 0.0);
		data.optical_thickness.resize(n_layer, 0.0);
		data.asymmetry_parameter.resize(n_layer, 0.0);
		data.reflectance_m_top_cos.resize(geometry_.M + 1, Eigen::MatrixXd::Zero(geometry_.Ntheta, geometry_.Ntheta));
		data.reflectance_m_top_sin.resize(geometry_.M + 1, Eigen::MatrixXd::Zero(geometry_.Ntheta, geometry_.Ntheta));

		// newly added
		data.scattering_phase_function = result_.spectral_data[0].scattering_phase_function;
		data.is_scattering_species = result_.spectral_data[0].is_scattering_species;
		data.species_scattering_phase_function = result_.spectral_data[0].species_scattering_phase_function;
		for(int i = 0; i < data.species_scattering_phase_function.size(); ++i) // altitude
		{
			for(int j = 0; j < data.species_scattering_phase_function[i].size(); ++j) // speceis
			{
				for(int k = 0; k < data.species_scattering_phase_function[i][j].size(); ++k) // scattering angle
				{
					data.species_scattering_phase_function[i][j][k][1] = 0.0;
				}
			}

			for(int j = 0; j < data.scattering_phase_function[i].size(); ++j) // scattering angle
			{
				data.scattering_phase_function[i][j][1] = 0.0;
			}
		}
		data.species_absorption_cross_section.resize(n_layer, std::vector<double>(data.is_scattering_species.size(), 0.0));
		data.species_scattering_cross_section.resize(n_layer, std::vector<double>(data.is_scattering_species.size(), 0.0));

		for(int i = 0; i < n_spectral; ++i)
		{
			spectral += spectral_.spectral_grid[i] * spectral_.filter_weight[i];

			data.source_up += result_.spectral_data[i].source_up * spectral_.filter_weight[i];
			
			for(int j = 0; j < n_layer; ++j)
			{
				data.absorption_coefficient[j] += result_.spectral_data[i].absorption_coefficient[j] * spectral_.filter_weight[i];
				data.scattering_coefficient[j] += result_.spectral_data[i].scattering_coefficient[j] * spectral_.filter_weight[i];

				for(int k = 0; k < data.is_scattering_species.size(); ++k)
				{
					data.species_absorption_cross_section[j][k] += result_.spectral_data[i].species_absorption_cross_section[j][k] * spectral_.filter_weight[i];
					data.species_scattering_cross_section[j][k] += result_.spectral_data[i].species_scattering_cross_section[j][k] * spectral_.filter_weight[i];

					if(data.is_scattering_species[k] == true)
					{
						for(int l = 0; l < data.species_scattering_phase_function[j][k].size(); ++l)
						{
							data.species_scattering_phase_function[j][k][l][1] += result_.spectral_data[i].species_scattering_phase_function[j][k][l][1] * result_.spectral_data[i].species_scattering_cross_section[j][k] * spectral_.filter_weight[i];
						}
					}
				}

				for(int k = 0; k < data.scattering_phase_function[j].size(); ++k)
				{
					data.scattering_phase_function[j][k][1] += result_.spectral_data[i].scattering_phase_function[j][k][1] * result_.spectral_data[i].scattering_coefficient[j] * spectral_.filter_weight[i];
				}

				data.asymmetry_parameter[j] += result_.spectral_data[i].asymmetry_parameter[j] * result_.spectral_data[i].scattering_coefficient[j] * spectral_.filter_weight[i];
			}

			for(int j = 0; j <= geometry_.M; ++j)
			{
				data.reflectance_m_top_cos[j] += result_.spectral_data[i].reflectance_m_top_cos[j] * spectral_.filter_weight[i];
				data.reflectance_m_top_sin[j] += result_.spectral_data[i].reflectance_m_top_sin[j] * spectral_.filter_weight[i];
			}
		}

		for(int i = 0; i < n_layer; ++i)
		{
			data.asymmetry_parameter[i] /= data.scattering_coefficient[i];

			data.absorption_coefficient[i] /= denom;
			data.scattering_coefficient[i] /= denom;

			for(int j = 0; j < data.is_scattering_species.size(); ++j)
			{
				data.species_absorption_cross_section[i][j] /= denom;
				data.species_scattering_cross_section[i][j] /= denom;
				
				if(data.is_scattering_species[j] == true)
				{
					normalizeScatteringPhaseFunction(data.species_scattering_phase_function[i][j]);
				}
			}

			normalizeScatteringPhaseFunction(data.scattering_phase_function[i]);

			data.single_scattering_albedo[i] = data.scattering_coefficient[i] / (data.scattering_coefficient[i] + data.absorption_coefficient[i]);
			data.optical_thickness[i] = (data.scattering_coefficient[i] + data.absorption_coefficient[i]) * (atmosphere_model_.altitude_top[i] - atmosphere_model_.altitude_bottom[i]);
		}

		data.source_up /= denom;
		spectral /= denom;

		for(int i = 0; i <= geometry_.M; ++i)
		{
			data.reflectance_m_top_cos[i] /= denom;
			data.reflectance_m_top_sin[i] /= denom;
		}

		result_.spectral_data = {data};
		result_.spectral_grid = {spectral};
		result_.spectral_dimension = spectral_.spectral_dimension;
		spectral_.spectral_grid = {spectral};
	}

	return;
}

inline RadiativeTransferResult RadiativeTransfer::result(void)
{
	return result_;
}

}