#pragma once

#include <complex>
#include <random>
#include <filesystem>
#include <fstream>
#include <omp.h>
#include <iomanip>
#include <thread>
#include <chrono>
#include <netcdf>
#include <cmath>
#include <vector>

#include <ctime>
#include <sstream>

#include <Eigen/Dense>

#include"constants"
#include"types"
#include"atmosphere"
#include"configuration"
#include"solver"
#include"export"
#include"geometry"
#include"utilities"

namespace radiative_transfer
{

inline RadiativeTransferSolver::RadiativeTransferSolver(const Geometry& geometry)
{
	geometry_ = geometry;
}

inline MonochromeData RadiativeTransferSolver::computeMonochrome(const AtmosphereModel& atmosphere_model, double spectral, SpectralCoordinateDimension dimension, double initial_optical_thickness = 1.0E-6)
{
	initial_optical_thickness_ = initial_optical_thickness;

	double wavelength;
	double wavenumber;

	if(dimension == SpectralCoordinateDimension::Wavenumber)
	{
		wavelength = 1.0 / spectral;
		wavenumber = spectral;
	}
	else if(dimension == SpectralCoordinateDimension::Wavelength)
	{
		wavelength = spectral;
		wavenumber = 1.0 / spectral;
	}
	else
	{
		throw std::runtime_error("[RadiativeTransferCalculator::computeMonochrome] Frequency calculation is not currently supported.");
	}

	int n_layer = atmosphere_model.altitude.size();
	OpticalLayer surface_layer_opt;
	RadiativeLayer surface_layer_rad;
	std::vector<OpticalLayer> atmosphere_layer_opt(n_layer);
	std::vector<RadiativeLayer> atmosphere_layer_rad(n_layer);
	RadiativeLayer result_layer_rad;

	MonochromeData result;

	if(atmosphere_model.surface_type != SurfaceType::NoSurface)
	{

		surface_layer_rad = initializeSurfaceLayer_(surface_layer_opt);
		result_layer_rad = surface_layer_rad;
	}

	for(int i = 0; i < n_layer; ++i)
	{
		atmosphere_layer_rad[i] = initializeAtmosphericLayer_(atmosphere_layer_opt[i]);

		result.absorption_coefficient[i] = atmosphere_layer_opt[i].absorption_coefficient;
		result.scattering_coefficient[i] = atmosphere_layer_opt[i].scattering_coefficient;
		result.optical_thickness[i] = atmosphere_layer_opt[i].optical_thickness;
		result.single_scattering_albedo[i] = atmosphere_layer_opt[i].single_scattering_albedo;
		result.asymmetry_parameter[i] = atmosphere_layer_opt[i].asymmetry_parameter;

		int n_doubling = atmosphere_layer_rad[i].n_doubling;

		for(int j = 0; j < n_doubling; ++j)
		{
			atmosphere_layer_rad[i] = doubleLayer(atmosphere_layer_rad[i], geometry_);
			// doubling;
		}

		if(atmosphere_model.surface_type == SurfaceType::NoSurface && i == 0)
		{
			result_layer_rad = atmosphere_layer_rad[i];
		}
		else
		{
			result_layer_rad = addLayer(result_layer_rad, atmosphere_layer_rad[i], geometry_);
		}
	}

	result.reflectance_m_top_cos = result_layer_rad.reflectance_m_top_cos;
	result.reflectance_m_top_sin = result_layer_rad.reflectance_m_top_sin;
	result.source_up = result_layer_rad.source_up;

	return result;
}

}