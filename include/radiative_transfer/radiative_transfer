#pragma once

#include<complex>
#include<random>
#include<filesystem>
#include<fstream>
#include<omp.h>
#include<iomanip>
#include<thread>
#include<chrono>
#include<netcdf>

#include<ctime>
#include<sstream>

#include<Eigen/Dense>

#include"constants"
#include"types"
#include"atmosphere"
#include"configuration"
#include"solver"
#include"export"
#include"geometry"
#include"utilities"

namespace radiative_transfer
{

void normalizeScatteringPhaseFunction(std::vector<std::vector<double>>&);
void computeMieScattering(int, double, double, std::complex<double>, double&, double&, double&, std::vector<std::vector<double>>&);
void computeMieScatteringSizeDistribution(int, double, const std::vector<std::vector<double>>&, const std::vector<std::vector<double>>&, std::complex<double>, double&, double&, double&, std::vector<std::vector<double>>&);

inline RadiativeTransferCalculator::RadiativeTransferCalculator(const Geometry& geometry)
{
	geometry_ = geometry;
}

inline RadiativeTransferResult RadiativeTransferCalculator::computeMonochrome(const AtmosphereModel& atmosphere_model, double spectrum, SpectralCoordinateDimenstion dimension)
{
	double wavelength;
	double wavenumber;

	if(dimension == SpectralCoordinateDimenstion::Wavenumber)
	{
		wavelength = 1.0 / spectrum;
		wavenumber = spectrum;
	}
	else if(dimension == SpectralCoordinateDimenstion::Wavelength)
	{
		wavelength = spectrum;
		wavenumber = 1.0 / spectrum;
	}
	else
	{
		throw std::runtime_error("[RadiativeTransferCalculator::computeMonochrome] Frequency calculation is not currently supported.");
	}

	int n_layer = atmosphere_model.altitude.size();
	OpticalLayer surface_layer_opt;
	RadiativeLayer surface_layer_rad;
	std::vector<OpticalLayer> atmosphere_layer_opt(n_layer);
	std::vector<RadiativeLayer> atmosphere_layer_rad(n_layer);
	RadiativeLayer result_layer_rad;

	if(atmosphere_model.surface_type == SurfaceType::Lambert)
	{
		surface_layer_opt.
	}

	for(int i = 0; i < n_layer; ++i)
	{
		// doubling -> adding
		;
	}

	if(atmosphere_model.surface_type != SurfaceType::NoSurface)
	{
		// from surface to toa
		;
	}

	RadiativeTransferResult result;
	result.spectral_data.resize(1);
	result.spectral_data[0].reflectance_m_top_cos = result_layer_rad.reflectance_m_top_cos;
	// all other variables

	return result;
}

inline void normalizeScatteringPhaseFunction(std::vector<std::vector<double>> &f)
{
	std::vector<std::vector<double>> phase_function_theta(f.size());

	for(int i = 0; i < f.size(); i ++)
	{
		phase_function_theta[i] = {f[i][0], f[i][1] * 2.0 * PI * std::sin(f[i][0])};
	}

	double sum = computeSimpsonIntegration(phase_function_theta) / (4.0 * PI);

	for(int i = 0; i < f.size(); i ++)
	{
		f[i][1] /= sum;
	}

	return;
}

inline void computeMieScattering(int n, double radius, double wavelength, std::complex<double> index, double& scattering_cross_section, double& absorption_cross_section, double& extinction_cross_section, std::vector<std::vector<double>>& phase_function)
{
	// Input validation
	if (radius <= 0.0 || wavelength <= 0.0 || n < 2)
	{
		scattering_cross_section = 0.0;
		absorption_cross_section = 0.0;
		extinction_cross_section = 0.0;
		phase_function.clear();
		return;
	}

	// 1) サイズパラメータ x = π·D/λ
	double diameter = 2.0 * radius;
	double x = PI * diameter / wavelength;

	// std::cout << wavelength << ", " << radius << ", " << x << std::endl;

	// 2) 級数上限 N_stop
	int nstop = int(std::floor(x + 4.05 * std::cbrt(x) + 2.0));

	//std::cout << "Riccati-Bessel" << std::endl;

	// 3) Riccati–Bessel 商 D_n(z) の計算
	std::vector<std::complex<double>> DD(nstop + 1);

	{
		double threshold = (13.78 * index.real() - 10.8) * index.real() + 3.9;
		auto z = x * index;
		auto zinv = std::complex<double>(0.0, 0.0);
	
		if (std::abs(index.imag() * x) < threshold)
		{
			DD[0] = 1.0 / std::tan(z);
			zinv  = 1.0 / z;
			for (int i = 1; i <= nstop; ++i)
			{
				double k = double(i);
				auto numerator = k * zinv;
				DD[i] = 1.0 / (numerator - DD[i - 1]) - numerator;
			}
		}
		else
		{
			auto zinv = 2.0 / z;
			auto aj = -(nstop + 1.5) * zinv;
			auto alpha_j1 = aj + 1.0 / ((nstop + 0.5) * zinv);
			auto alpha_j2 = aj;
			auto ratio = alpha_j1 / alpha_j2;
			auto runratio = ((nstop + 0.5) * zinv) * ratio;

			while (std::abs(std::abs(ratio) - 1.0) > 1e-12)
			{
				aj = zinv - aj;
				alpha_j1 = 1.0 / alpha_j1 + aj;
				alpha_j2 = 1.0 / alpha_j2 + aj;
				ratio = alpha_j1 / alpha_j2;
				runratio *= ratio;
				zinv = -zinv;
			}

			DD[nstop] = -double(nstop) / z + runratio;
			zinv = 1.0 / z;

			for (int i = nstop - 1; i >= 0; --i)
			{
				double k = double(i + 1);
				auto num = k * zinv;
				DD[i] = num - 1.0 / (DD[i + 1] + num);
			}
		}
	}

	//std::cout << DD[nstop] << std::endl;

	//std::cout << "a_n, b_n and Q" << std::endl;

	// 4) Mie 係数 a_n, b_n と効率 Q の計算
	std::vector<std::complex<double>> a(nstop), b(nstop);
	double Qsca = 0.0;
	double Qext = 0.0;

	{
		double psi0 = std::sin(x);
		double psi1 = psi0 / x - std::cos(x);
	
		auto xi0 = std::complex<double>(psi0, -std::cos(x));
		auto xi1 = std::complex<double>(psi1, -(std::cos(x) / x + std::sin(x)));

		// double g = 0.0;
		// double sign1 = 1.0;
		// auto s1 = std::complex<double>(0.0, 0.0);
		// auto s2 = std::complex<double>(0.0, 0.0);
		// double pi0 = 0.0;
		// double pi1 = 1.0;
		// std::complex<double> ann_1(0.0, 0.0);
		// std::complex<double> bnn_1(0.0, 0.0);

		//std::cout << xi0 << ", " << xi1 << std::endl;

		for (int i = 0; i < nstop; ++i)
		{
			a[i] = ((DD[i + 1] / index + double(i + 1) / x) * psi1 - psi0) / ((DD[i + 1] / index + double(i + 1) / x) * xi1 - xi0);
			b[i] = ((DD[i + 1] * index + double(i + 1) / x) * psi1 - psi0) / ((DD[i + 1] * index + double(i + 1) / x) * xi1 - xi0);
			
			//double factor0 = (2.0 * double(i + 1) + 1.0) / double(i + 2) / double(i + 1);
			//tau = double(i + 1) * mu * pi1 - double(i + 2) * pi0;
			//double alpha = factor0 * pi1;
			//double beta = factor0 * tau;
			
			//s1 = s1 + alpha * ann + beta * bnn;
			//s2 = s2 + alpha * bnn + beta * ann;
			
			//factor0 = pi1;//((2*n+1)*mu[k]*pi1[k]-(n+1)*pi0[k])/n;
			//pi1 = ((2.0 * double(i + 1) + 1.0) * mu * pi1 - double(i + 2) * pi0) / double(i + 1);
			//pi0 = factor0;
			
			double factor0 = 2.0 * double(i + 1) + 1.0;
			
			//g = g + double(i) / double(i + 1) * (ann_1.real() * ann.real() + ann_1.imag() * ann.imag() + bnn_1.real() * bnn.real() + bnn_1.imag() * bnn.imag());
			//g = g + factor0 / double(i + 1) / double(i + 2) * (ann.real() * bnn.real() + ann.imag() * bnn.imag());
			Qsca = Qsca + factor0 * (std::abs(a[i]) * std::abs(a[i]) + std::abs(b[i]) * std::abs(b[i]));
			Qext = Qext + factor0 * (a[i].real() + b[i].real());
			
			//sign1 = -sign1;
			
			factor0 = (2.0 * double(i + 1) + 1.0) / x;
			std::complex<double> xi = factor0 * xi1 - xi0;
			xi0 = xi1;
			xi1 = xi;
			
			double psi = factor0 * psi1 - psi0;
			psi0 = psi1;
			psi1 = xi1.real();
		}

		//std::cout << xi0 << ", " << xi1 << ", " << psi0 << ", " << psi1 << std::endl;
	}

	// 5) 無次元効率 Q の正規化
	Qsca = 2.0 * Qsca / (x * x);
	Qext = 2.0 * Qext / (x * x);
	double Qabs = Qext - Qsca;

	// std::cout << "Qsca: " << Qsca << std::endl;
	// std::cout << "Qabs: " << Qabs << std::endl;
	// std::cout << "Qext: " << Qext << std::endl;

	// 6) 断面積 [m^2] に変換
	double area = PI * radius * radius;
	scattering_cross_section = Qsca * area;
	absorption_cross_section = Qabs * area;
	extinction_cross_section = Qext * area;

	//std::cout << "Scattering phase function" << std::endl;

	// 7) 位相関数の計算
	phase_function.clear();
	phase_function.resize(n);
	double dtheta = PI / double(n - 1);

	//#pragma omp parallel for
	for (int k = 0; k < n; ++k)
	{
		double theta = dtheta * double(k);
		double mu = std::cos(theta);

		std::complex<double> S1(0.0, 0.0);
		std::complex<double> S2(0.0, 0.0);
		double pi0 = 0.0;
		double pi1 = 1.0;

		for (int i = 0; i < nstop; ++i)
		{
			double weight = (2.0 * double(i + 1) + 1.0) / double(i + 2) / double(i + 1);
			double tau = double(i + 1) * mu * pi1 - double(i + 2) * pi0;
			// double tau = n_i * mu * pi1 - (n_i + 1) * pi0;

			S1 += weight * (a[i] * pi1 + b[i] * tau);
			S2 += weight * (b[i] * pi1 + a[i] * tau);

			double pi2 = ((2.0 * double(i + 1) + 1.0) * mu * pi1 - double(i + 2) * pi0) / double(i + 1);
			pi0 = pi1;
			pi1 = pi2;
		}

		double s11 = 0.5 * (std::norm(S2) + std::norm(S1));
		// double s12 = 0.5 * (std::norm(S2) - std::norm(S1));
		// double pol = -s12 / s11;
		// double s33 = (S2 * std::conj(S1)).real();
		// double s34 = (S2 * std::conj(S1)).imag();
		double natural = s11 / (PI * x * x * Qsca);
		//double P11 = s11 / (PI * x * x * Qsca);

		phase_function[k] = {theta, natural * 4.0 * PI};
	}

	return;
}

inline void computeMieScatteringSizeDistribution(int n_theta, double wavelength, const std::vector<std::vector<double>>& size_distribution, const std::vector<std::vector<double>>& weight, std::complex<double> index, double& scattering_cross_section, double& absorption_cross_section, double& extinction_cross_section, std::vector<std::vector<double>>& phase_function)
{
	int n_r = size_distribution.size();
	// std::vector<double> scs(n_r);
	// std::vector<double> acs(n_r);
	// std::vector<std::vector<std::vector<double>>> pf(n_r, std::vector<std::vector<double>>(n_theta, std::vector<double>(2)));

	double denom = 0.0;

	absorption_cross_section = 0.0;
	scattering_cross_section = 0.0;
	phase_function = std::vector<std::vector<double>>(n_theta, std::vector<double>(2, 0.0));

	double dtheta = PI / double(n_theta - 1);
	for (int i = 0; i < n_theta; ++i)
	{
		phase_function[i][0] = dtheta * double(i);
	}

	for(int i = 0; i < n_r; ++i)
	{
		double scs, acs, ecs;
		std::vector<std::vector<double>> pf;
		double n_dr = size_distribution[i][1] * weight[i][1];
		computeMieScattering(n_theta, size_distribution[i][0], wavelength, index, scs, acs, ecs, pf);
		absorption_cross_section += acs * n_dr;
		scattering_cross_section += scs * n_dr;
		extinction_cross_section += ecs * n_dr;
		denom += n_dr;

		for(int j = 0; j < n_theta; ++j)
		{
			phase_function[j][1] += pf[j][1] * scs * n_dr;
		}
	}

	absorption_cross_section /= denom;
	scattering_cross_section /= denom;
	extinction_cross_section /= denom;
	
	normalizeScatteringPhaseFunction(phase_function);

	return;
}















JacobianResult computeJacobian(std::string, JacobianType, double);
JacobianResult computeJacobianSpecies(std::string, JacobianType, int, double);
JacobianResult computeJacobianRefractiveIndex(std::string, std::vector<int>, double);

inline void RadiativeTransfer::importConfiguration(void)
{
	try
	{
		configuration = ConfigurationLoader::load(config_filename);
		configuration.validateConfiguration();
	}
	catch(const std::exception &e)
	{
		std::cerr << "Configuration import failed: " << e.what() << std::endl;
	}

	std::filesystem::create_directory(configuration.simulation.directory_name.value() + "result");
	// std::filesystem::create_directory(configuration.directory_name + "log");

	return;
}

inline void RadiativeTransfer::exportResultNetCDF(void)
{
	try
	{
		exportResultNetCDF(configuration.result_name);
	}
	catch(const std::exception &e)
	{
		std::cerr << "Calculation result export failed: " << e.what() << std::endl;
	}


	return;
}

/*
inline void RadiativeTransfer::runSpectrum(void)
{
	initializeGeometry();

	int n_x;
	if(configuration.is_wavenumber == true)
	{
		n_x = configuration.wavenumber_list.size();
		result.wavenumber.resize(n_x);
	}
	else
	{
		n_x = configuration.wavelength_list.size();
		result.wavelength.resize(n_x);
	}

	result.Ntheta = Ntheta;
	result.Nmode = M;

	for(int i = 0; i < Ntheta; i ++)
	{
		result.theta_e.push_back(geometry.theta_uh(i));
		result.theta_i.push_back(PI - geometry.theta_lh(i));
	}

	result.absorption_coefficient.resize(n_x);
	result.scattering_coefficient.resize(n_x);
	result.single_scattering_albedo.resize(n_x);
	result.optical_thickness.resize(n_x);
	result.asymmetry_parameter.resize(n_x);

	result.reflectance_top.resize(n_x);
	result.reflectance_m_top_cos.resize(n_x);
	result.reflectance_m_top_sin.resize(n_x);
	result.source_up.resize(n_x);

	#pragma omp parallel for
	for(int n_lambda = 0; n_lambda < n_x; n_lambda ++)
	{
		#pragma omp critical
		{
			if(configuration.is_wavenumber == true)
			{
				std::cout << "Wavenumber: " << configuration.wavenumber_list[n_lambda] << " m-1 (" << n_lambda + 1 << " / " << configuration.wavenumber_list.size() << ")" << std::endl;
			}
			else
			{
				std::cout << "Wavelength: " << configuration.wavelength_list[n_lambda] << " m (" << n_lambda + 1 << " / " << configuration.wavelength_list.size() << ")" << std::endl;
			}
		}

		AtmosphereModel atmosphere_model;

		computeAtmosphericProperties(atmosphere_model);
		computeSpeciesProperties(atmosphere_model);
				
		if(configuration.is_wavenumber == true)
		{
			double wavenumber = configuration.wavenumber_list[n_lambda];
			result.wavenumber[n_lambda] = wavenumber;
			runMonochrome(atmosphere_model, wavenumber);
		}
		else
		{
			double wavelength = configuration.wavelength_list[n_lambda];
			result.wavelength[n_lambda] = wavelength;
			runMonochrome(atmosphere_model, 1.0 / wavelength);
		}

		if(n_lambda == 0)
		{
			std::vector<double> z, z_top, z_bottom, dz, T, P, ND;
			for(int i = 0; i < atmosphere_model.layers.size(); i ++)
			{
				z.push_back(atmosphere_model.layers[i].altitude);
				z_top.push_back(atmosphere_model.layers[i].altitude_top);
				z_bottom.push_back(atmosphere_model.layers[i].altitude_bottom);
				dz.push_back(atmosphere_model.layers[i].physical_thickness);
				T.push_back(atmosphere_model.layers[i].temperature);
				P.push_back(atmosphere_model.layers[i].pressure);
				ND.push_back(atmosphere_model.layers[i].number_density);
			}

			result.altitude = z;
			result.altitude_bottom = z_bottom;
			result.altitude_top = z_top;
			result.physical_thickness = dz;
			result.temperature = T;
			result.pressure = P;
			result.number_density = ND;
		}

		result.absorption_coefficient[n_lambda].resize(atmosphere_model.layers.size());
		result.scattering_coefficient[n_lambda].resize(atmosphere_model.layers.size());
		result.single_scattering_albedo[n_lambda].resize(atmosphere_model.layers.size());
		result.optical_thickness[n_lambda].resize(atmosphere_model.layers.size());
		result.asymmetry_parameter[n_lambda].resize(atmosphere_model.layers.size());

		for(int i = 0; i < atmosphere_model.layers.size(); i ++)
		{
			result.optical_thickness[n_lambda][i] = atmosphere_model.layers[i].optical_thickness;
			result.scattering_coefficient[n_lambda][i] = atmosphere_model.layers[i].scattering_coefficient;
			result.absorption_coefficient[n_lambda][i] = atmosphere_model.layers[i].absorption_coefficient;
			result.single_scattering_albedo[n_lambda][i] = atmosphere_model.layers[i].single_scattering_albedo;
			result.asymmetry_parameter[n_lambda][i] = atmosphere_model.layers[i].asymmetry_parameter;
		}

		reconstructOpticalProperties(atmosphere_model.result_layer);

		result.reflectance_top[n_lambda] = atmosphere_model.result_layer.reflectance_top;
		result.reflectance_m_top_cos[n_lambda] = atmosphere_model.result_layer.reflectance_m_top_cos;
		result.reflectance_m_top_sin[n_lambda] = atmosphere_model.result_layer.reflectance_m_top_sin;
		result.source_up[n_lambda] = atmosphere_model.result_layer.source_up;
	}

	if(configuration.is_instrument)
	{
		// std::cout << "instrument" << std::endl;

		int n_lsf;
		double dx = configuration.instrument_function_width / double(configuration.n_over_sample);

		if(configuration.instrument_function_type == InstrumentFunction::Rectangle)
		{
			n_lsf = configuration.n_over_sample + 1;
		}
		else if(configuration.instrument_function_type == InstrumentFunction::Gauss)
		{
			n_lsf = 2 * 5 * configuration.n_over_sample + 1;
		}

		std::vector<double> lsf_kernel(n_lsf);

		if(configuration.instrument_function_type == InstrumentFunction::Rectangle)
		{
			for(int i = 0; i < n_lsf; i ++)
			{
				lsf_kernel[i] = 1.0;
			}
		}
		else if(configuration.instrument_function_type == InstrumentFunction::Gauss)
		{
			int n_center = (n_lsf - 1) / 2;
			double sigma = configuration.instrument_function_width;
						
			for(int i = 0; i < n_lsf; i ++)
			{
				double x = dx * double(i - n_center);

				lsf_kernel[i] = std::exp(-x * x / (2.0 * sigma * sigma));
			}
		}

		// normalization
		double sum = 0.0;
		for(int i = 0; i < n_lsf; i ++)
		{
			sum += lsf_kernel[i];
		}

		for(int i = 0; i < n_lsf; i ++)
		{
			lsf_kernel[i] /= sum;
		}

		auto result_tmp = result;

		for(int n_wn = 0; n_wn < n_x; n_wn ++)
		{
			result.reflectance_top[n_wn] = std::vector<std::vector<std::vector<double>>>(Ntheta, std::vector<std::vector<double>>(Ntheta, std::vector<double>(Nphi, 0.0)));
			result.reflectance_m_top_cos[n_wn] = std::vector<Eigen::MatrixXd>(M + 1, Eigen::MatrixXd::Zero(Ntheta, Ntheta));
			result.reflectance_m_top_sin[n_wn] = std::vector<Eigen::MatrixXd>(M + 1, Eigen::MatrixXd::Zero(Ntheta, Ntheta));
			result.source_up[n_wn] = Eigen::VectorXd::Zero(Ntheta);
			
			int n_start = std::max(0, n_wn - (n_lsf - 1) / 2);
			int n_end = std::min(n_x - 1, n_wn + (n_lsf - 1) / 2);

			for(int i = n_start; i <= n_end; i ++)
			{
				int n_kn = (n_lsf - 1) / 2 + i - n_wn;

				for(int ne = 0; ne < Ntheta; ne ++)
				{
					for(int ni = 0; ni < Ntheta; ni ++)
					{
						for(int np = 0; np < Nphi; np ++)
						{
							result.reflectance_top[n_wn][ne][ni][np] += result_tmp.reflectance_top[i][ne][ni][np] * lsf_kernel[n_kn];
						}
					}
				}

				for(int nm = 0; nm <= M; nm ++)
				{
					result.reflectance_m_top_cos[n_wn][nm] += result_tmp.reflectance_m_top_cos[i][nm] * lsf_kernel[n_kn];
					result.reflectance_m_top_sin[n_wn][nm] += result_tmp.reflectance_m_top_sin[i][nm] * lsf_kernel[n_kn];
				}
				
				result.source_up[n_wn] += result_tmp.source_up[i] * lsf_kernel[n_kn];
			}
		}
	
		for(int n_wn = 0; n_wn < n_x; n_wn ++)
		{
			if(result.wavenumber[n_wn] < configuration.wavenumber_min_result || result.wavenumber[n_wn] > configuration.wavenumber_max_result)
			{
				result.reflectance_top.erase(result.reflectance_top.begin() + n_wn);
				result.reflectance_m_top_cos.erase(result.reflectance_m_top_cos.begin() + n_wn);
				result.reflectance_m_top_sin.erase(result.reflectance_m_top_sin.begin() + n_wn);
				result.source_up.erase(result.source_up.begin() + n_wn);
				result.wavenumber.erase(result.wavenumber.begin() + n_wn);
				result.absorption_coefficient.erase(result.absorption_coefficient.begin() + n_wn);
				result.scattering_coefficient.erase(result.scattering_coefficient.begin() + n_wn);
				result.single_scattering_albedo.erase(result.single_scattering_albedo.begin() + n_wn);
				result.optical_thickness.erase(result.optical_thickness.begin() + n_wn);
				result.asymmetry_parameter.erase(result.asymmetry_parameter.begin() + n_wn);

				n_wn --;
				n_x --;
			}
		}
	}

	return;
}
*/

inline void RadiativeTransfer::runSpectrum(AtmosphereModel atmosphere_model)
{
	int n_x;
	if(configuration.is_wavenumber == true)
	{
		n_x = configuration.wavenumber_list.size();
		result.wavenumber.resize(n_x);
	}
	else
	{
		n_x = configuration.wavelength_list.size();
		result.wavelength.resize(n_x);
	}

	result.Ntheta = Ntheta;
	result.Nmode = M;
	result.Nphi = Nphi;

	for(int i = 0; i < Ntheta; i ++)
	{
		result.theta_e.push_back(geometry.theta_uh(i));
		result.theta_i.push_back(PI - geometry.theta_lh(i));
	}

	result.phi = std::vector<double>(geometry.phi.data(), geometry.phi.data() + geometry.phi.size());

	result.absorption_coefficient.resize(n_x);
	result.scattering_coefficient.resize(n_x);
	result.single_scattering_albedo.resize(n_x);
	result.optical_thickness.resize(n_x);
	result.asymmetry_parameter.resize(n_x);

	result.reflectance_top.resize(n_x);
	result.reflectance_m_top_cos.resize(n_x);
	result.reflectance_m_top_sin.resize(n_x);
	result.source_up.resize(n_x);

	#pragma omp parallel for num_threads(configuration.n_parallel)
	for(int n_lambda = 0; n_lambda < n_x; n_lambda ++)
	{
		#pragma omp critical
		{
			if(configuration.is_wavenumber == true)
			{
				std::cout << "Wavenumber: " << configuration.wavenumber_list[n_lambda] << " m-1 (" << n_lambda + 1 << " / " << configuration.wavenumber_list.size() << ")" << std::endl;
			}
			else
			{
				std::cout << "Wavelength: " << configuration.wavelength_list[n_lambda] << " m (" << n_lambda + 1 << " / " << configuration.wavelength_list.size() << ")" << std::endl;
			}
		}

		AtmosphereModel atmos_model = atmosphere_model;
				
		if(configuration.is_wavenumber == true)
		{
			double wavenumber = configuration.wavenumber_list[n_lambda];
			result.wavenumber[n_lambda] = wavenumber;
			runMonochrome(atmos_model, wavenumber);
		}
		else
		{
			double wavelength = configuration.wavelength_list[n_lambda];
			result.wavelength[n_lambda] = wavelength;
			runMonochrome(atmos_model, 1.0 / wavelength);
		}

		if(n_lambda == 0)
		{
			std::vector<double> z, z_top, z_bottom, dz, T, P, ND;
			for(int i = 0; i < atmos_model.layers.size(); i ++)
			{
				z.push_back(atmos_model.layers[i].altitude);
				z_top.push_back(atmos_model.layers[i].altitude_top);
				z_bottom.push_back(atmos_model.layers[i].altitude_bottom);
				dz.push_back(atmos_model.layers[i].physical_thickness);
				T.push_back(atmos_model.layers[i].temperature);
				P.push_back(atmos_model.layers[i].pressure);
				ND.push_back(atmos_model.layers[i].number_density);
			}

			result.altitude = z;
			result.altitude_bottom = z_bottom;
			result.altitude_top = z_top;
			result.physical_thickness = dz;
			result.temperature = T;
			result.pressure = P;
			result.number_density = ND;
		}

		result.absorption_coefficient[n_lambda].resize(atmos_model.layers.size());
		result.scattering_coefficient[n_lambda].resize(atmos_model.layers.size());
		result.single_scattering_albedo[n_lambda].resize(atmos_model.layers.size());
		result.optical_thickness[n_lambda].resize(atmos_model.layers.size());
		result.asymmetry_parameter[n_lambda].resize(atmos_model.layers.size());

		for(int i = 0; i < atmos_model.layers.size(); i ++)
		{
			result.optical_thickness[n_lambda][i] = atmos_model.layers[i].optical_thickness;
			result.scattering_coefficient[n_lambda][i] = atmos_model.layers[i].scattering_coefficient;
			result.absorption_coefficient[n_lambda][i] = atmos_model.layers[i].absorption_coefficient;
			result.single_scattering_albedo[n_lambda][i] = atmos_model.layers[i].single_scattering_albedo;
			result.asymmetry_parameter[n_lambda][i] = atmos_model.layers[i].asymmetry_parameter;
		}

		reconstructOpticalProperties(atmos_model.result_layer);

		result.reflectance_top[n_lambda] = atmos_model.result_layer.reflectance_top;
		result.reflectance_m_top_cos[n_lambda] = atmos_model.result_layer.reflectance_m_top_cos;
		result.reflectance_m_top_sin[n_lambda] = atmos_model.result_layer.reflectance_m_top_sin;
		result.source_up[n_lambda] = atmos_model.result_layer.source_up;
	}

	if(configuration.is_instrument)
	{
		// std::cout << "instrument" << std::endl;

		int n_lsf;
		double dx = configuration.instrument_function_width / double(configuration.n_sample);

		if(configuration.instrument_function_type == InstrumentFunction::Rectangle)
		{
			n_lsf = configuration.n_sample + 1;
		}
		else if(configuration.instrument_function_type == InstrumentFunction::Gauss)
		{
			n_lsf = 2 * 5 * configuration.n_sample + 1;
		}

		std::vector<double> lsf_kernel(n_lsf);

		if(configuration.instrument_function_type == InstrumentFunction::Rectangle)
		{
			for(int i = 0; i < n_lsf; i ++)
			{
				lsf_kernel[i] = 1.0;
			}
		}
		else if(configuration.instrument_function_type == InstrumentFunction::Gauss)
		{
			int n_center = (n_lsf - 1) / 2;
			double sigma = configuration.instrument_function_width;
						
			for(int i = 0; i < n_lsf; i ++)
			{
				double x = dx * double(i - n_center);

				lsf_kernel[i] = std::exp(-x * x / (2.0 * sigma * sigma));
			}
		}

		// normalization
		double sum = 0.0;
		for(int i = 0; i < n_lsf; i ++)
		{
			sum += lsf_kernel[i];
		}

		for(int i = 0; i < n_lsf; i ++)
		{
			lsf_kernel[i] /= sum;
		}

		auto result_tmp = result;

		for(int n_wn = 0; n_wn < n_x; n_wn ++)
		{
			result.reflectance_top[n_wn] = std::vector<std::vector<std::vector<double>>>(Ntheta, std::vector<std::vector<double>>(Ntheta, std::vector<double>(Nphi, 0.0)));
			result.reflectance_m_top_cos[n_wn] = std::vector<Eigen::MatrixXd>(M + 1, Eigen::MatrixXd::Zero(Ntheta, Ntheta));
			result.reflectance_m_top_sin[n_wn] = std::vector<Eigen::MatrixXd>(M + 1, Eigen::MatrixXd::Zero(Ntheta, Ntheta));
			result.source_up[n_wn] = Eigen::VectorXd::Zero(Ntheta);
			
			int n_start = std::max(0, n_wn - (n_lsf - 1) / 2);
			int n_end = std::min(n_x - 1, n_wn + (n_lsf - 1) / 2);

			for(int i = n_start; i <= n_end; i ++)
			{
				int n_kn = (n_lsf - 1) / 2 + i - n_wn;

				for(int ne = 0; ne < Ntheta; ne ++)
				{
					for(int ni = 0; ni < Ntheta; ni ++)
					{
						for(int np = 0; np < Nphi; np ++)
						{
							result.reflectance_top[n_wn][ne][ni][np] += result_tmp.reflectance_top[i][ne][ni][np] * lsf_kernel[n_kn];
						}
					}
				}

				for(int nm = 0; nm <= M; nm ++)
				{
					result.reflectance_m_top_cos[n_wn][nm] += result_tmp.reflectance_m_top_cos[i][nm] * lsf_kernel[n_kn];
					result.reflectance_m_top_sin[n_wn][nm] += result_tmp.reflectance_m_top_sin[i][nm] * lsf_kernel[n_kn];
				}
				
				result.source_up[n_wn] += result_tmp.source_up[i] * lsf_kernel[n_kn];
			}
		}
	
		for(int n_wn = 0; n_wn < n_x; n_wn ++)
		{
			if(result.wavenumber[n_wn] < configuration.wavenumber_min_result || result.wavenumber[n_wn] > configuration.wavenumber_max_result)
			{
				result.reflectance_top.erase(result.reflectance_top.begin() + n_wn);
				result.reflectance_m_top_cos.erase(result.reflectance_m_top_cos.begin() + n_wn);
				result.reflectance_m_top_sin.erase(result.reflectance_m_top_sin.begin() + n_wn);
				result.source_up.erase(result.source_up.begin() + n_wn);
				result.wavenumber.erase(result.wavenumber.begin() + n_wn);
				result.absorption_coefficient.erase(result.absorption_coefficient.begin() + n_wn);
				result.scattering_coefficient.erase(result.scattering_coefficient.begin() + n_wn);
				result.single_scattering_albedo.erase(result.single_scattering_albedo.begin() + n_wn);
				result.optical_thickness.erase(result.optical_thickness.begin() + n_wn);
				result.asymmetry_parameter.erase(result.asymmetry_parameter.begin() + n_wn);

				n_wn --;
				n_x --;
			}
		}
	}

	return;
}

inline void RadiativeTransfer::runMonochrome(AtmosphereModel& atmosphere_model, double wavenumber)
{
	//call computeAtmosphericProperties, computeSpeciesProperties, initializeGeometry, setLayerCondition first
	// std::cout << "thru" << std::endl;

	// std::cout << atmosphere_model.layers.size() << std::endl;

	for(int nlayer = 0; nlayer < atmosphere_model.layers.size(); nlayer ++)
	{
		initializeLayer(atmosphere_model.layers[nlayer]);
	}

	if(configuration.surface_type != SurfaceType::NoSurface)
	{
		initializeSurface(atmosphere_model.surface_layer);
	}

	// std::cout << "thru" << std::endl;

	for(int nlayer = 0; nlayer < atmosphere_model.layers.size(); nlayer ++)
	{
		auto layer = atmosphere_model.layers[nlayer];
		
		for(int nadd = 0; nadd < layer.n_doubling; nadd ++)
		{
			layer = doubleLayer(layer, geometry);
		}

		atmosphere_model.layers[nlayer] = layer;

		if(nlayer == 0)
		{
			if(configuration.surface_type == SurfaceType::NoSurface)
			{
				atmosphere_model.result_layer = layer;
			}
			else
			{
				atmosphere_model.result_layer = addLayer(atmosphere_model.surface_layer, layer, geometry);
			}
		}
		else
		{
			atmosphere_model.result_layer = addLayer(atmosphere_model.result_layer, layer, geometry);
		}
	}
	
	return;
}

/*
inline void RadiativeTransfer::runBandpass(void)
{
	initializeGeometry();

	int n_x;
	if(configuration.is_wavenumber == true)
	{
		n_x = configuration.wavenumber_list.size();
		result.wavenumber.resize(n_x);
	}
	else
	{
		n_x = configuration.wavelength_list.size();
		result.wavelength.resize(n_x);
	}

	result.Ntheta = Ntheta;
	result.Nmode = M;

	for(int i = 0; i < Ntheta; i ++)
	{
		result.theta_e.push_back(geometry.theta_uh(i));
		result.theta_i.push_back(PI - geometry.theta_lh(i));
	}

	result.absorption_coefficient.resize(n_x);
	result.scattering_coefficient.resize(n_x);
	result.single_scattering_albedo.resize(n_x);
	result.optical_thickness.resize(n_x);
	result.asymmetry_parameter.resize(n_x);

	result.reflectance_top.resize(n_x);
	result.reflectance_m_top_cos.resize(n_x);
	result.reflectance_m_top_sin.resize(n_x);
	result.source_up.resize(n_x);

	#pragma omp parallel for
	for(int n_lambda = 0; n_lambda < n_x; n_lambda ++)
	{
		#pragma omp critical
		{
			if(configuration.is_wavenumber == true)
			{
				std::cout << "Wavenumber: " << configuration.wavenumber_list[n_lambda] << " m-1 (" << n_lambda + 1 << " / " << configuration.wavenumber_list.size() << ")" << std::endl;
			}
			else
			{
				std::cout << "Wavelength: " << configuration.wavelength_list[n_lambda] << " m (" << n_lambda + 1 << " / " << configuration.wavelength_list.size() << ")" << std::endl;
			}
		}

		AtmosphereModel atmosphere_model;

		computeAtmosphericProperties(atmosphere_model);
		computeSpeciesProperties(atmosphere_model);
				
		if(configuration.is_wavenumber == true)
		{
			double wavenumber = configuration.wavenumber_list[n_lambda];
			result.wavenumber[n_lambda] = wavenumber;
			runMonochrome(atmosphere_model, wavenumber);
		}
		else
		{
			double wavelength = configuration.wavelength_list[n_lambda];
			result.wavelength[n_lambda] = wavelength;
			runMonochrome(atmosphere_model, 1.0 / wavelength);
		}

		if(n_lambda == 0)
		{
			std::vector<double> z, z_top, z_bottom, dz, T, P, ND;
			for(int i = 0; i < atmosphere_model.layers.size(); i ++)
			{
				z.push_back(atmosphere_model.layers[i].altitude);
				z_top.push_back(atmosphere_model.layers[i].altitude_top);
				z_bottom.push_back(atmosphere_model.layers[i].altitude_bottom);
				dz.push_back(atmosphere_model.layers[i].physical_thickness);
				T.push_back(atmosphere_model.layers[i].temperature);
				P.push_back(atmosphere_model.layers[i].pressure);
				ND.push_back(atmosphere_model.layers[i].number_density);
			}

			result.altitude = z;
			result.altitude_bottom = z_bottom;
			result.altitude_top = z_top;
			result.physical_thickness = dz;
			result.temperature = T;
			result.pressure = P;
			result.number_density = ND;
		}

		result.absorption_coefficient[n_lambda].resize(atmosphere_model.layers.size());
		result.scattering_coefficient[n_lambda].resize(atmosphere_model.layers.size());
		result.single_scattering_albedo[n_lambda].resize(atmosphere_model.layers.size());
		result.optical_thickness[n_lambda].resize(atmosphere_model.layers.size());
		result.asymmetry_parameter[n_lambda].resize(atmosphere_model.layers.size());

		for(int i = 0; i < atmosphere_model.layers.size(); i ++)
		{
			result.optical_thickness[n_lambda][i] = atmosphere_model.layers[i].optical_thickness;
			result.scattering_coefficient[n_lambda][i] = atmosphere_model.layers[i].scattering_coefficient;
			result.absorption_coefficient[n_lambda][i] = atmosphere_model.layers[i].absorption_coefficient;
			result.single_scattering_albedo[n_lambda][i] = atmosphere_model.layers[i].single_scattering_albedo;
			result.asymmetry_parameter[n_lambda][i] = atmosphere_model.layers[i].asymmetry_parameter;
		}

		reconstructOpticalProperties(atmosphere_model.result_layer);

		result.reflectance_top[n_lambda] = atmosphere_model.result_layer.reflectance_top;
		result.reflectance_m_top_cos[n_lambda] = atmosphere_model.result_layer.reflectance_m_top_cos;
		result.reflectance_m_top_sin[n_lambda] = atmosphere_model.result_layer.reflectance_m_top_sin;
		result.source_up[n_lambda] = atmosphere_model.result_layer.source_up;
	}

	auto result_tmp = result;

	int n_layer = result.altitude.size();

	result.absorption_coefficient.resize(1, std::vector<double>(n_layer, 0.0));
	result.scattering_coefficient.resize(1, std::vector<double>(n_layer, 0.0));
	result.single_scattering_albedo.resize(1, std::vector<double>(n_layer, 0.0));
	result.optical_thickness.resize(1, std::vector<double>(n_layer, 0.0));
	result.asymmetry_parameter.resize(1, std::vector<double>(n_layer, 0.0));

	result.reflectance_top.resize(1, std::vector<std::vector<std::vector<double>>>(Ntheta, std::vector<std::vector<double>>(Ntheta, std::vector<double>(Nphi, 0.0))));
	result.reflectance_m_top_cos.resize(1, std::vector<Eigen::MatrixXd>(M + 1, Eigen::MatrixXd::Zero(Ntheta, Ntheta)));
	result.reflectance_m_top_sin.resize(1, std::vector<Eigen::MatrixXd>(M + 1, Eigen::MatrixXd::Zero(Ntheta, Ntheta)));
	result.source_up.resize(1, Eigen::VectorXd::Zero(Ntheta));

	double wavenumber_mean = 0.0;
	double wavelength_mean = 0.0;

	for(int i = 0; i < n_x; i ++)
	{
		for(int j = 0; j < n_layer; j ++)
		{
			result.absorption_coefficient[0][j] += result_tmp.absorption_coefficient[i][j] * configuration.window_function[i];
			result.scattering_coefficient[0][j] += result_tmp.scattering_coefficient[i][j] * configuration.window_function[i];
			// result.single_scattering_albedo[0][j] += result_tmp.single_scattering_albedo[i][j] * configuration.window_function[i];
			// result.optical_thickness[0][j] += result_tmp.optical_thickness[i][j] * configuration.window_function[i];
			result.asymmetry_parameter[0][j] += result_tmp.asymmetry_parameter[i][j] * result_tmp.scattering_coefficient[i][j] * configuration.window_function[i];
		}

		for(int j = 0; j < Ntheta; j ++)
		{
			result.source_up[0](j) += result_tmp.source_up[i](j) * configuration.window_function[i];

			for(int k = 0; k < Ntheta; k ++)
			{
				for(int l = 0; l < Nphi; l ++)
				{
					result.reflectance_top[0][j][k][l] += result_tmp.reflectance_top[i][j][k][l] * configuration.window_function[i];
				}
			}
		}

		for(int j = 0; j <= M; j ++)
		{
			for(int k = 0; k < Ntheta; k ++)
			{
				for(int l = 0; l < Ntheta; l ++)
				{
					result.reflectance_m_top_cos[0][j](k, l) += result_tmp.reflectance_m_top_cos[i][j](k, l) * configuration.window_function[i];
					result.reflectance_m_top_sin[0][j](k, l) += result_tmp.reflectance_m_top_sin[i][j](k, l) * configuration.window_function[i];
				}
			}
		}

		wavenumber_mean += (configuration.is_wavenumber == true ? configuration.wavenumber_list[i] : 1.0 / configuration.wavelength_list[i]) * configuration.window_function[i];
		wavelength_mean += (configuration.is_wavenumber == true ? 1.0 / configuration.wavenumber_list[i] : configuration.wavelength_list[i]) * configuration.window_function[i];
	}

	for(int j = 0; j < n_layer; j ++)
	{
		result.single_scattering_albedo[0][j] = result.scattering_coefficient[0][j] / (result.scattering_coefficient[0][j] + result.absorption_coefficient[0][j]);
		result.asymmetry_parameter[0][j] /= result.scattering_coefficient[0][j];
		result.optical_thickness[0][j] = (result.scattering_coefficient[0][j] + result.absorption_coefficient[0][j]) * result.physical_thickness[j];
	}

	result.wavenumber = {wavenumber_mean};
	result.wavelength = {wavelength_mean};
	
	return;
}
*/

inline void RadiativeTransfer::runBandpass(AtmosphereModel atmosphere_model)
{
	int n_x;
	if(configuration.is_wavenumber == true)
	{
		n_x = configuration.wavenumber_list.size();
		result.wavenumber.resize(n_x);
	}
	else
	{
		n_x = configuration.wavelength_list.size();
		result.wavelength.resize(n_x);
	}

	result.Ntheta = Ntheta;
	result.Nmode = M;
	result.Nphi = Nphi;

	for(int i = 0; i < Ntheta; i ++)
	{
		result.theta_e.push_back(geometry.theta_uh(i));
		result.theta_i.push_back(PI - geometry.theta_lh(i));
	}

	result.phi = std::vector<double>(geometry.phi.data(), geometry.phi.data() + geometry.phi.size());

	result.absorption_coefficient.resize(n_x);
	result.scattering_coefficient.resize(n_x);
	result.single_scattering_albedo.resize(n_x);
	result.optical_thickness.resize(n_x);
	result.asymmetry_parameter.resize(n_x);

	result.reflectance_top.resize(n_x);
	result.reflectance_m_top_cos.resize(n_x);
	result.reflectance_m_top_sin.resize(n_x);
	result.source_up.resize(n_x);

	#pragma omp parallel for num_threads(configuration.n_parallel)
	for(int n_lambda = 0; n_lambda < n_x; n_lambda ++)
	{
		#pragma omp critical
		{
			if(configuration.is_wavenumber == true)
			{
				std::cout << "Wavenumber: " << configuration.wavenumber_list[n_lambda] << " m-1 (" << n_lambda + 1 << " / " << configuration.wavenumber_list.size() << ")" << std::endl;
			}
			else
			{
				std::cout << "Wavelength: " << configuration.wavelength_list[n_lambda] << " m (" << n_lambda + 1 << " / " << configuration.wavelength_list.size() << ")" << std::endl;
			}
		}

		AtmosphereModel atmos_model = atmosphere_model;
				
		if(configuration.is_wavenumber == true)
		{
			double wavenumber = configuration.wavenumber_list[n_lambda];
			result.wavenumber[n_lambda] = wavenumber;
			runMonochrome(atmos_model, wavenumber);
		}
		else
		{
			double wavelength = configuration.wavelength_list[n_lambda];
			result.wavelength[n_lambda] = wavelength;
			runMonochrome(atmos_model, 1.0 / wavelength);
		}

		// std::cout << "thru." << std::endl;

		if(n_lambda == 0)
		{
			std::vector<double> z, z_top, z_bottom, dz, T, P, ND;
			for(int i = 0; i < atmos_model.layers.size(); i ++)
			{
				z.push_back(atmos_model.layers[i].altitude);
				z_top.push_back(atmos_model.layers[i].altitude_top);
				z_bottom.push_back(atmos_model.layers[i].altitude_bottom);
				dz.push_back(atmos_model.layers[i].physical_thickness);
				T.push_back(atmos_model.layers[i].temperature);
				P.push_back(atmos_model.layers[i].pressure);
				ND.push_back(atmos_model.layers[i].number_density);
			}

			result.altitude = z;
			result.altitude_bottom = z_bottom;
			result.altitude_top = z_top;
			result.physical_thickness = dz;
			result.temperature = T;
			result.pressure = P;
			result.number_density = ND;
		}

		result.absorption_coefficient[n_lambda].resize(atmos_model.layers.size());
		result.scattering_coefficient[n_lambda].resize(atmos_model.layers.size());
		result.single_scattering_albedo[n_lambda].resize(atmos_model.layers.size());
		result.optical_thickness[n_lambda].resize(atmos_model.layers.size());
		result.asymmetry_parameter[n_lambda].resize(atmos_model.layers.size());

		for(int i = 0; i < atmos_model.layers.size(); i ++)
		{
			result.optical_thickness[n_lambda][i] = atmos_model.layers[i].optical_thickness;
			result.scattering_coefficient[n_lambda][i] = atmos_model.layers[i].scattering_coefficient;
			result.absorption_coefficient[n_lambda][i] = atmos_model.layers[i].absorption_coefficient;
			result.single_scattering_albedo[n_lambda][i] = atmos_model.layers[i].single_scattering_albedo;
			result.asymmetry_parameter[n_lambda][i] = atmos_model.layers[i].asymmetry_parameter;
		}

		reconstructOpticalProperties(atmos_model.result_layer);

		result.reflectance_top[n_lambda] = atmos_model.result_layer.reflectance_top;
		result.reflectance_m_top_cos[n_lambda] = atmos_model.result_layer.reflectance_m_top_cos;
		result.reflectance_m_top_sin[n_lambda] = atmos_model.result_layer.reflectance_m_top_sin;
		result.source_up[n_lambda] = atmos_model.result_layer.source_up;
	}

	auto result_tmp = result;

	int n_layer = result.altitude.size();

	result.absorption_coefficient.resize(1, std::vector<double>(n_layer, 0.0));
	result.scattering_coefficient.resize(1, std::vector<double>(n_layer, 0.0));
	result.single_scattering_albedo.resize(1, std::vector<double>(n_layer, 0.0));
	result.optical_thickness.resize(1, std::vector<double>(n_layer, 0.0));
	result.asymmetry_parameter.resize(1, std::vector<double>(n_layer, 0.0));

	result.reflectance_top.resize(1, std::vector<std::vector<std::vector<double>>>(Ntheta, std::vector<std::vector<double>>(Ntheta, std::vector<double>(Nphi, 0.0))));
	result.reflectance_m_top_cos.resize(1, std::vector<Eigen::MatrixXd>(M + 1, Eigen::MatrixXd::Zero(Ntheta, Ntheta)));
	result.reflectance_m_top_sin.resize(1, std::vector<Eigen::MatrixXd>(M + 1, Eigen::MatrixXd::Zero(Ntheta, Ntheta)));
	result.source_up.resize(1, Eigen::VectorXd::Zero(Ntheta));

	double wavenumber_mean = 0.0;
	double wavelength_mean = 0.0;

	for(int i = 0; i < n_x; i ++)
	{
		for(int j = 0; j < n_layer; j ++)
		{
			result.absorption_coefficient[0][j] += result_tmp.absorption_coefficient[i][j] * configuration.window_function[i];
			result.scattering_coefficient[0][j] += result_tmp.scattering_coefficient[i][j] * configuration.window_function[i];
			// result.single_scattering_albedo[0][j] += result_tmp.single_scattering_albedo[i][j] * configuration.window_function[i];
			// result.optical_thickness[0][j] += result_tmp.optical_thickness[i][j] * configuration.window_function[i];
			result.asymmetry_parameter[0][j] += result_tmp.asymmetry_parameter[i][j] * result_tmp.scattering_coefficient[i][j] * configuration.window_function[i];
		}

		for(int j = 0; j < Ntheta; j ++)
		{
			result.source_up[0](j) += result_tmp.source_up[i](j) * configuration.window_function[i];

			for(int k = 0; k < Ntheta; k ++)
			{
				for(int l = 0; l < Nphi; l ++)
				{
					result.reflectance_top[0][j][k][l] += result_tmp.reflectance_top[i][j][k][l] * configuration.window_function[i];
				}
			}
		}

		for(int j = 0; j <= M; j ++)
		{
			for(int k = 0; k < Ntheta; k ++)
			{
				for(int l = 0; l < Ntheta; l ++)
				{
					result.reflectance_m_top_cos[0][j](k, l) += result_tmp.reflectance_m_top_cos[i][j](k, l) * configuration.window_function[i];
					result.reflectance_m_top_sin[0][j](k, l) += result_tmp.reflectance_m_top_sin[i][j](k, l) * configuration.window_function[i];
				}
			}
		}

		wavenumber_mean += (configuration.is_wavenumber == true ? configuration.wavenumber_list[i] : 1.0 / configuration.wavelength_list[i]) * configuration.window_function[i];
		wavelength_mean += (configuration.is_wavenumber == true ? 1.0 / configuration.wavenumber_list[i] : configuration.wavelength_list[i]) * configuration.window_function[i];
	}

	for(int j = 0; j < n_layer; j ++)
	{
		result.single_scattering_albedo[0][j] = result.scattering_coefficient[0][j] / (result.scattering_coefficient[0][j] + result.absorption_coefficient[0][j]);
		result.asymmetry_parameter[0][j] /= result.scattering_coefficient[0][j];
		result.optical_thickness[0][j] = (result.scattering_coefficient[0][j] + result.absorption_coefficient[0][j]) * result.physical_thickness[j];
	}

	result.wavenumber = {wavenumber_mean};
	result.wavelength = {wavelength_mean};
	
	return;
}

inline void RadiativeTransfer::run(void)
{
	if(configuration.wavenumber_type == WavenumberType::Bandpass || configuration.wavelength_type == WavelengthType::Bandpass)
	{
		configuration.importConfiguration(config_filename);
		AtmosphereModel atmosphere_model;
		computeAtmosphericProperties(atmosphere_model);
		computeSpeciesProperties(atmosphere_model);
		initializeGeometry();
		runBandpass(atmosphere_model);
	}
	else if(configuration.wavenumber_type == WavenumberType::Spectrum || configuration.wavelength_type == WavelengthType::Spectrum)
	{
		configuration.importConfiguration(config_filename);
		AtmosphereModel atmosphere_model;
		computeAtmosphericProperties(atmosphere_model);
		computeSpeciesProperties(atmosphere_model);
		initializeGeometry();
		runSpectrum(atmosphere_model);
	}
	else if(configuration.wavenumber_type == WavenumberType::Monochrome || configuration.wavelength_type == WavelengthType::Monochrome)
	{
		configuration.importConfiguration(config_filename);
		AtmosphereModel atmosphere_model;
		computeAtmosphericProperties(atmosphere_model);
		computeSpeciesProperties(atmosphere_model);
		initializeGeometry();
		configuration.is_instrument = false;
		runSpectrum(atmosphere_model);
	}

	return;
}

/*
inline JacobianResult computeJacobianSpecies(std::string config_filename, JacobianType jacobian_type, int n_species, double delta = 0.01)
{
	JacobianResult result;

	Configuration cfg;

	try
	{
		cfg.importConfiguration(config_filename);
	}
	catch(const std::exception &e)
	{
		std::cerr << "Configuration import failed: " << e.what() << std::endl;
	}

	double wavenumber = cfg.is_wavenumber == true ? cfg.wavenumber_list[0] : 1.0 / cfg.wavelength_list[0];

	if((cfg.is_wavenumber == true && cfg.wavenumber_type == WavenumberType::Monochrome) || (cfg.is_wavenumber == false && cfg.wavelength_type == WavelengthType::Monochrome))
	{
		int n_layer;

		if(cfg.z_edge.size() > 0)
		{
			n_layer = cfg.z_edge.size() - 1;
		}
		else if(cfg.z_center.size() > 0)
		{
			n_layer = cfg.z_center.size();
		}
		else
		{
			throw std::runtime_error("Altitude coordinate not specified.");
		}

		result.initialize(n_layer);

		//results.resize(n_layer);

		if(jacobian_type == JacobianType::Temperature)
		{
			#pragma omp parallel for
			for(int nl = 0; nl < n_layer; nl ++)
			{
				#pragma omp critical
				{
					std::cout << "Layer " << nl << std::endl;
				}
				
				AtmosphereModel atmosphere_model_plus;
				RadiativeTransfer rtm_plus;
				rtm_plus.configuration = cfg;
				rtm_plus.computeAtmosphericProperties(atmosphere_model_plus);
				double temperature_base = atmosphere_model_plus.layers[nl].temperature;
				atmosphere_model_plus.layers[nl].temperature *= (1.0 + delta);
				rtm_plus.computeSpeciesProperties(atmosphere_model_plus);
				rtm_plus.initializeGeometry();
				rtm_plus.runMonochrome(atmosphere_model_plus, wavenumber);

				AtmosphereModel atmosphere_model_minus;
				RadiativeTransfer rtm_minus;
				rtm_minus.configuration = cfg;
				rtm_minus.computeAtmosphericProperties(atmosphere_model_minus);
				atmosphere_model_minus.layers[nl].temperature *= (1.0 - delta);
				rtm_minus.computeSpeciesProperties(atmosphere_model_minus);
				rtm_minus.initializeGeometry();
				rtm_minus.runMonochrome(atmosphere_model_minus, wavenumber);

				if(nl == 0)
				{
					result.emission_zenith_angle = std::vector<double>(rtm_plus.geometry.theta_uh.data(), rtm_plus.geometry.theta_uh.data() + rtm_plus.geometry.theta_uh.size());
				}

				result.altitude[nl] = atmosphere_model_plus.layers[nl].altitude;
				result.weighting_function[nl] = (atmosphere_model_plus.result_layer.source_up - atmosphere_model_minus.result_layer.source_up) / (2.0 * delta * temperature_base);
				result.contribution_function[nl] = (atmosphere_model_plus.result_layer.source_up - atmosphere_model_minus.result_layer.source_up) / (2.0 * delta * temperature_base) * temperature_base;
			}
		}
		else if(jacobian_type == JacobianType::TotalNumberDensity)
		{
			#pragma omp parallel for
			for(int nl = 0; nl < n_layer; nl ++)
			{
				#pragma omp critical
				{
					std::cout << "Layer " << nl << std::endl;
				}
				
				AtmosphereModel atmosphere_model_plus;
				RadiativeTransfer rtm_plus;
				rtm_plus.configuration = cfg;
				rtm_plus.computeAtmosphericProperties(atmosphere_model_plus);
				double number_density_base = atmosphere_model_plus.layers[nl].number_density;
				atmosphere_model_plus.layers[nl].number_density *= (1.0 + delta);
				rtm_plus.computeSpeciesProperties(atmosphere_model_plus);
				rtm_plus.initializeGeometry();
				rtm_plus.runMonochrome(atmosphere_model_plus, wavenumber);

				AtmosphereModel atmosphere_model_minus;
				RadiativeTransfer rtm_minus;
				rtm_minus.configuration = cfg;
				rtm_minus.computeAtmosphericProperties(atmosphere_model_minus);
				atmosphere_model_minus.layers[nl].number_density *= (1.0 - delta);
				rtm_minus.computeSpeciesProperties(atmosphere_model_minus);
				rtm_minus.initializeGeometry();
				rtm_minus.runMonochrome(atmosphere_model_minus, wavenumber);

				if(nl == 0)
				{
					result.emission_zenith_angle = std::vector<double>(rtm_plus.geometry.theta_uh.data(), rtm_plus.geometry.theta_uh.data() + rtm_plus.geometry.theta_uh.size());
				}

				result.altitude[nl] = atmosphere_model_plus.layers[nl].altitude;
				result.weighting_function[nl] = (atmosphere_model_plus.result_layer.source_up - atmosphere_model_minus.result_layer.source_up) / (2.0 * delta * number_density_base);
				result.contribution_function[nl] = (atmosphere_model_plus.result_layer.source_up - atmosphere_model_minus.result_layer.source_up) / (2.0 * delta * number_density_base) * number_density_base;
			}
		}
		else if(jacobian_type == JacobianType::SpeciesNumberDensity)
		{
			#pragma omp parallel for
			for(int nl = 0; nl < n_layer; nl ++)
			{
				#pragma omp critical
				{
					std::cout << "Layer " << nl << std::endl;
				}
				
				AtmosphereModel atmosphere_model_plus;
				RadiativeTransfer rtm_plus;
				rtm_plus.configuration = cfg;
				rtm_plus.computeAtmosphericProperties(atmosphere_model_plus);
				rtm_plus.computeSpeciesProperties(atmosphere_model_plus);
				double number_density_base = atmosphere_model_plus.layers[nl].number_density_species[n_species];
				atmosphere_model_plus.layers[nl].number_density_species[n_species] *= (1.0 + delta);
				rtm_plus.initializeGeometry();
				rtm_plus.runMonochrome(atmosphere_model_plus, wavenumber);

				AtmosphereModel atmosphere_model_minus;
				RadiativeTransfer rtm_minus;
				rtm_minus.configuration = cfg;
				rtm_minus.computeAtmosphericProperties(atmosphere_model_minus);
				rtm_minus.computeSpeciesProperties(atmosphere_model_minus);
				atmosphere_model_minus.layers[nl].number_density_species[n_species] *= (1.0 - delta);
				rtm_minus.initializeGeometry();
				rtm_minus.runMonochrome(atmosphere_model_minus, wavenumber);

				if(nl == 0)
				{
					result.emission_zenith_angle = std::vector<double>(rtm_plus.geometry.theta_uh.data(), rtm_plus.geometry.theta_uh.data() + rtm_plus.geometry.theta_uh.size());
				}

				result.altitude[nl] = atmosphere_model_plus.layers[nl].altitude;
				result.weighting_function[nl] = (atmosphere_model_plus.result_layer.source_up - atmosphere_model_minus.result_layer.source_up) / (2.0 * delta * number_density_base);
				result.contribution_function[nl] = (atmosphere_model_plus.result_layer.source_up - atmosphere_model_minus.result_layer.source_up) / (2.0 * delta * number_density_base) * number_density_base;
			}
		}
		else if(jacobian_type == JacobianType::SpeciesMixingRatio)
		{
			#pragma omp parallel for
			for(int nl = 0; nl < n_layer; nl ++)
			{
				#pragma omp critical
				{
					std::cout << "Layer " << nl << std::endl;
				}
				
				AtmosphereModel atmosphere_model_plus;
				RadiativeTransfer rtm_plus;
				rtm_plus.configuration = cfg;
				rtm_plus.computeAtmosphericProperties(atmosphere_model_plus);
				rtm_plus.computeSpeciesProperties(atmosphere_model_plus);
				double mixing_ratio_base = atmosphere_model_plus.layers[nl].mixing_ratio_species[n_species];
				atmosphere_model_plus.layers[nl].mixing_ratio_species[n_species] *= (1.0 + delta);
				atmosphere_model_plus.layers[nl].number_density_species[n_species] = atmosphere_model_plus.layers[nl].number_density * atmosphere_model_plus.layers[nl].mixing_ratio_species[n_species];
				rtm_plus.initializeGeometry();
				rtm_plus.runMonochrome(atmosphere_model_plus, wavenumber);

				AtmosphereModel atmosphere_model_minus;
				RadiativeTransfer rtm_minus;
				rtm_minus.configuration = cfg;
				rtm_minus.computeAtmosphericProperties(atmosphere_model_minus);
				rtm_minus.computeSpeciesProperties(atmosphere_model_minus);
				atmosphere_model_minus.layers[nl].mixing_ratio_species[n_species] *= (1.0 - delta);
				atmosphere_model_minus.layers[nl].number_density_species[n_species] = atmosphere_model_minus.layers[nl].number_density * atmosphere_model_minus.layers[nl].mixing_ratio_species[n_species];
				rtm_minus.initializeGeometry();
				rtm_minus.runMonochrome(atmosphere_model_minus, wavenumber);

				if(nl == 0)
				{
					result.emission_zenith_angle = std::vector<double>(rtm_plus.geometry.theta_uh.data(), rtm_plus.geometry.theta_uh.data() + rtm_plus.geometry.theta_uh.size());
				}

				result.altitude[nl] = atmosphere_model_plus.layers[nl].altitude;
				result.weighting_function[nl] = (atmosphere_model_plus.result_layer.source_up - atmosphere_model_minus.result_layer.source_up) / (2.0 * delta * mixing_ratio_base);
				result.contribution_function[nl] = (atmosphere_model_plus.result_layer.source_up - atmosphere_model_minus.result_layer.source_up) / (2.0 * delta * mixing_ratio_base) * mixing_ratio_base;
			}
		}
	}
	else
	{
		throw std::runtime_error("Computing spectral Jacobian is currently not supported.");
	}

	return result;
}
*/

inline JacobianResult computeJacobian(std::string config_filename, JacobianType jacobian_type, double delta = 0.01)
{
	if(jacobian_type == JacobianType::SpeciesMixingRatio || jacobian_type == JacobianType::SpeciesNumberDensity)
	{
		throw std::runtime_error("Use computeJacobianSpecies.");
	}

	return computeJacobianSpecies(config_filename, jacobian_type, 0, delta);
}

inline JacobianResult computeJacobianSpecies(std::string config_filename, JacobianType jacobian_type, int n_species, double delta = 0.01)
{
	JacobianResult result;

	Configuration cfg;

	try
	{
		cfg.importConfiguration(config_filename);
	}
	catch(const std::exception &e)
	{
		std::cerr << "Configuration import failed: " << e.what() << std::endl;
	}

	if((cfg.wavenumber_type == WavenumberType::Spectrum) || (cfg.wavenumber_type == WavenumberType::Spectrum) || (cfg.wavenumber_type == WavenumberType::Table) || (cfg.wavenumber_type == WavenumberType::Table))
	{
		throw std::runtime_error("Use monochrome or bandpass for the jacobian calculations.");
	}
	else
	{
		int n_layer;

		if(cfg.z_edge.size() > 0)
		{
			n_layer = cfg.z_edge.size() - 1;
		}
		else if(cfg.z_center.size() > 0)
		{
			n_layer = cfg.z_center.size();
		}
		else
		{
			std::cout << cfg.z_edge.size() << ", " << cfg.z_center.size() << std::endl;
			throw std::runtime_error("Altitude coordinate not specified.");
		}

		result.initialize(n_layer);

		//results.resize(n_layer);

		if(jacobian_type == JacobianType::Temperature)
		{
			#pragma omp parallel for
			for(int nl = 0; nl < n_layer; nl ++)
			{
				#pragma omp critical
				{
					std::cout << "Layer " << nl << std::endl;
				}
				
				AtmosphereModel atmosphere_model_plus;
				RadiativeTransfer rtm_plus;
				rtm_plus.configuration = cfg;
				rtm_plus.computeAtmosphericProperties(atmosphere_model_plus);
				double temperature_base = atmosphere_model_plus.layers[nl].temperature;
				atmosphere_model_plus.layers[nl].temperature *= (1.0 + delta);
				rtm_plus.computeSpeciesProperties(atmosphere_model_plus);
				rtm_plus.initializeGeometry();
				if(cfg.wavenumber_type == WavenumberType::Bandpass || cfg.wavelength_type == WavelengthType::Bandpass)
				{
					rtm_plus.runBandpass(atmosphere_model_plus);
				}
				else if(cfg.wavenumber_type == WavenumberType::Monochrome || cfg.wavelength_type == WavelengthType::Monochrome)
				{
					rtm_plus.configuration.is_instrument = false;
					rtm_plus.runSpectrum(atmosphere_model_plus);
				}

				AtmosphereModel atmosphere_model_minus;
				RadiativeTransfer rtm_minus;
				rtm_minus.configuration = cfg;
				rtm_minus.computeAtmosphericProperties(atmosphere_model_minus);
				atmosphere_model_minus.layers[nl].temperature *= (1.0 - delta);
				rtm_minus.computeSpeciesProperties(atmosphere_model_minus);
				rtm_minus.initializeGeometry();
				if(cfg.wavenumber_type == WavenumberType::Bandpass || cfg.wavelength_type == WavelengthType::Bandpass)
				{
					rtm_minus.runBandpass(atmosphere_model_minus);
				}
				else if(cfg.wavenumber_type == WavenumberType::Monochrome || cfg.wavelength_type == WavelengthType::Monochrome)
				{
					rtm_minus.configuration.is_instrument = false;
					rtm_minus.runSpectrum(atmosphere_model_minus);
				}

				if(nl == 0)
				{
					result.Ntheta = rtm_plus.Ntheta;
					result.Nphi = rtm_plus.Nphi;
					result.Nmode = rtm_plus.M;
					result.emission_zenith_angle = std::vector<double>(rtm_plus.geometry.theta_uh.data(), rtm_plus.geometry.theta_uh.data() + rtm_plus.geometry.theta_uh.size());
					result.incidence_zenith_angle = std::vector<double>(rtm_plus.geometry.theta_uh.data(), rtm_plus.geometry.theta_uh.data() + rtm_plus.geometry.theta_uh.size());
					result.emission_azimuth_angle = std::vector<double>(rtm_plus.geometry.phi.data(), rtm_plus.geometry.phi.data() + rtm_plus.geometry.phi.size());
				}

				result.altitude[nl] = atmosphere_model_plus.layers[nl].altitude;

				result.weighting_function_source_up[nl] = Eigen::VectorXd::Zero(rtm_plus.Ntheta);
				result.contribution_function_source_up[nl] = Eigen::VectorXd::Zero(rtm_plus.Ntheta);
				result.weighting_function_reflectance_top[nl] = std::vector<std::vector<std::vector<double>>>(rtm_plus.Ntheta, std::vector<std::vector<double>>(rtm_plus.Ntheta, std::vector<double>(rtm_plus.Nphi, 0.0)));
				result.contribution_function_reflectance_top[nl] = std::vector<std::vector<std::vector<double>>>(rtm_plus.Ntheta, std::vector<std::vector<double>>(rtm_plus.Ntheta, std::vector<double>(rtm_plus.Nphi, 0.0)));
				result.weighting_function_reflectance_m_top_cos[nl] = std::vector<Eigen::MatrixXd>(rtm_plus.M + 1, Eigen::MatrixXd::Zero(rtm_plus.Ntheta, rtm_plus.Ntheta));
				result.contribution_function_reflectance_m_top_cos[nl] = std::vector<Eigen::MatrixXd>(rtm_plus.M + 1, Eigen::MatrixXd::Zero(rtm_plus.Ntheta, rtm_plus.Ntheta));
				result.weighting_function_reflectance_m_top_sin[nl] = std::vector<Eigen::MatrixXd>(rtm_plus.M + 1, Eigen::MatrixXd::Zero(rtm_plus.Ntheta, rtm_plus.Ntheta));
				result.contribution_function_reflectance_m_top_sin[nl] = std::vector<Eigen::MatrixXd>(rtm_plus.M + 1, Eigen::MatrixXd::Zero(rtm_plus.Ntheta, rtm_plus.Ntheta));

				result.weighting_function_source_up[nl] = (rtm_plus.result.source_up[0] - rtm_minus.result.source_up[0]) / (2.0 * delta * temperature_base);
				result.contribution_function_source_up[nl] = (rtm_plus.result.source_up[0] - rtm_minus.result.source_up[0]) / (2.0 * delta * temperature_base) * temperature_base;

				for(int i = 0; i < rtm_plus.Ntheta; i ++)
				{
					for(int j = 0; j < rtm_plus.Ntheta; j ++)
					{
						for(int k = 0; k < rtm_plus.Nphi; k ++)
						{
							result.weighting_function_reflectance_top[nl][i][j][k] = (rtm_plus.result.reflectance_top[0][i][j][k] - rtm_minus.result.reflectance_top[0][i][j][k]) / (2.0 * delta * temperature_base);
							result.contribution_function_reflectance_top[nl][i][j][k] = (rtm_plus.result.reflectance_top[0][i][j][k] - rtm_minus.result.reflectance_top[0][i][j][k]) / (2.0 * delta * temperature_base) * temperature_base;
						}
					}
				}

				for(int i = 0; i <= rtm_plus.M; i ++)
				{
					result.weighting_function_reflectance_m_top_cos[nl][i] = (rtm_plus.result.reflectance_m_top_cos[0][i] - rtm_minus.result.reflectance_m_top_cos[0][i]) / (2.0 * delta * temperature_base);
					result.contribution_function_reflectance_m_top_cos[nl][i] = (rtm_plus.result.reflectance_m_top_cos[0][i] - rtm_minus.result.reflectance_m_top_cos[0][i]) / (2.0 * delta * temperature_base) * temperature_base;
					result.weighting_function_reflectance_m_top_sin[nl][i] = (rtm_plus.result.reflectance_m_top_sin[0][i] - rtm_minus.result.reflectance_m_top_sin[0][i]) / (2.0 * delta * temperature_base);
					result.contribution_function_reflectance_m_top_sin[nl][i] = (rtm_plus.result.reflectance_m_top_sin[0][i] - rtm_minus.result.reflectance_m_top_sin[0][i]) / (2.0 * delta * temperature_base) * temperature_base;
				}
			}
		}
		else if(jacobian_type == JacobianType::TotalNumberDensity)
		{
			#pragma omp parallel for
			for(int nl = 0; nl < n_layer; nl ++)
			{
				#pragma omp critical
				{
					std::cout << "Layer " << nl << std::endl;
				}
				
				AtmosphereModel atmosphere_model_plus;
				RadiativeTransfer rtm_plus;
				rtm_plus.configuration = cfg;
				rtm_plus.computeAtmosphericProperties(atmosphere_model_plus);
				double number_density_base = atmosphere_model_plus.layers[nl].number_density;
				atmosphere_model_plus.layers[nl].number_density *= (1.0 + delta);
				rtm_plus.computeSpeciesProperties(atmosphere_model_plus);
				rtm_plus.initializeGeometry();
				if(cfg.wavenumber_type == WavenumberType::Bandpass || cfg.wavelength_type == WavelengthType::Bandpass)
				{
					rtm_plus.runBandpass(atmosphere_model_plus);
				}
				else if(cfg.wavenumber_type == WavenumberType::Monochrome || cfg.wavelength_type == WavelengthType::Monochrome)
				{
					rtm_plus.configuration.is_instrument = false;
					rtm_plus.runSpectrum(atmosphere_model_plus);
				}

				AtmosphereModel atmosphere_model_minus;
				RadiativeTransfer rtm_minus;
				rtm_minus.configuration = cfg;
				rtm_minus.computeAtmosphericProperties(atmosphere_model_minus);
				atmosphere_model_minus.layers[nl].number_density *= (1.0 - delta);
				rtm_minus.computeSpeciesProperties(atmosphere_model_minus);
				rtm_minus.initializeGeometry();
				if(cfg.wavenumber_type == WavenumberType::Bandpass || cfg.wavelength_type == WavelengthType::Bandpass)
				{
					rtm_minus.runBandpass(atmosphere_model_minus);
				}
				else if(cfg.wavenumber_type == WavenumberType::Monochrome || cfg.wavelength_type == WavelengthType::Monochrome)
				{
					rtm_minus.configuration.is_instrument = false;
					rtm_minus.runSpectrum(atmosphere_model_minus);
				}

				if(nl == 0)
				{
					result.Ntheta = rtm_plus.Ntheta;
					result.Nphi = rtm_plus.Nphi;
					result.Nmode = rtm_plus.M;
					result.emission_zenith_angle = std::vector<double>(rtm_plus.geometry.theta_uh.data(), rtm_plus.geometry.theta_uh.data() + rtm_plus.geometry.theta_uh.size());
					result.incidence_zenith_angle = std::vector<double>(rtm_plus.geometry.theta_uh.data(), rtm_plus.geometry.theta_uh.data() + rtm_plus.geometry.theta_uh.size());
					result.emission_azimuth_angle = std::vector<double>(rtm_plus.geometry.phi.data(), rtm_plus.geometry.phi.data() + rtm_plus.geometry.phi.size());
				}

				result.altitude[nl] = atmosphere_model_plus.layers[nl].altitude;

				result.weighting_function_source_up[nl] = Eigen::VectorXd::Zero(rtm_plus.Ntheta);
				result.contribution_function_source_up[nl] = Eigen::VectorXd::Zero(rtm_plus.Ntheta);
				result.weighting_function_reflectance_top[nl] = std::vector<std::vector<std::vector<double>>>(rtm_plus.Ntheta, std::vector<std::vector<double>>(rtm_plus.Ntheta, std::vector<double>(rtm_plus.Nphi, 0.0)));
				result.contribution_function_reflectance_top[nl] = std::vector<std::vector<std::vector<double>>>(rtm_plus.Ntheta, std::vector<std::vector<double>>(rtm_plus.Ntheta, std::vector<double>(rtm_plus.Nphi, 0.0)));
				result.weighting_function_reflectance_m_top_cos[nl] = std::vector<Eigen::MatrixXd>(rtm_plus.M + 1, Eigen::MatrixXd::Zero(rtm_plus.Ntheta, rtm_plus.Ntheta));
				result.contribution_function_reflectance_m_top_cos[nl] = std::vector<Eigen::MatrixXd>(rtm_plus.M + 1, Eigen::MatrixXd::Zero(rtm_plus.Ntheta, rtm_plus.Ntheta));
				result.weighting_function_reflectance_m_top_sin[nl] = std::vector<Eigen::MatrixXd>(rtm_plus.M + 1, Eigen::MatrixXd::Zero(rtm_plus.Ntheta, rtm_plus.Ntheta));
				result.contribution_function_reflectance_m_top_sin[nl] = std::vector<Eigen::MatrixXd>(rtm_plus.M + 1, Eigen::MatrixXd::Zero(rtm_plus.Ntheta, rtm_plus.Ntheta));

				result.weighting_function_source_up[nl] = (rtm_plus.result.source_up[0] - rtm_minus.result.source_up[0]) / (2.0 * delta * number_density_base);
				result.contribution_function_source_up[nl] = (rtm_plus.result.source_up[0] - rtm_minus.result.source_up[0]) / (2.0 * delta * number_density_base) * number_density_base;

				for(int i = 0; i < rtm_plus.Ntheta; i ++)
				{
					for(int j = 0; j < rtm_plus.Ntheta; j ++)
					{
						for(int k = 0; k < rtm_plus.Nphi; k ++)
						{
							result.weighting_function_reflectance_top[nl][i][j][k] = (rtm_plus.result.reflectance_top[0][i][j][k] - rtm_minus.result.reflectance_top[0][i][j][k]) / (2.0 * delta * number_density_base);
							result.contribution_function_reflectance_top[nl][i][j][k] = (rtm_plus.result.reflectance_top[0][i][j][k] - rtm_minus.result.reflectance_top[0][i][j][k]) / (2.0 * delta * number_density_base) * number_density_base;
						}
					}
				}

				for(int i = 0; i <= rtm_plus.M; i ++)
				{
					result.weighting_function_reflectance_m_top_cos[nl][i] = (rtm_plus.result.reflectance_m_top_cos[0][i] - rtm_minus.result.reflectance_m_top_cos[0][i]) / (2.0 * delta * number_density_base);
					result.contribution_function_reflectance_m_top_cos[nl][i] = (rtm_plus.result.reflectance_m_top_cos[0][i] - rtm_minus.result.reflectance_m_top_cos[0][i]) / (2.0 * delta * number_density_base) * number_density_base;
					result.weighting_function_reflectance_m_top_sin[nl][i] = (rtm_plus.result.reflectance_m_top_sin[0][i] - rtm_minus.result.reflectance_m_top_sin[0][i]) / (2.0 * delta * number_density_base);
					result.contribution_function_reflectance_m_top_sin[nl][i] = (rtm_plus.result.reflectance_m_top_sin[0][i] - rtm_minus.result.reflectance_m_top_sin[0][i]) / (2.0 * delta * number_density_base) * number_density_base;
				}
			}
		}
		else if(jacobian_type == JacobianType::SpeciesNumberDensity)
		{
			#pragma omp parallel for
			for(int nl = 0; nl < n_layer; nl ++)
			{
				#pragma omp critical
				{
					std::cout << "Layer " << nl << std::endl;
				}
				
				AtmosphereModel atmosphere_model_plus;
				RadiativeTransfer rtm_plus;
				rtm_plus.configuration = cfg;
				rtm_plus.computeAtmosphericProperties(atmosphere_model_plus);
				rtm_plus.computeSpeciesProperties(atmosphere_model_plus);
				double number_density_base = atmosphere_model_plus.layers[nl].number_density_species[n_species];
				atmosphere_model_plus.layers[nl].number_density_species[n_species] *= (1.0 + delta);
				rtm_plus.initializeGeometry();
				if(cfg.wavenumber_type == WavenumberType::Bandpass || cfg.wavelength_type == WavelengthType::Bandpass)
				{
					rtm_plus.runBandpass(atmosphere_model_plus);
				}
				else if(cfg.wavenumber_type == WavenumberType::Monochrome || cfg.wavelength_type == WavelengthType::Monochrome)
				{
					rtm_plus.configuration.is_instrument = false;
					rtm_plus.runSpectrum(atmosphere_model_plus);
				}

				AtmosphereModel atmosphere_model_minus;
				RadiativeTransfer rtm_minus;
				rtm_minus.configuration = cfg;
				rtm_minus.computeAtmosphericProperties(atmosphere_model_minus);
				rtm_minus.computeSpeciesProperties(atmosphere_model_minus);
				atmosphere_model_minus.layers[nl].number_density_species[n_species] *= (1.0 - delta);
				rtm_minus.initializeGeometry();
				if(cfg.wavenumber_type == WavenumberType::Bandpass || cfg.wavelength_type == WavelengthType::Bandpass)
				{
					rtm_minus.runBandpass(atmosphere_model_minus);
				}
				else if(cfg.wavenumber_type == WavenumberType::Monochrome || cfg.wavelength_type == WavelengthType::Monochrome)
				{
					rtm_minus.configuration.is_instrument = false;
					rtm_minus.runSpectrum(atmosphere_model_minus);
				}

				if(nl == 0)
				{
					result.Ntheta = rtm_plus.Ntheta;
					result.Nphi = rtm_plus.Nphi;
					result.Nmode = rtm_plus.M;
					result.emission_zenith_angle = std::vector<double>(rtm_plus.geometry.theta_uh.data(), rtm_plus.geometry.theta_uh.data() + rtm_plus.geometry.theta_uh.size());
					result.incidence_zenith_angle = std::vector<double>(rtm_plus.geometry.theta_uh.data(), rtm_plus.geometry.theta_uh.data() + rtm_plus.geometry.theta_uh.size());
					result.emission_azimuth_angle = std::vector<double>(rtm_plus.geometry.phi.data(), rtm_plus.geometry.phi.data() + rtm_plus.geometry.phi.size());
				}

				result.altitude[nl] = atmosphere_model_plus.layers[nl].altitude;

				result.weighting_function_source_up[nl] = Eigen::VectorXd::Zero(rtm_plus.Ntheta);
				result.contribution_function_source_up[nl] = Eigen::VectorXd::Zero(rtm_plus.Ntheta);
				result.weighting_function_reflectance_top[nl] = std::vector<std::vector<std::vector<double>>>(rtm_plus.Ntheta, std::vector<std::vector<double>>(rtm_plus.Ntheta, std::vector<double>(rtm_plus.Nphi, 0.0)));
				result.contribution_function_reflectance_top[nl] = std::vector<std::vector<std::vector<double>>>(rtm_plus.Ntheta, std::vector<std::vector<double>>(rtm_plus.Ntheta, std::vector<double>(rtm_plus.Nphi, 0.0)));
				result.weighting_function_reflectance_m_top_cos[nl] = std::vector<Eigen::MatrixXd>(rtm_plus.M + 1, Eigen::MatrixXd::Zero(rtm_plus.Ntheta, rtm_plus.Ntheta));
				result.contribution_function_reflectance_m_top_cos[nl] = std::vector<Eigen::MatrixXd>(rtm_plus.M + 1, Eigen::MatrixXd::Zero(rtm_plus.Ntheta, rtm_plus.Ntheta));
				result.weighting_function_reflectance_m_top_sin[nl] = std::vector<Eigen::MatrixXd>(rtm_plus.M + 1, Eigen::MatrixXd::Zero(rtm_plus.Ntheta, rtm_plus.Ntheta));
				result.contribution_function_reflectance_m_top_sin[nl] = std::vector<Eigen::MatrixXd>(rtm_plus.M + 1, Eigen::MatrixXd::Zero(rtm_plus.Ntheta, rtm_plus.Ntheta));

				result.weighting_function_source_up[nl] = (rtm_plus.result.source_up[0] - rtm_minus.result.source_up[0]) / (2.0 * delta * number_density_base);
				result.contribution_function_source_up[nl] = (rtm_plus.result.source_up[0] - rtm_minus.result.source_up[0]) / (2.0 * delta * number_density_base) * number_density_base;

				for(int i = 0; i < rtm_plus.Ntheta; i ++)
				{
					for(int j = 0; j < rtm_plus.Ntheta; j ++)
					{
						for(int k = 0; k < rtm_plus.Nphi; k ++)
						{
							result.weighting_function_reflectance_top[nl][i][j][k] = (rtm_plus.result.reflectance_top[0][i][j][k] - rtm_minus.result.reflectance_top[0][i][j][k]) / (2.0 * delta * number_density_base);
							result.contribution_function_reflectance_top[nl][i][j][k] = (rtm_plus.result.reflectance_top[0][i][j][k] - rtm_minus.result.reflectance_top[0][i][j][k]) / (2.0 * delta * number_density_base) * number_density_base;
						}
					}
				}

				for(int i = 0; i <= rtm_plus.M; i ++)
				{
					result.weighting_function_reflectance_m_top_cos[nl][i] = (rtm_plus.result.reflectance_m_top_cos[0][i] - rtm_minus.result.reflectance_m_top_cos[0][i]) / (2.0 * delta * number_density_base);
					result.contribution_function_reflectance_m_top_cos[nl][i] = (rtm_plus.result.reflectance_m_top_cos[0][i] - rtm_minus.result.reflectance_m_top_cos[0][i]) / (2.0 * delta * number_density_base) * number_density_base;
					result.weighting_function_reflectance_m_top_sin[nl][i] = (rtm_plus.result.reflectance_m_top_sin[0][i] - rtm_minus.result.reflectance_m_top_sin[0][i]) / (2.0 * delta * number_density_base);
					result.contribution_function_reflectance_m_top_sin[nl][i] = (rtm_plus.result.reflectance_m_top_sin[0][i] - rtm_minus.result.reflectance_m_top_sin[0][i]) / (2.0 * delta * number_density_base) * number_density_base;
				}
			}
		}
		else if(jacobian_type == JacobianType::SpeciesMixingRatio)
		{
			#pragma omp parallel for
			for(int nl = 0; nl < n_layer; nl ++)
			{
				#pragma omp critical
				{
					std::cout << "Layer " << nl << std::endl;
				}
				
				AtmosphereModel atmosphere_model_plus;
				RadiativeTransfer rtm_plus;
				rtm_plus.configuration = cfg;
				rtm_plus.computeAtmosphericProperties(atmosphere_model_plus);
				rtm_plus.computeSpeciesProperties(atmosphere_model_plus);
				double mixing_ratio_base = atmosphere_model_plus.layers[nl].mixing_ratio_species[n_species];
				atmosphere_model_plus.layers[nl].mixing_ratio_species[n_species] *= (1.0 + delta);
				atmosphere_model_plus.layers[nl].number_density_species[n_species] = atmosphere_model_plus.layers[nl].number_density * atmosphere_model_plus.layers[nl].mixing_ratio_species[n_species];
				rtm_plus.initializeGeometry();
				if(cfg.wavenumber_type == WavenumberType::Bandpass || cfg.wavelength_type == WavelengthType::Bandpass)
				{
					rtm_plus.runBandpass(atmosphere_model_plus);
				}
				else if(cfg.wavenumber_type == WavenumberType::Monochrome || cfg.wavelength_type == WavelengthType::Monochrome)
				{
					rtm_plus.configuration.is_instrument = false;
					rtm_plus.runSpectrum(atmosphere_model_plus);
				}

				AtmosphereModel atmosphere_model_minus;
				RadiativeTransfer rtm_minus;
				rtm_minus.configuration = cfg;
				rtm_minus.computeAtmosphericProperties(atmosphere_model_minus);
				rtm_minus.computeSpeciesProperties(atmosphere_model_minus);
				atmosphere_model_minus.layers[nl].mixing_ratio_species[n_species] *= (1.0 - delta);
				atmosphere_model_minus.layers[nl].number_density_species[n_species] = atmosphere_model_minus.layers[nl].number_density * atmosphere_model_minus.layers[nl].mixing_ratio_species[n_species];
				rtm_minus.initializeGeometry();
				if(cfg.wavenumber_type == WavenumberType::Bandpass || cfg.wavelength_type == WavelengthType::Bandpass)
				{
					rtm_minus.runBandpass(atmosphere_model_minus);
				}
				else if(cfg.wavenumber_type == WavenumberType::Monochrome || cfg.wavelength_type == WavelengthType::Monochrome)
				{
					rtm_minus.configuration.is_instrument = false;
					rtm_minus.runSpectrum(atmosphere_model_minus);
				}

				if(nl == 0)
				{
					result.Ntheta = rtm_plus.Ntheta;
					result.Nphi = rtm_plus.Nphi;
					result.Nmode = rtm_plus.M;
					result.emission_zenith_angle = std::vector<double>(rtm_plus.geometry.theta_uh.data(), rtm_plus.geometry.theta_uh.data() + rtm_plus.geometry.theta_uh.size());
					result.incidence_zenith_angle = std::vector<double>(rtm_plus.geometry.theta_uh.data(), rtm_plus.geometry.theta_uh.data() + rtm_plus.geometry.theta_uh.size());
					result.emission_azimuth_angle = std::vector<double>(rtm_plus.geometry.phi.data(), rtm_plus.geometry.phi.data() + rtm_plus.geometry.phi.size());
				}

				result.altitude[nl] = atmosphere_model_plus.layers[nl].altitude;

				result.weighting_function_source_up[nl] = Eigen::VectorXd::Zero(rtm_plus.Ntheta);
				result.contribution_function_source_up[nl] = Eigen::VectorXd::Zero(rtm_plus.Ntheta);
				result.weighting_function_reflectance_top[nl] = std::vector<std::vector<std::vector<double>>>(rtm_plus.Ntheta, std::vector<std::vector<double>>(rtm_plus.Ntheta, std::vector<double>(rtm_plus.Nphi, 0.0)));
				result.contribution_function_reflectance_top[nl] = std::vector<std::vector<std::vector<double>>>(rtm_plus.Ntheta, std::vector<std::vector<double>>(rtm_plus.Ntheta, std::vector<double>(rtm_plus.Nphi, 0.0)));
				result.weighting_function_reflectance_m_top_cos[nl] = std::vector<Eigen::MatrixXd>(rtm_plus.M + 1, Eigen::MatrixXd::Zero(rtm_plus.Ntheta, rtm_plus.Ntheta));
				result.contribution_function_reflectance_m_top_cos[nl] = std::vector<Eigen::MatrixXd>(rtm_plus.M + 1, Eigen::MatrixXd::Zero(rtm_plus.Ntheta, rtm_plus.Ntheta));
				result.weighting_function_reflectance_m_top_sin[nl] = std::vector<Eigen::MatrixXd>(rtm_plus.M + 1, Eigen::MatrixXd::Zero(rtm_plus.Ntheta, rtm_plus.Ntheta));
				result.contribution_function_reflectance_m_top_sin[nl] = std::vector<Eigen::MatrixXd>(rtm_plus.M + 1, Eigen::MatrixXd::Zero(rtm_plus.Ntheta, rtm_plus.Ntheta));

				result.weighting_function_source_up[nl] = (rtm_plus.result.source_up[0] - rtm_minus.result.source_up[0]) / (2.0 * delta * mixing_ratio_base);
				result.contribution_function_source_up[nl] = (rtm_plus.result.source_up[0] - rtm_minus.result.source_up[0]) / (2.0 * delta * mixing_ratio_base) * mixing_ratio_base;

				for(int i = 0; i < rtm_plus.Ntheta; i ++)
				{
					for(int j = 0; j < rtm_plus.Ntheta; j ++)
					{
						for(int k = 0; k < rtm_plus.Nphi; k ++)
						{
							result.weighting_function_reflectance_top[nl][i][j][k] = (rtm_plus.result.reflectance_top[0][i][j][k] - rtm_minus.result.reflectance_top[0][i][j][k]) / (2.0 * delta * mixing_ratio_base);
							result.contribution_function_reflectance_top[nl][i][j][k] = (rtm_plus.result.reflectance_top[0][i][j][k] - rtm_minus.result.reflectance_top[0][i][j][k]) / (2.0 * delta * mixing_ratio_base) * mixing_ratio_base;
						}
					}
				}

				for(int i = 0; i <= rtm_plus.M; i ++)
				{
					result.weighting_function_reflectance_m_top_cos[nl][i] = (rtm_plus.result.reflectance_m_top_cos[0][i] - rtm_minus.result.reflectance_m_top_cos[0][i]) / (2.0 * delta * mixing_ratio_base);
					result.contribution_function_reflectance_m_top_cos[nl][i] = (rtm_plus.result.reflectance_m_top_cos[0][i] - rtm_minus.result.reflectance_m_top_cos[0][i]) / (2.0 * delta * mixing_ratio_base) * mixing_ratio_base;
					result.weighting_function_reflectance_m_top_sin[nl][i] = (rtm_plus.result.reflectance_m_top_sin[0][i] - rtm_minus.result.reflectance_m_top_sin[0][i]) / (2.0 * delta * mixing_ratio_base);
					result.contribution_function_reflectance_m_top_sin[nl][i] = (rtm_plus.result.reflectance_m_top_sin[0][i] - rtm_minus.result.reflectance_m_top_sin[0][i]) / (2.0 * delta * mixing_ratio_base) * mixing_ratio_base;
				}
			}
		}
	}

	return result;
}

inline JacobianResult computeJacobianRefractiveIndex(std::string config_filename, std::vector<int> n_species, double delta = 0.01)
{
	JacobianResult result;

	Configuration cfg;

	try
	{
		cfg.importConfiguration(config_filename);
	}
	catch(const std::exception &e)
	{
		std::cerr << "Configuration import failed: " << e.what() << std::endl;
	}

	if((cfg.wavenumber_type == WavenumberType::Spectrum) || (cfg.wavenumber_type == WavenumberType::Spectrum) || (cfg.wavenumber_type == WavenumberType::Table) || (cfg.wavenumber_type == WavenumberType::Table))
	{
		throw std::runtime_error("Use monochrome or bandpass for the jacobian calculations.");
	}
	else
	{
		int n_layer;

		if(cfg.z_edge.size() > 0)
		{
			n_layer = cfg.z_edge.size() - 1;
		}
		else if(cfg.z_center.size() > 0)
		{
			n_layer = cfg.z_center.size();
		}
		else
		{
			std::cout << cfg.z_edge.size() << ", " << cfg.z_center.size() << std::endl;
			throw std::runtime_error("Altitude coordinate not specified.");
		}

		result.initialize(n_layer);

		//results.resize(n_layer);

		#pragma omp parallel for
		for(int nl = 0; nl < n_layer; nl ++)
		{
			#pragma omp critical
			{
				std::cout << "Layer " << nl << std::endl;
			}
			
			AtmosphereModel atmosphere_model_plus;
			RadiativeTransfer rtm_plus;
			rtm_plus.configuration = cfg;
			rtm_plus.computeAtmosphericProperties(atmosphere_model_plus);
			rtm_plus.computeSpeciesProperties(atmosphere_model_plus);
			double ni_base = atmosphere_model_plus.species[n_species[0]].ni;

			for(int i = 0; i < n_species.size(); i ++)
			{
				atmosphere_model_plus.species.push_back(atmosphere_model_plus.species[n_species[i]]);
				atmosphere_model_plus.species[atmosphere_model_plus.species.size() - 1].ni = ni_base * (1.0 + delta);

				for(int j = 0; j < n_layer; j ++)
				{
					if(j != nl)
					{
						atmosphere_model_plus.layers[j].mixing_ratio_species[atmosphere_model_plus.species.size() - 1] = 0.0;
						atmosphere_model_plus.layers[j].number_density_species[atmosphere_model_plus.species.size() - 1] = 0.0;
					}
				}

				atmosphere_model_plus.layers[nl].mixing_ratio_species[n_species[i]] = 0.0;
				atmosphere_model_plus.layers[nl].number_density_species[n_species[i]] = 0.0;
			}
			
			// atmosphere_model_plus.layers[nl].mixing_ratio_species[n_species] *= (1.0 + delta);
			// atmosphere_model_plus.layers[nl].number_density_species[n_species] = atmosphere_model_plus.layers[nl].number_density * atmosphere_model_plus.layers[nl].mixing_ratio_species[n_species];
			rtm_plus.initializeGeometry();
			if(cfg.wavenumber_type == WavenumberType::Bandpass || cfg.wavelength_type == WavelengthType::Bandpass)
			{
				rtm_plus.runBandpass(atmosphere_model_plus);
			}
			else if(cfg.wavenumber_type == WavenumberType::Monochrome || cfg.wavelength_type == WavelengthType::Monochrome)
			{
				rtm_plus.configuration.is_instrument = false;
				rtm_plus.runSpectrum(atmosphere_model_plus);
			}

			AtmosphereModel atmosphere_model_minus;
			RadiativeTransfer rtm_minus;
			rtm_minus.configuration = cfg;
			rtm_minus.computeAtmosphericProperties(atmosphere_model_minus);
			rtm_minus.computeSpeciesProperties(atmosphere_model_minus);
			
			for(int i = 0; i < n_species.size(); i ++)
			{
				atmosphere_model_minus.species.push_back(atmosphere_model_minus.species[n_species[i]]);
				atmosphere_model_minus.species[atmosphere_model_minus.species.size() - 1].ni = ni_base * (1.0 - delta);

				for(int j = 0; j < n_layer; j ++)
				{
					if(j != nl)
					{
						atmosphere_model_minus.layers[j].mixing_ratio_species[atmosphere_model_minus.species.size() - 1] = 0.0;
						atmosphere_model_minus.layers[j].number_density_species[atmosphere_model_minus.species.size() - 1] = 0.0;
					}
				}

				atmosphere_model_minus.layers[nl].mixing_ratio_species[n_species[i]] = 0.0;
				atmosphere_model_minus.layers[nl].number_density_species[n_species[i]] = 0.0;
			}

			// atmosphere_model_minus.layers[nl].mixing_ratio_species[n_species] *= (1.0 - delta);
			// atmosphere_model_minus.layers[nl].number_density_species[n_species] = atmosphere_model_minus.layers[nl].number_density * atmosphere_model_minus.layers[nl].mixing_ratio_species[n_species];
			rtm_minus.initializeGeometry();
			if(cfg.wavenumber_type == WavenumberType::Bandpass || cfg.wavelength_type == WavelengthType::Bandpass)
			{
				rtm_minus.runBandpass(atmosphere_model_minus);
			}
			else if(cfg.wavenumber_type == WavenumberType::Monochrome || cfg.wavelength_type == WavelengthType::Monochrome)
			{
				rtm_minus.configuration.is_instrument = false;
				rtm_minus.runSpectrum(atmosphere_model_minus);
			}

			if(nl == 0)
			{
				result.Ntheta = rtm_plus.Ntheta;
				result.Nphi = rtm_plus.Nphi;
				result.Nmode = rtm_plus.M;
				result.emission_zenith_angle = std::vector<double>(rtm_plus.geometry.theta_uh.data(), rtm_plus.geometry.theta_uh.data() + rtm_plus.geometry.theta_uh.size());
				result.incidence_zenith_angle = std::vector<double>(rtm_plus.geometry.theta_uh.data(), rtm_plus.geometry.theta_uh.data() + rtm_plus.geometry.theta_uh.size());
				result.emission_azimuth_angle = std::vector<double>(rtm_plus.geometry.phi.data(), rtm_plus.geometry.phi.data() + rtm_plus.geometry.phi.size());
			}

			result.altitude[nl] = atmosphere_model_plus.layers[nl].altitude;

			result.weighting_function_source_up[nl] = Eigen::VectorXd::Zero(rtm_plus.Ntheta);
			result.contribution_function_source_up[nl] = Eigen::VectorXd::Zero(rtm_plus.Ntheta);
			result.weighting_function_reflectance_top[nl] = std::vector<std::vector<std::vector<double>>>(rtm_plus.Ntheta, std::vector<std::vector<double>>(rtm_plus.Ntheta, std::vector<double>(rtm_plus.Nphi, 0.0)));
			result.contribution_function_reflectance_top[nl] = std::vector<std::vector<std::vector<double>>>(rtm_plus.Ntheta, std::vector<std::vector<double>>(rtm_plus.Ntheta, std::vector<double>(rtm_plus.Nphi, 0.0)));
			result.weighting_function_reflectance_m_top_cos[nl] = std::vector<Eigen::MatrixXd>(rtm_plus.M + 1, Eigen::MatrixXd::Zero(rtm_plus.Ntheta, rtm_plus.Ntheta));
			result.contribution_function_reflectance_m_top_cos[nl] = std::vector<Eigen::MatrixXd>(rtm_plus.M + 1, Eigen::MatrixXd::Zero(rtm_plus.Ntheta, rtm_plus.Ntheta));
			result.weighting_function_reflectance_m_top_sin[nl] = std::vector<Eigen::MatrixXd>(rtm_plus.M + 1, Eigen::MatrixXd::Zero(rtm_plus.Ntheta, rtm_plus.Ntheta));
			result.contribution_function_reflectance_m_top_sin[nl] = std::vector<Eigen::MatrixXd>(rtm_plus.M + 1, Eigen::MatrixXd::Zero(rtm_plus.Ntheta, rtm_plus.Ntheta));

			result.weighting_function_source_up[nl] = (rtm_plus.result.source_up[0] - rtm_minus.result.source_up[0]) / (2.0 * delta * ni_base);
			result.contribution_function_source_up[nl] = (rtm_plus.result.source_up[0] - rtm_minus.result.source_up[0]) / (2.0 * delta * ni_base) * ni_base;

			for(int i = 0; i < rtm_plus.Ntheta; i ++)
			{
				for(int j = 0; j < rtm_plus.Ntheta; j ++)
				{
					for(int k = 0; k < rtm_plus.Nphi; k ++)
					{
						result.weighting_function_reflectance_top[nl][i][j][k] = (rtm_plus.result.reflectance_top[0][i][j][k] - rtm_minus.result.reflectance_top[0][i][j][k]) / (2.0 * delta * ni_base);
						result.contribution_function_reflectance_top[nl][i][j][k] = (rtm_plus.result.reflectance_top[0][i][j][k] - rtm_minus.result.reflectance_top[0][i][j][k]) / (2.0 * delta * ni_base) * ni_base;
					}
				}
			}

			for(int i = 0; i <= rtm_plus.M; i ++)
			{
				result.weighting_function_reflectance_m_top_cos[nl][i] = (rtm_plus.result.reflectance_m_top_cos[0][i] - rtm_minus.result.reflectance_m_top_cos[0][i]) / (2.0 * delta * ni_base);
				result.contribution_function_reflectance_m_top_cos[nl][i] = (rtm_plus.result.reflectance_m_top_cos[0][i] - rtm_minus.result.reflectance_m_top_cos[0][i]) / (2.0 * delta * ni_base) * ni_base;
				result.weighting_function_reflectance_m_top_sin[nl][i] = (rtm_plus.result.reflectance_m_top_sin[0][i] - rtm_minus.result.reflectance_m_top_sin[0][i]) / (2.0 * delta * ni_base);
				result.contribution_function_reflectance_m_top_sin[nl][i] = (rtm_plus.result.reflectance_m_top_sin[0][i] - rtm_minus.result.reflectance_m_top_sin[0][i]) / (2.0 * delta * ni_base) * ni_base;
			}
		}
	}

	return result;
}


}