#ifndef __AKATSUKI_UVI_H__
#define __AKATSUKI_UVI_H__

#include<filesystem>
#include<iostream>
#include<sstream>
#include<chrono>
#include<vector>
#include<string>
#include<cmath>
#include<fstream>
#include<iomanip>
#include<algorithm>
#include<netcdf>
#include<omp.h>

#include<spherical_grid>
#include<multivariate_spline>

namespace akatsuki_uvi
{
const double AU_KM = 149597870.7;	//1au (km)
const double R_VENUS = 6051.8;	//Radius of Venus (km)
const double S283 = 288.0;	//unit W/m2/um
const double S365 = 1076.0;
const double BETA283 = 1.94;	//by Yamazaki, et al., 2018
const double BETA365 = 1.58;

//provided by Dr. Lee, Yeon Joo
//alpha: mean solar phase angle in degree
//k(alpha) = A0 + A1 * alpha + A2 * alpha^2 + A3 * alpha^3
const double A283_0 = 0.414544;
const double A283_1 = 0.0156191;
const double A283_2 = -0.000208026;
const double A283_3 = 5.71934E-7;

const double A365_0 = 0.270438;
const double A365_1 = 0.00269467;
const double A365_2 = -1.19147E-5;
const double A365_3 = -1.10714E-7;

//A(alpha) = B0 + B1 * alpha + B2 * alpha^2 + B3 * alpha^3 + B4 * alpha^4
const double B283_0 = 0.59833499;
const double B283_1 = -0.021021799;
const double B283_2 = 0.00042929144;
const double B283_3 = -4.1064112E-6;
const double B283_4 = 1.6082283E-8;

const double B365_0 = 0.70259118;
const double B365_1 = -0.018853930;
const double B365_2 = 0.00036374861;
const double B365_3 = -3.4318567E-6;
const double B365_4 = 1.3748240E-8;

/*
283-nm
contact: YJLEE
date: 2019/09/10

UVI L3bx data v20190401
LLS k(pha)=0.414544 + 0.0156191*pha-(0.000208026)*(pha^2) + (5.71934e-007)*(pha^3)
where pha is a mean solar phase angle in degree, 0-160 deg (2019/04/23).

A_pha_v20190401_20190908.png (2019/09/10)
Yellow curve: polynomial (4degree) fit of global mean albedo (A) phase curve
A(pha)=0.59833499 + (-0.021021799)*pha + (0.00042929144)*pha^2 + (-4.1064112e-006)*pha^3 + (1.6082283e-008)*pha^4,
where pha is a mean solar phase angle, and A is global mean albedo

365-nm
contact: YJLEE
date: 2019/09/08

UVI L3bx data v20190401
LLS k(pha)=0.270438 + 0.00269467*pha -(1.19147e-005)*(pha^2) - (1.10714e-007)*(pha^3),
where pha is mean solar phase angle in degree, 0-160 deg (2019/04/23).

A_pha_v20190401_20190908.png (2019/09/08)
Yellow curve: polynomial (4degree) fit of global mean albedo (A) phase curve
A(pha)=0.70259118 + (-0.018853930)*pha + (0.00036374861)*pha^2 + (-3.4318567e-006)*pha^3 + (1.3748240e-008)*pha^4,
where pha is mean solar phase angle, and A is global mean albedo
*/

class AkatsukiUVIL3B
{
	private:
	
	public:
		std::string filename;
		std::string filter;
		std::string time_str;	//yyyy-mm-dd hh:mm:ss
		double hours_since_2000;

		int num_x;	//number of zonal pixels
		int num_y;	//number of mieridional pixels

		//int binning = 1;

		std::vector<std::vector<double>> inangle;
		std::vector<std::vector<double>> emangle;
		std::vector<std::vector<double>> phangle;
		std::vector<std::vector<double>> radiance;
		//std::vector<std::vector<double>> reflectance;
		std::vector<double> longitude;
		std::vector<double> local_time;
		std::vector<double> latitude;
		std::vector<std::vector<bool>> availability;

		double dv;	//distance b/w sun and venus
		double av;	//distance b/w akatsuki and Venus
		double subsolar_longitude, subsolar_latitude, subsc_longitude, subsc_latitude, subsc_phangle;
		double lim_inangle = 85.0;
		double lim_emangle = 85.0;

		int wavelength;

		AkatsukiUVIL3B(void);
		AkatsukiUVIL3B(std::string);
		void importAkatsukiUVINetCDF(std::string);

		void exportAkatsukiUVI(std::string);
};

class AkatsukiUVIL3BX
{
	private:

	public:
		std::string filename;
		std::string filter;
		std::string time_str;	//yyyy-mm-dd hh:mm:ss
		double hours_since_2000;

		int num_x;	//number of zonal pixels
		int num_y;	//number of mieridional pixels

		std::vector<std::vector<double>> inangle;
		std::vector<std::vector<double>> emangle;
		std::vector<std::vector<double>> phangle;
		std::vector<std::vector<double>> radiance;
		//std::vector<std::vector<double>> reflectance;
		std::vector<std::vector<double>> longitude;
		std::vector<std::vector<double>> local_time;
		std::vector<std::vector<double>> latitude;
		std::vector<std::vector<bool>> availability;

		double dv;	//distance b/w sun and venus
		double av;	//distance b/w akatsuki and Venus
		double subsolar_longitude, subsolar_latitude, subsc_longitude, subsc_latitude;
		double lim_inangle = 85.0;
		double lim_emangle = 85.0;

		int wavelength;

		AkatsukiUVIL3BX(void);
		AkatsukiUVIL3BX(std::string);
		void importAkatsukiUVINetCDF(std::string);
};

enum class RetrievalStatus
{
	Success,                // ピクセルでリトリーバル成功
	NoObservation,          // 観測がない
	ValueBelowLowerBound,   // 観測値がシミュレーションの下限より下
	ValueAboveUpperBound,   // 観測値がシミュレーションの上限より上
	ConvergenceFailure,     // シミュレーションが収束しなかった
	OutOfGeometry           // 注目している観測ジオメトリの範囲外
};

std::vector<std::string> splitString(std::string, char);
std::vector<std::vector<std::vector<std::vector<double>>>> importReflectanceModel(spherical_grid::IcosahedralGrid, std::string);
std::string convertElapsedTime(double);

AkatsukiUVIL3B::AkatsukiUVIL3B(void)
{
	return;
}

AkatsukiUVIL3B::AkatsukiUVIL3B(std::string input_filename)
{
	importAkatsukiUVINetCDF(input_filename);
	return;
}

inline void AkatsukiUVIL3B::importAkatsukiUVINetCDF(std::string input_filename)
{
	filename = input_filename;
	netCDF::NcFile input(filename, netCDF::NcFile::read);

	netCDF::NcDim dim_longitude0 = input.getDim("longitude");
	int dim_longitude = dim_longitude0.getSize();
	netCDF::NcDim dim_latitude0 = input.getDim("latitude");
	int dim_latitude = dim_latitude0.getSize();
	netCDF::NcDim dim_time0 = input.getDim("time");
	int dim_time = dim_time0.getSize();
	netCDF::NcDim dim_text0 = input.getDim("text");
	int dim_text = dim_text0.getSize();

	num_x = dim_longitude;
	num_y = dim_latitude;

	inangle.resize(num_x);
	emangle.resize(num_x);
	phangle.resize(num_x);

	longitude.resize(num_x);
	local_time.resize(num_x);
	latitude.resize(num_y);
	availability.resize(num_x);

	radiance.resize(num_x);

	#pragma omp parallel for
	for(int i = 0; i < num_x; i ++)
	{
		inangle[i].resize(num_y);
		emangle[i].resize(num_y);
		phangle[i].resize(num_y);
		availability[i].resize(num_y);
		radiance[i].resize(num_y);
	}

	double* t = new double[dim_time];

	float* dv0 = new float[dim_time];
	float* av0 = new float[dim_time];

	float* sslon = new float[dim_time];
	float* sslat = new float[dim_time];
	float* sclon = new float[dim_time];
	float* sclat = new float[dim_time];

	float* sscphangle = new float[dim_time];

	float* rad = new float[dim_time * dim_latitude * dim_longitude];
	float* lon = new float[dim_longitude];
	float* lat = new float[dim_latitude];
	short* emang = new short[dim_time * dim_latitude * dim_longitude];
	short* inang = new short[dim_time * dim_latitude * dim_longitude];
	short* phang = new short[dim_time * dim_latitude * dim_longitude];

	char* fil = new char[dim_text];

	netCDF::NcVar time0 = input.getVar("time");
	time0.getVar(t);
	
	netCDF::NcVar sslon0 = input.getVar("S_SOLLON");
	sslon0.getVar(sslon);

	netCDF::NcVar sslat0 = input.getVar("S_SOLLAT");
	sslat0.getVar(sslat);

	netCDF::NcVar sclon0 = input.getVar("S_SSCLON");
	sclon0.getVar(sclon);

	netCDF::NcVar sclat0 = input.getVar("S_SSCLAT");
	sclat0.getVar(sclat);

	netCDF::NcVar S_DISTVS = input.getVar("S_DISTVS");
	S_DISTVS.getVar(dv0);

	netCDF::NcVar S_DISTAV = input.getVar("S_DISTAV");
	S_DISTAV.getVar(av0);

	netCDF::NcVar sscphangle0 = input.getVar("S_SSCPHA");
	sscphangle0.getVar(sscphangle);

	netCDF::NcVar longitude0 = input.getVar("longitude");
	longitude0.getVar(lon);

	netCDF::NcVar latitude0 = input.getVar("latitude");
	latitude0.getVar(lat);

	netCDF::NcVar radiance0 = input.getVar("radiance");
	radiance0.getVar(rad);

	netCDF::NcVar filter0 = input.getVar("FILTER");
	filter0.getVar(fil);

	filter = std::string(fil);
	wavelength = std::stoi(filter.substr(0, 3));

	netCDF::NcVar emangle0 = input.getVar("emangle");
	emangle0.getVar(emang);
	float emang_add_offset0[1];
	emangle0.getAtt("add_offset").getValues(emang_add_offset0);
	float emang_add_offset = emang_add_offset0[0];
	float emang_scale_factor0[1];
	emangle0.getAtt("scale_factor").getValues(emang_scale_factor0);
	float emang_scale_factor = emang_scale_factor0[0];

	netCDF::NcVar inangle0 = input.getVar("inangle");
	inangle0.getVar(inang);
	float inang_add_offset0[1];
	inangle0.getAtt("add_offset").getValues(inang_add_offset0);
	float inang_add_offset = inang_add_offset0[0];
	float inang_scale_factor0[1];
	inangle0.getAtt("scale_factor").getValues(inang_scale_factor0);
	float inang_scale_factor = inang_scale_factor0[0];

	netCDF::NcVar phangle0 = input.getVar("phangle");
	phangle0.getVar(phang);
	float phang_add_offset0[1];
	phangle0.getAtt("add_offset").getValues(phang_add_offset0);
	float phang_add_offset = phang_add_offset0[0];
	float phang_scale_factor0[1];
	phangle0.getAtt("scale_factor").getValues(phang_scale_factor0);
	float phang_scale_factor = phang_scale_factor0[0];

	hours_since_2000 = t[0];
	time_str = convertElapsedTime(hours_since_2000);

	dv = dv0[0] / 149597870.7;    //unit au
	av = av0[0];
	subsolar_longitude = sslon[0];
	subsolar_latitude = sslat[0];
	subsc_longitude = sclon[0];
	subsc_latitude = sclat[0];
	subsc_phangle = sscphangle[0];

	#pragma omp parallel for
	for(int i = 0; i < num_x; i ++)
	{
		for(int j = 0; j < num_y; j ++)
		{
			int idx = 0 * num_x * num_y + j * num_x + i;

			inangle[i][j] = inang[idx] * inang_scale_factor + inang_add_offset;
			emangle[i][j] = emang[idx] * emang_scale_factor + emang_add_offset;
			phangle[i][j] = phang[idx] * phang_scale_factor + phang_add_offset;
			if(filter == "283 nm")
			{
				radiance[i][j] = rad[idx] * BETA283;    //unit W/m2/sr/m
			}
			else if(filter == "365 nm")
			{
				radiance[i][j] = rad[idx] * BETA365;    //unit W/m2/sr/m
			}

			if(inangle[i][j] >= 0.0 && inangle[i][j] <= 90.0 && emangle[i][j] >= 0.0 && emangle[i][j] <= 90.0 && radiance[i][j] > 0.0)
			//if(inangle[i][j] >= 0.0 && inangle[i][j] < 75.0 && emangle[i][j] >= 0.0 && emangle[i][j] < 75.0 && radiance[i][j] > -6.0e20)
			{
				availability[i][j] = true;
			}
			else
			{
				availability[i][j] = false;
			}
		}
	}

	#pragma omp parallel for
	for(int i = 0; i < num_x; i ++)
	{
		longitude[i] = lon[i];
		local_time[i] = 12.0 + (subsolar_longitude - longitude[i]) / 360.0 * 24.0;
		if(local_time[i] >= 24.0)
		{
			local_time[i] -= 24.0;
		}
		else if(local_time[i] < 0.0)
		{
			local_time[i] += 24.0;
		}
	}

	#pragma omp parallel for
	for(int i = 0; i < num_y; i ++)
	{
		latitude[i] = lat[i];
	}

	delete[] t;
	delete[] dv0;
	delete[] av0;
	delete[] sslon;
	delete[] sslat;
	delete[] sclon;
	delete[] sclat;
	delete[] sscphangle;
	delete[] rad;
	delete[] lon;
	delete[] lat;
	delete[] emang;
	delete[] inang;
	delete[] phang;
	delete[] fil;

	return;
}

inline void AkatsukiUVIL3B::exportAkatsukiUVI(std::string output_filename)
{
	std::ofstream output(output_filename);

	output << "#1. x, 2. y, 3. longitude, 4. local time, 5. latitude, 6. availability, 7. incidence angle, 8. emission angle, 9. phase angle, 10. radiance" << std::endl;
	for(int x = 0; x < num_x; x ++)
	{
		for(int y = 0; y < num_y; y ++)
		{
			output << x << ", " << y << ", " << longitude[x] << ", " << local_time[x] << ", " << latitude[y] << ", " << availability[x][y] << ", ";
			output << inangle[x][y] << ", " << emangle[x][y] << ", " << phangle[x][y] << ", " << radiance[x][y] << std::endl;
		}
		
		output << std::endl;
	}

	return;
}

inline AkatsukiUVIL3BX::AkatsukiUVIL3BX(void)
{
	return;
}

inline AkatsukiUVIL3BX::AkatsukiUVIL3BX(std::string input_filename)
{
	importAkatsukiUVINetCDF(input_filename);
	return;
}

inline void AkatsukiUVIL3BX::importAkatsukiUVINetCDF(std::string input_filename)
{
	filename = input_filename;
	netCDF::NcFile input(filename, netCDF::NcFile::read);

	netCDF::NcDim dim_axis10 = input.getDim("axis1");
	int dim_axis1 = dim_axis10.getSize();
	netCDF::NcDim dim_axis20 = input.getDim("axis2");
	int dim_axis2 = dim_axis20.getSize();
	netCDF::NcDim dim_time0 = input.getDim("time");
	int dim_time = dim_time0.getSize();
	netCDF::NcDim dim_text0 = input.getDim("text");
	int dim_text = dim_text0.getSize();

	num_x = dim_axis1;
	num_y = dim_axis2;

	longitude.resize(num_x);
	latitude.resize(num_x);
	local_time.resize(num_x);
	inangle.resize(num_x);
	emangle.resize(num_x);
	phangle.resize(num_x);
	radiance.resize(num_x);
	availability.resize(num_x);

	#pragma omp parallel for
	for(int x = 0; x < num_x; x ++)
	{
		longitude[x].resize(num_y);
		latitude[x].resize(num_y);
		local_time[x].resize(num_y);
		inangle[x].resize(num_y);
		emangle[x].resize(num_y);
		phangle[x].resize(num_y);
		radiance[x].resize(num_y);
		availability[x].resize(num_y);
	}

	double* t = new double[dim_time];

	float* dv0 = new float[dim_time];
	float* av0 = new float[dim_time];

	float* sslon = new float[dim_time];
	float* sslat = new float[dim_time];
	float* sclon = new float[dim_time];
	float* sclat = new float[dim_time];

	float* rad = new float[dim_time * dim_axis2 * dim_axis1];
	float* lon = new float[dim_time * dim_axis2 * dim_axis1];
	float* lat = new float[dim_time * dim_axis2 * dim_axis1];
	float* emang = new float[dim_time * dim_axis2 * dim_axis1];
	float* inang = new float[dim_time * dim_axis2 * dim_axis1];
	float* phang = new float[dim_time * dim_axis2 * dim_axis1];

	char* fil = new char[dim_text];

	netCDF::NcVar time0 = input.getVar("time");
	time0.getVar(t);
	
	netCDF::NcVar sslon0 = input.getVar("S_SOLLON");
	sslon0.getVar(sslon);

	netCDF::NcVar sslat0 = input.getVar("S_SOLLAT");
	sslat0.getVar(sslat);

	netCDF::NcVar sclon0 = input.getVar("S_SSCLON");
	sclon0.getVar(sclon);

	netCDF::NcVar sclat0 = input.getVar("S_SSCLAT");
	sclat0.getVar(sclat);

	netCDF::NcVar S_DISTVS = input.getVar("S_DISTVS");
	S_DISTVS.getVar(dv0);

	netCDF::NcVar S_DISTAV = input.getVar("S_DISTAV");
	S_DISTAV.getVar(av0);

	netCDF::NcVar longitude0 = input.getVar("lon");
	longitude0.getVar(lon);

	netCDF::NcVar latitude0 = input.getVar("lat");
	latitude0.getVar(lat);

	netCDF::NcVar radiance0 = input.getVar("radiance");
	radiance0.getVar(rad);

	netCDF::NcVar filter0 = input.getVar("FILTER");
	filter0.getVar(fil);

	filter = std::string(fil);
	wavelength = std::stoi(filter.substr(0, 3));

	netCDF::NcVar emangle0 = input.getVar("emangle");
	emangle0.getVar(emang);

	netCDF::NcVar inangle0 = input.getVar("inangle");
	inangle0.getVar(inang);

	netCDF::NcVar phangle0 = input.getVar("phangle");
	phangle0.getVar(phang);

	hours_since_2000 = t[0];
	time_str = convertElapsedTime(hours_since_2000);

	dv = dv0[0] / 149597870.7;    //unit au
	av = av0[0];
	subsolar_longitude = sslon[0];
	subsolar_latitude = sslat[0];
	subsc_longitude = sclon[0];
	subsc_latitude = sclat[0];

	#pragma omp parallel for
	for(int i = 0; i < num_x; i ++)
	{
		for(int j = 0; j < num_y; j ++)
		{
			int idx = 0 * num_x * num_y + j * num_x + i;

			longitude[i][j] = lon[idx];
			latitude[i][j] = lat[idx];
			local_time[i][j] = 12.0 + (subsolar_longitude - longitude[i][j]) / 360.0 * 24.0;
			if(local_time[i][j] >= 24.0)
			{
				local_time[i][j] -= 24.0;
			}
			else if(local_time[i][j] < 0.0)
			{
				local_time[i][j] += 24.0;
			}

			inangle[i][j] = inang[idx];
			emangle[i][j] = emang[idx];
			phangle[i][j] = phang[idx];
			if(filter == "283 nm")
			{
				radiance[i][j] = rad[idx] * BETA283;    //unit W/m2/sr/m
			}
			else if(filter == "365 nm")
			{
				radiance[i][j] = rad[idx] * BETA365;    //unit W/m2/sr/m
			}

			if(inangle[i][j] >= 0.0 && inangle[i][j] <= 90.0 && emangle[i][j] >= 0.0 && emangle[i][j] <= 90.0 && radiance[i][j] > 0.0)
			//if(inangle[i][j] >= 0.0 && inangle[i][j] < 75.0 && emangle[i][j] >= 0.0 && emangle[i][j] < 75.0 && radiance[i][j] > -6.0e20)
			{
				availability[i][j] = true;
			}
			else
			{
				availability[i][j] = false;
			}
		}
	}

	delete[] t;
	delete[] dv0;
	delete[] av0;
	delete[] sslon;
	delete[] sslat;
	delete[] sclon;
	delete[] sclat;
	delete[] rad;
	delete[] lon;
	delete[] lat;
	delete[] emang;
	delete[] inang;
	delete[] phang;
	delete[] fil;

	return;
}

class AkatsukiUVIL3bGeometry
{
	private:
		void _resizeVector(void);
		double _llsDiskFunction(double, double, double);
		double _meanAlbedo(double alpha);
		double _getEmissionAzimuthAngle(double, double, double);

	public:
		int binning = 24;
		int deg_sphere = 3;
		int num_x;
		int num_y;
		int year, month, day, hour, minute, second;
		double subsc_phangle, dv, av, subsolar_longitude, subsolar_latitude, subsc_longitude, subsc_latitude;
		double lat_limit, mean_solar_phase_angle;
		std::string time_str;	//yyyy-mm-dd hh:mm:ss
		double hours_since_2000;

		std::string filter = "283 nm";
		int wavelength = 283;

		std::vector<std::vector<double>> incidence_zenith_angle;
		std::vector<std::vector<double>> emission_zenith_angle;
		std::vector<std::vector<double>> emission_azimuth_angle;
		std::vector<std::vector<double>> phase_angle;
		
		std::vector<double> longitude;
		std::vector<double> local_time;
		std::vector<double> latitude;
		std::vector<std::vector<bool>> availability;

		std::vector<std::vector<double>> radiance;
		std::vector<std::vector<double>> reflectance;
		std::vector<std::vector<double>> disk_function;
		std::vector<std::vector<double>> corrected_reflectance;

		AkatsukiUVIL3bGeometry(void);
		AkatsukiUVIL3bGeometry(int, int);
		void importAkatsukiUVINetCDF(std::string);
		void importAkatsukiUVINetCDF(AkatsukiUVIL3B);
};

inline AkatsukiUVIL3bGeometry::AkatsukiUVIL3bGeometry(void)
{
	num_x = 360;
	num_y = 180;

	lat_limit = 40.0;

	_resizeVector();

	return;
}

inline AkatsukiUVIL3bGeometry::AkatsukiUVIL3bGeometry(int nx, int ny)
{
	num_x = nx;
	num_y = ny;

	lat_limit = 40.0;

	_resizeVector();

	return;
}

inline void AkatsukiUVIL3bGeometry::_resizeVector(void)
{
	incidence_zenith_angle.resize(num_x, std::vector<double>(num_y));
	emission_zenith_angle.resize(num_x, std::vector<double>(num_y));
	emission_azimuth_angle.resize(num_x, std::vector<double>(num_y));
	phase_angle.resize(num_x, std::vector<double>(num_y));

	longitude.resize(num_x);
	local_time.resize(num_x);
	latitude.resize(num_y);
	availability.resize(num_x, std::vector<bool>(num_y));

	radiance.resize(num_x, std::vector<double>(num_y));
	reflectance.resize(num_x, std::vector<double>(num_y));
	disk_function.resize(num_x, std::vector<double>(num_y));
	corrected_reflectance.resize(num_x, std::vector<double>(num_y));

	return;
}

inline void AkatsukiUVIL3bGeometry::importAkatsukiUVINetCDF(std::string filename)
{
	AkatsukiUVIL3B nc(filename);
	importAkatsukiUVINetCDF(nc);

	return;
}

inline void AkatsukiUVIL3bGeometry::importAkatsukiUVINetCDF(AkatsukiUVIL3B nc)
{
	filter = nc.filter;
	wavelength = nc.wavelength;
	dv = nc.dv;
	av = nc.av;
	time_str = nc.time_str;
	hours_since_2000 = nc.hours_since_2000;
	subsolar_longitude = nc.subsolar_longitude;
	subsolar_latitude = nc.subsolar_latitude;
	subsc_longitude = nc.subsc_longitude;
	subsc_latitude = nc.subsc_latitude;
	subsc_phangle = nc.subsc_phangle;

	binning = nc.num_x / num_x;

	//std::cout << nc.num_x << ", " << nc.num_y << std::endl;

	// num_x = nc.num_x / binning;
	// num_y = nc.num_y / binning;

	//std::cout << num_x << ", " << num_y << std::endl;

	_resizeVector();

	//std::cout << "vectors resized" << std::endl;
 
	for(int x = 0; x < num_x; x ++)
	{
		longitude[x] = 360.0 / double(num_x) * 0.5 + 360.0 / double(num_x) * double(x);

		local_time[x] = 12.0 + (nc.subsolar_longitude - longitude[x]) / 360.0 * 24.0;
		if(local_time[x] >= 24.0)
		{
			local_time[x] -= 24.0;
		}
		else if(local_time[x] < 0.0)
		{
			local_time[x] += 24.0;
		}
	}

	for(int y = 0; y < num_y; y ++)
	{
		latitude[y] = -90.0 + 180.0 / double(num_y) * 0.5 + 180.0 / double(num_y) * double(y);
	}

	double theta_ss = (90.0 - subsolar_latitude) * M_PI / 180.0;
	double phi_ss = subsolar_longitude * M_PI / 180.0;
	double theta_sc = (90.0 - subsc_latitude) * M_PI / 180.0;
	double phi_sc = subsc_longitude * M_PI / 180.0;

	double x_ss = R_VENUS * std::sin(theta_ss) * std::cos(phi_ss);
	double y_ss = R_VENUS * std::sin(theta_ss) * std::sin(phi_ss);
	double z_ss = R_VENUS * std::cos(theta_ss);
	double x_sc = av * std::sin(theta_sc) * std::cos(phi_sc);
	double y_sc = av * std::sin(theta_sc) * std::sin(phi_sc);
	double z_sc = av * std::cos(theta_sc);
	double x_sun = dv * AU_KM * std::sin(theta_ss) * std::cos(phi_ss);
	double y_sun = dv * AU_KM * std::sin(theta_ss) * std::sin(phi_ss);
	double z_sun = dv * AU_KM * std::cos(theta_ss);

	double alpha = 0.0;
	int count_alpha = 0;

	for(int x = 0; x < num_x; x ++)
	{
		for(int y = 0; y < num_y; y ++)
		{
			double theta = (90.0 - latitude[y]) * M_PI / 180.0;
			double phi = longitude[x] * M_PI / 180.0;
			
			double x_obs = R_VENUS * std::sin(theta) * std::cos(phi);
			double y_obs = R_VENUS * std::sin(theta) * std::sin(phi);
			double z_obs = R_VENUS * std::cos(theta);

			incidence_zenith_angle[x][y] = std::acos((x_obs * x_ss + y_obs * y_ss + z_obs * z_ss) / (R_VENUS * R_VENUS)) * 180.0 / M_PI;
			emission_zenith_angle[x][y] = 180.0 - std::acos(((x_sc - x_obs) * (0.0 - x_obs) + (y_sc - y_obs) * (0.0 - y_obs) + (z_sc - z_obs) * (0.0 - z_obs)) / (std::sqrt((x_sc - x_obs) * (x_sc - x_obs) + (y_sc - y_obs) * (y_sc - y_obs) + (z_sc - z_obs) * (z_sc - z_obs)) * std::sqrt((0.0 - x_obs) * (0.0 - x_obs) + (0.0 - y_obs) * (0.0 - y_obs) + (0.0 - z_obs) * (0.0 - z_obs)))) * 180.0 / M_PI;
			phase_angle[x][y] = std::acos(((x_sc - x_obs) * (x_sun - x_obs) + (y_sc - y_obs) * (y_sun - y_obs) + (z_sc - z_obs) * (z_sun - z_obs)) / (std::sqrt((x_sc - x_obs) * (x_sc - x_obs) + (y_sc - y_obs) * (y_sc - y_obs) + (z_sc - z_obs) * (z_sc - z_obs)) * std::sqrt((x_sun - x_obs) * (x_sun - x_obs) + (y_sun - y_obs) * (y_sun - y_obs) + (z_sun - z_obs) * (z_sun - z_obs)))) * 180.0 / M_PI;

			emission_azimuth_angle[x][y] = _getEmissionAzimuthAngle(incidence_zenith_angle[x][y] / 180.0 * M_PI, emission_zenith_angle[x][y] / 180.0 * M_PI, phase_angle[x][y] / 180.0 * M_PI) * 180.0 / M_PI;

			radiance[x][y] = 0.0;
			int count = 0;

			//std::cout << x << ", " << y << ", " << inangle[x][y] << ", " << emangle[x][y] << ", " << phangle[x][y] << std::endl;

			for(int dx = binning * x; dx < binning * (x + 1); dx ++)
			{
				for(int dy = binning * y; dy < binning * (y + 1); dy ++)
				{
					if(nc.availability[dx][dy] == true)
					{
						radiance[x][y] += nc.radiance[dx][dy];
						count ++;
					}
				}
			}

			if(count >= 0.5 * binning * binning)
			{
				radiance[x][y] /= double(count);
				availability[x][y] = true;

				if(filter == "283 nm")
				{
					reflectance[x][y] = radiance[x][y] / (S283 * 1.0E6 * std::cos(incidence_zenith_angle[x][y] * M_PI / 180.0) / dv / dv / M_PI);
				}
				else if(filter == "365 nm")
				{
					reflectance[x][y] = radiance[x][y] / (S365 * 1.0E6 * std::cos(incidence_zenith_angle[x][y] * M_PI / 180.0) / dv / dv / M_PI);
				}
			}
			else
			{
				radiance[x][y] = -99.0;
				reflectance[x][y] = - 99.0;
				availability[x][y] = false;
			}

			if(availability[x][y] == true)
			{
				alpha += phase_angle[x][y];
				count_alpha ++;
			}
		}
	}

	mean_solar_phase_angle = alpha / double(count_alpha);
	
	for(int x = 0; x < num_x; x ++)
	{
		#pragma omp parallel for
		for(int y = 0; y < num_y; y ++)
		{
			if(availability[x][y] == true)
			{
				//_getGeometricParameters(emangle[x][y], inangle[x][y], phangle[x][y], sphere, fe[x][y], se[x][y], te[x][y], fi[x][y], si[x][y], ti[x][y]);
				disk_function[x][y] = _llsDiskFunction(incidence_zenith_angle[x][y], emission_zenith_angle[x][y], mean_solar_phase_angle);
				corrected_reflectance[x][y] = reflectance[x][y] / disk_function[x][y] / _meanAlbedo(mean_solar_phase_angle) * std::cos(incidence_zenith_angle[x][y] * M_PI / 180.0);
			}
		}
	}
	
	
	return;
}

inline double AkatsukiUVIL3bGeometry::_llsDiskFunction(double inangle, double emangle, double alpha)
{
	//Lambert and Lommel-Seeliger law
	//A = k * 2 * mu0 / (mu + mu0) + (1 - k) * mu0
	double mu = std::cos(emangle * M_PI / 180.0);
	double mu0 = std::cos(inangle * M_PI / 180.0);
	double k;

	if(wavelength == 283)
	{
		k = A283_0 + A283_1 * alpha + A283_2 * alpha * alpha + A283_3 * alpha * alpha * alpha;
	}
	else if(wavelength == 365)
	{
		k = A365_0 + A365_1 * alpha + A365_2 * alpha * alpha + A365_3 * alpha * alpha * alpha;
	}

	return k * 2.0 * mu0 / (mu + mu0) + (1.0 - k) * mu0;
}

inline double AkatsukiUVIL3bGeometry::_meanAlbedo(double alpha)
{
	if(wavelength == 283)
	{
		return B283_0 + B283_1 * alpha + B283_2 * alpha * alpha + B283_3 * alpha * alpha * alpha + B283_4 * alpha * alpha * alpha * alpha;
	}
	else if(wavelength == 365)
	{
		return B365_0 + B365_1 * alpha + B365_2 * alpha * alpha + B365_3 * alpha * alpha * alpha + B365_4 * alpha * alpha * alpha * alpha;
	}
	else
	{
		return -99.0;
	}
}

inline double AkatsukiUVIL3bGeometry::_getEmissionAzimuthAngle(double inangle, double emangle, double phangle)
{
	//incidence: incidence vector (theta, phi)
	//emangle: emergence angle
	//phangle: phase angle

	const double eps = 1.0E-10;

	if(inangle <= eps || emangle <= eps)
	{
		return 0.0;
	}
	else if(inangle + emangle <= phangle + eps)
	{
		return M_PI;
	}
	else if(std::abs(emangle - inangle) >= phangle - eps)
	{
		return 0.0;
	}
	else
	{
		return std::acos((std::cos(phangle) - std::cos(inangle) * std::cos(emangle)) / (std::sin(inangle) * std::sin(emangle)));
	}
}

class AkatsukiUVIL3bRetrievedData
{
	private:
		void _resizeVector(void);

	public:
		//observation information are based on 283 observation
		int num_x;
		int num_y;
		int year, month, day, hour, minute, second;
		double subsc_phangle, dv, subsolar_longitude, subsolar_latitude, subsc_longitude, subsc_latitude;
		double lat_limit, mean_solar_phase_angle;
		std::string time_str;	//yyyy-mm-dd hh:mm:ss
		double hours_since_2000;

		std::vector<std::vector<double>> incidence_zenith_angle;
		std::vector<std::vector<double>> emission_zenith_angle;
		std::vector<std::vector<double>> emission_azimuth_angle;
		std::vector<std::vector<double>> phase_angle;
		
		std::vector<double> longitude;
		std::vector<double> local_time;
		std::vector<double> latitude;
		std::vector<std::vector<bool>> availability;
		std::vector<std::vector<RetrievalStatus>> retrieval_status;

		std::vector<std::vector<double>> radiance_283;
		std::vector<std::vector<double>> radiance_365;
		std::vector<std::vector<double>> reflectance_283;
		std::vector<std::vector<double>> reflectance_365;
		std::vector<std::vector<double>> disk_function_283;
		std::vector<std::vector<double>> disk_function_365;
		std::vector<std::vector<double>> corrected_reflectance_283;
		std::vector<std::vector<double>> corrected_reflectance_365;

		std::vector<std::vector<double>> so2;
		std::vector<std::vector<double>> ni;

		double ni_ratio = 2.77;





		// for sensitivity tests
		bool is_sensitivity_test = false;
		std::vector<std::vector<std::vector<bool>>> availability_st;
		std::vector<std::vector<std::vector<RetrievalStatus>>> retrieval_status_st;
		std::vector<std::vector<std::vector<double>>> so2_st;
		std::vector<std::vector<std::vector<double>>> ni_st;
		std::vector<double> ni_ratio_st;

		AkatsukiUVIL3bRetrievedData(void);
		AkatsukiUVIL3bRetrievedData(std::vector<double>);
		AkatsukiUVIL3bRetrievedData(double);
		AkatsukiUVIL3bRetrievedData(int, int);
		AkatsukiUVIL3bRetrievedData(int, int, std::vector<double>);
		AkatsukiUVIL3bRetrievedData(int, int, double);

		void importGeometry(AkatsukiUVIL3bGeometry, AkatsukiUVIL3bGeometry);
		void importRetrievedDataNetCDF(std::string);
		void exportRetrievedDataNetCDF(std::string);

		void importOldRetrievedDataNetCDF(std::string);
		void makeQuickLook(std::string, int);
};

inline AkatsukiUVIL3bRetrievedData::AkatsukiUVIL3bRetrievedData(void)
{
	num_x = 360;
	num_y = 180;

	lat_limit = 40.0;

	_resizeVector();

	return;
}

inline AkatsukiUVIL3bRetrievedData::AkatsukiUVIL3bRetrievedData(double t)
{
	num_x = 360;
	num_y = 180;
	is_sensitivity_test = false;
	ni_ratio = t;

	lat_limit = 40.0;

	_resizeVector();

	return;
}

inline AkatsukiUVIL3bRetrievedData::AkatsukiUVIL3bRetrievedData(std::vector<double> t_list)
{
	num_x = 360;
	num_y = 180;
	is_sensitivity_test = true;
	ni_ratio_st = t_list;

	lat_limit = 40.0;

	_resizeVector();

	return;
}

inline AkatsukiUVIL3bRetrievedData::AkatsukiUVIL3bRetrievedData(int nx, int ny)
{
	num_x = nx;
	num_y = ny;

	lat_limit = 40.0;

	_resizeVector();

	return;
}

inline AkatsukiUVIL3bRetrievedData::AkatsukiUVIL3bRetrievedData(int nx, int ny, std::vector<double> t_list)
{
	num_x = nx;
	num_y = ny;
	is_sensitivity_test = true;
	ni_ratio_st = t_list;

	lat_limit = 40.0;

	_resizeVector();

	return;
}

inline AkatsukiUVIL3bRetrievedData::AkatsukiUVIL3bRetrievedData(int nx, int ny, double t)
{
	num_x = nx;
	num_y = ny;
	is_sensitivity_test = false;
	ni_ratio = t;

	lat_limit = 40.0;

	_resizeVector();

	return;
}

inline void AkatsukiUVIL3bRetrievedData::_resizeVector(void)
{
	incidence_zenith_angle.resize(num_x, std::vector<double>(num_y));
	emission_zenith_angle.resize(num_x, std::vector<double>(num_y));
	emission_azimuth_angle.resize(num_x, std::vector<double>(num_y));
	phase_angle.resize(num_x, std::vector<double>(num_y));

	longitude.resize(num_x);
	local_time.resize(num_x);
	latitude.resize(num_y);

	radiance_283.resize(num_x, std::vector<double>(num_y));
	radiance_365.resize(num_x, std::vector<double>(num_y));
	reflectance_283.resize(num_x, std::vector<double>(num_y));
	reflectance_365.resize(num_x, std::vector<double>(num_y));
	disk_function_283.resize(num_x, std::vector<double>(num_y));
	disk_function_365.resize(num_x, std::vector<double>(num_y));
	corrected_reflectance_283.resize(num_x, std::vector<double>(num_y));
	corrected_reflectance_365.resize(num_x, std::vector<double>(num_y));

	if(is_sensitivity_test == false)
	{
		so2.resize(num_x, std::vector<double>(num_y));
		ni.resize(num_x, std::vector<double>(num_y));
		availability.resize(num_x, std::vector<bool>(num_y));
		retrieval_status.resize(num_x, std::vector<RetrievalStatus>(num_y));
	}
	else
	{
		so2_st.resize(num_x, std::vector<std::vector<double>>(num_y, std::vector<double>(ni_ratio_st.size())));
		ni_st.resize(num_x, std::vector<std::vector<double>>(num_y, std::vector<double>(ni_ratio_st.size())));
		availability_st.resize(num_x, std::vector<std::vector<bool>>(num_y, std::vector<bool>(ni_ratio_st.size())));
		retrieval_status_st.resize(num_x, std::vector<std::vector<RetrievalStatus>>(num_y, std::vector<RetrievalStatus>(ni_ratio_st.size())));
	}

	return;
}

inline void AkatsukiUVIL3bRetrievedData::importGeometry(AkatsukiUVIL3bGeometry geometry_283, AkatsukiUVIL3bGeometry geometry_365)
{
	num_x = geometry_283.num_x;
	num_y = geometry_283.num_y;

	_resizeVector();

	time_str = geometry_283.time_str;
	hours_since_2000 = geometry_283.hours_since_2000;

	subsc_phangle = geometry_283.subsc_phangle;
	dv = geometry_283.dv;
	subsolar_longitude = geometry_283.subsolar_longitude;
	subsolar_latitude = geometry_283.subsolar_latitude;
	subsc_longitude = geometry_283.subsc_longitude;
	subsc_latitude = geometry_283.subsc_latitude;

	lat_limit = geometry_283.lat_limit;
	mean_solar_phase_angle = geometry_283.mean_solar_phase_angle;

	incidence_zenith_angle = geometry_283.incidence_zenith_angle;
	emission_zenith_angle = geometry_283.emission_zenith_angle;
	emission_azimuth_angle = geometry_283.emission_azimuth_angle;
	phase_angle = geometry_283.phase_angle;

	longitude = geometry_283.longitude;
	latitude = geometry_283.latitude;
	local_time = geometry_283.local_time;

	radiance_283 = geometry_283.radiance;
	radiance_365 = geometry_365.radiance;
	reflectance_283 = geometry_283.reflectance;
	reflectance_365 = geometry_365.reflectance;
	disk_function_283 = geometry_283.disk_function;
	disk_function_365 = geometry_365.disk_function;
	corrected_reflectance_283 = geometry_283.corrected_reflectance;
	corrected_reflectance_365 = geometry_365.corrected_reflectance;

	mean_solar_phase_angle = geometry_283.mean_solar_phase_angle;

	for(int x = 0; x < num_x; x ++)
	{
		for(int y = 0; y < num_y; y ++)
		{
			if(geometry_283.availability[x][y] == true && geometry_365.availability[x][y] == true)
			{
				if(is_sensitivity_test)
				{
					for(int t = 0; t < ni_ratio_st.size(); t ++)
					{
						availability_st[x][y][t] = true;
					}
				}
				else
				{
					availability[x][y] = true;
				}
			}
		}
	}

	return;
}

inline void AkatsukiUVIL3bRetrievedData::exportRetrievedDataNetCDF(std::string filename)
{
	netCDF::NcFile outputFile(filename, netCDF::NcFile::replace);

	if(is_sensitivity_test == false)
	{
		int num_t = 1;
		// 次元の定義
		netCDF::NcDim dim_nx = outputFile.addDim("num_x", num_x);
		netCDF::NcDim dim_ny = outputFile.addDim("num_y", num_y);
		netCDF::NcDim dim_nt = outputFile.addDim("num_ni_ratio", num_t);

		// 書き込み用の転置データ
		std::vector<double> flat_inang(num_y * num_x);
		std::vector<double> flat_emang(num_y * num_x);
		std::vector<double> flat_phi(num_y * num_x);
		std::vector<double> flat_phang(num_y * num_x);

		std::vector<double> flat_rad_283(num_y * num_x);
		std::vector<double> flat_ref_283(num_y * num_x);
		std::vector<double> flat_coref_283(num_y * num_x);
		std::vector<double> flat_df_283(num_y * num_x);
		std::vector<double> flat_rad_365(num_y * num_x);
		std::vector<double> flat_ref_365(num_y * num_x);
		std::vector<double> flat_coref_365(num_y * num_x);
		std::vector<double> flat_df_365(num_y * num_x);
		
		std::vector<int> flat_avail(num_t * num_y * num_x);
		std::vector<double> flat_so2(num_t * num_y * num_x);
		std::vector<double> flat_ni(num_t * num_y * num_x);
		std::vector<int> flat_status(num_t * num_y * num_x);

		//#pragma omp parallel for
		for(int x = 0; x < num_x; x ++)
		{
			for(int y = 0; y < num_y; y ++)
			{
				int idx = x * num_y + y;
				flat_inang[idx] = incidence_zenith_angle[x][y];
				flat_emang[idx] = emission_zenith_angle[x][y];
				flat_phi[idx] = emission_azimuth_angle[x][y];
				flat_phang[idx] = phase_angle[x][y];
				flat_rad_283[idx] = radiance_283[x][y];
				flat_ref_283[idx] = reflectance_283[x][y];
				flat_coref_283[idx] = corrected_reflectance_283[x][y];
				flat_df_283[idx] = disk_function_283[x][y];
				flat_rad_365[idx] = radiance_365[x][y];
				flat_ref_365[idx] = reflectance_365[x][y];
				flat_coref_365[idx] = corrected_reflectance_365[x][y];
				flat_df_365[idx] = disk_function_365[x][y];
			}
		}

		//#pragma omp parallel for
		for(int x = 0; x < num_x; x ++)
		{
			for(int y = 0; y < num_y; y ++)
			{
				int idx = x * num_y + y;
				flat_so2[idx] = so2[x][y];
				flat_ni[idx] = ni[x][y];

				if(availability[x][y] == true)
				{
					flat_avail[idx] = 1;
				}
				else
				{
					flat_avail[idx] = 0;
				}

				if(retrieval_status[x][y] == RetrievalStatus::Success)
				{
					flat_status[idx] = 0;
				}
				else if(retrieval_status[x][y] == RetrievalStatus::NoObservation)
				{
					flat_status[idx] = 1;
				}
				else if(retrieval_status[x][y] == RetrievalStatus::ValueBelowLowerBound)
				{
					flat_status[idx] = 2;
				}
				else if(retrieval_status[x][y] == RetrievalStatus::ValueAboveUpperBound)
				{
					flat_status[idx] = 3;
				}
				else if(retrieval_status[x][y] == RetrievalStatus::ConvergenceFailure)
				{
					flat_status[idx] = 4;
				}
				else if(retrieval_status[x][y] == RetrievalStatus::OutOfGeometry)
				{
					flat_status[idx] = 5;
				}
			}
		}

		// 変数の定義
		netCDF::NcVar var_lon = outputFile.addVar("longitude", netCDF::ncDouble, dim_nx);
		var_lon.putAtt("long_name", "east longitude");
		var_lon.putAtt("units", "degree");
		netCDF::NcVar var_lat = outputFile.addVar("latitude", netCDF::ncDouble, dim_ny);
		var_lat.putAtt("long_name", "latitude");
		var_lat.putAtt("units", "degree");
		netCDF::NcVar var_lt = outputFile.addVar("local_time", netCDF::ncDouble, dim_nx);
		var_lt.putAtt("long_name", "local time");
		var_lt.putAtt("units", "hour");
		netCDF::NcVar var_ni_ratio = outputFile.addVar("ni_ratio", netCDF::ncDouble, dim_nt);
		var_ni_ratio.putAtt("long_name", "ni(365 nm) / ni(283 nm)");

		netCDF::NcVar var_inang = outputFile.addVar("incidence_zenith_angle", netCDF::ncDouble, {dim_nx, dim_ny});
		var_inang.putAtt("long_name", "incidence zenith angle");
		var_inang.putAtt("units", "degree");
		netCDF::NcVar var_emang = outputFile.addVar("emission_zenith_angle", netCDF::ncDouble, {dim_nx, dim_ny});
		var_emang.putAtt("long_name", "emission zenith angle");
		var_emang.putAtt("units", "degree");
		netCDF::NcVar var_phi = outputFile.addVar("emission_azimuth_angle", netCDF::ncDouble, {dim_nx, dim_ny});
		var_phi.putAtt("long_name", "emission azimuth angle");
		var_phi.putAtt("units", "degree");
		netCDF::NcVar var_phang = outputFile.addVar("phase_angle", netCDF::ncDouble, {dim_nx, dim_ny});
		var_phang.putAtt("long_name", "phase angle");
		var_phang.putAtt("units", "degree");

		netCDF::NcVar var_rad_283 = outputFile.addVar("radiance_283", netCDF::ncDouble, {dim_nx, dim_ny});
		var_rad_283.putAtt("long_name", "radiance (283 nm)");
		var_rad_283.putAtt("units", "W/m2/sr/m");
		netCDF::NcVar var_ref_283 = outputFile.addVar("reflectance_283", netCDF::ncDouble, {dim_nx, dim_ny});
		var_ref_283.putAtt("long_name", "reflectance (283 nm)");
		netCDF::NcVar var_coref_283 = outputFile.addVar("corrected_reflectance_283", netCDF::ncDouble, {dim_nx, dim_ny});
		var_coref_283.putAtt("long_name", "photometrical corrected reflectance (283 nm)");
		netCDF::NcVar var_df_283 = outputFile.addVar("disk_function_283", netCDF::ncDouble, {dim_nx, dim_ny});
		var_df_283.putAtt("long_name", "lambert and lommel-seeliger low disk function (283 nm)");

		netCDF::NcVar var_rad_365 = outputFile.addVar("radiance_365", netCDF::ncDouble, {dim_nx, dim_ny});
		var_rad_365.putAtt("long_name", "radiance (365 nm)");
		var_rad_365.putAtt("units", "W/m2/sr/m");
		netCDF::NcVar var_ref_365 = outputFile.addVar("reflectance_365", netCDF::ncDouble, {dim_nx, dim_ny});
		var_ref_365.putAtt("long_name", "reflectance (365 nm)");
		netCDF::NcVar var_coref_365 = outputFile.addVar("corrected_reflectance_365", netCDF::ncDouble, {dim_nx, dim_ny});
		var_coref_365.putAtt("long_name", "photometrical corrected reflectance (365 nm)");
		netCDF::NcVar var_df_365 = outputFile.addVar("disk_function_365", netCDF::ncDouble, {dim_nx, dim_ny});
		var_df_365.putAtt("long_name", "lambert and lommel-seeliger low disk function (365 nm)");

		netCDF::NcVar var_avail = outputFile.addVar("availability", netCDF::ncInt, {dim_nx, dim_ny, dim_nt});
		var_avail.putAtt("long_name", "pixel availability");
		netCDF::NcVar var_status = outputFile.addVar("retrieval_status", netCDF::ncInt, {dim_nx, dim_ny, dim_nt});
		var_status.putAtt("long_name", "status of the retrieval");
		var_status.putAtt("description", "0: Success, 1: NoObservation, 2: ValueBelowLowerBound, 3: ValueAboveUpperBound, 4: ConvergenceFailure, 5: OutOfGeometry");

		netCDF::NcVar var_so2 = outputFile.addVar("so2", netCDF::ncDouble, {dim_nx, dim_ny, dim_nt});
		var_so2.putAtt("long_name", "Mixing ratio of sulfur dioxide (SO2) at 70 km");
		var_so2.putAtt("units", "ppb");

		netCDF::NcVar var_ni = outputFile.addVar("ni", netCDF::ncDouble, {dim_nx, dim_ny, dim_nt});
		var_ni.putAtt("long_name", "The imaginary part of refractive index of cloud mode 1 and 2 particles");

		netCDF::NcVar var_date = outputFile.addVar("observation_date", netCDF::ncString);
		var_date.putAtt("long_name", "observation date");
		var_date.putAtt("format", "YYYY-MM-DD HH:mm:SS");
		netCDF::NcVar var_time = outputFile.addVar("hours_since_2000", netCDF::ncDouble);
		var_time.putAtt("long_name", "hours since Jan 1, 2000 00:00:00");
		var_time.putAtt("units", "hour");

		netCDF::NcVar var_dv = outputFile.addVar("dv", netCDF::ncDouble);
		var_dv.putAtt("long_name", "distance between the Sun and Venus");
		var_dv.putAtt("units", "AU");
		netCDF::NcVar var_sslon = outputFile.addVar("subsolar_longitude", netCDF::ncDouble);
		var_sslon.putAtt("long_name", "subsolar east longitude");
		var_sslon.putAtt("units", "degree");
		netCDF::NcVar var_sslat = outputFile.addVar("subsolar_latitude", netCDF::ncDouble);
		var_sslat.putAtt("long_name", "subsolar latitude");
		var_sslat.putAtt("units", "degree");
		netCDF::NcVar var_ssclon = outputFile.addVar("subsc_longitude", netCDF::ncDouble);
		var_ssclon.putAtt("long_name", "nadir east longitude");
		var_ssclon.putAtt("units", "degree");
		netCDF::NcVar var_ssclat = outputFile.addVar("subsc_latitude", netCDF::ncDouble);
		var_ssclat.putAtt("long_name", "nadir latitude");
		var_ssclat.putAtt("units", "degree");
		netCDF::NcVar var_sscpha = outputFile.addVar("subsc_phangle", netCDF::ncDouble);
		var_sscpha.putAtt("long_name", "sun-venus-akatsuki phase angle");
		var_sscpha.putAtt("units", "degree");
		netCDF::NcVar var_meanphang = outputFile.addVar("mean_solar_phangle", netCDF::ncDouble);
		var_meanphang.putAtt("long_name", "disk-mean solar phase angle");
		var_meanphang.putAtt("units", "degree");

		// グローバル属性の追加
		outputFile.putAtt("description", "");

		// データの書き込み
		std::vector<double> ni_ratio_temp = {ni_ratio};
		var_lon.putVar(longitude.data());
		var_lat.putVar(latitude.data());
		var_lt.putVar(local_time.data());
		var_ni_ratio.putVar(ni_ratio_temp.data());
		//std::string str_time = std::format("{:%Y-%m-%d %H:%M:%S}", time);
		const char* c_str_time = time_str.c_str();
		var_date.putVar(&c_str_time);
		var_time.putVar(&hours_since_2000);
		var_sslon.putVar(&subsolar_longitude);
		var_sslat.putVar(&subsolar_latitude);
		var_ssclon.putVar(&subsc_longitude);
		var_ssclat.putVar(&subsc_latitude);
		var_sscpha.putVar(&subsc_phangle);
		var_meanphang.putVar(&mean_solar_phase_angle);
		var_dv.putVar(&dv);

		var_inang.putVar(flat_inang.data());
		var_emang.putVar(flat_emang.data());
		var_phi.putVar(flat_phi.data());
		var_phang.putVar(flat_phang.data());
		var_avail.putVar(flat_avail.data());
		var_status.putVar(flat_status.data());
		var_rad_283.putVar(flat_rad_283.data());
		var_ref_283.putVar(flat_ref_283.data());
		var_coref_283.putVar(flat_coref_283.data());
		var_df_283.putVar(flat_df_283.data());
		var_rad_365.putVar(flat_rad_365.data());
		var_ref_365.putVar(flat_ref_365.data());
		var_coref_365.putVar(flat_coref_365.data());
		var_df_365.putVar(flat_df_365.data());
		var_so2.putVar(flat_so2.data());
		var_ni.putVar(flat_ni.data());
	}
	else
	{
		int num_t = ni_ratio_st.size();
		// 次元の定義
		netCDF::NcDim dim_nx = outputFile.addDim("num_x", num_x);
		netCDF::NcDim dim_ny = outputFile.addDim("num_y", num_y);
		netCDF::NcDim dim_nt = outputFile.addDim("num_ni_ratio", num_t);

		// 書き込み用の転置データ
		std::vector<double> flat_inang(num_y * num_x);
		std::vector<double> flat_emang(num_y * num_x);
		std::vector<double> flat_phi(num_y * num_x);
		std::vector<double> flat_phang(num_y * num_x);

		std::vector<double> flat_rad_283(num_y * num_x);
		std::vector<double> flat_ref_283(num_y * num_x);
		std::vector<double> flat_coref_283(num_y * num_x);
		std::vector<double> flat_df_283(num_y * num_x);
		std::vector<double> flat_rad_365(num_y * num_x);
		std::vector<double> flat_ref_365(num_y * num_x);
		std::vector<double> flat_coref_365(num_y * num_x);
		std::vector<double> flat_df_365(num_y * num_x);

		std::vector<int> flat_avail(num_t * num_y * num_x);
		std::vector<double> flat_so2(num_t * num_y * num_x);
		std::vector<double> flat_ni(num_t * num_y * num_x);
		std::vector<int> flat_status(num_t * num_y * num_x);

		//#pragma omp parallel for
		for(int x = 0; x < num_x; x ++)
		{
			for(int y = 0; y < num_y; y ++)
			{
				int idx = x * num_y + y;
				flat_inang[idx] = incidence_zenith_angle[x][y];
				flat_emang[idx] = emission_zenith_angle[x][y];
				flat_phi[idx] = emission_azimuth_angle[x][y];
				flat_phang[idx] = phase_angle[x][y];
				flat_rad_283[idx] = radiance_283[x][y];
				flat_ref_283[idx] = reflectance_283[x][y];
				flat_coref_283[idx] = corrected_reflectance_283[x][y];
				flat_df_283[idx] = disk_function_283[x][y];
				flat_rad_365[idx] = radiance_365[x][y];
				flat_ref_365[idx] = reflectance_365[x][y];
				flat_coref_365[idx] = corrected_reflectance_365[x][y];
				flat_df_365[idx] = disk_function_365[x][y];
			}
		}

		for(int x = 0; x < num_x; x ++)
		{
			for(int y = 0; y < num_y; y ++)
			{
				for(int t = 0; t < num_t; t ++)
				{
					int idx = x * num_y *  num_t + y * num_t + t;
					flat_so2[idx] = so2_st[x][y][t];
					flat_ni[idx] = ni_st[x][y][t];

					if(availability_st[x][y][t] == true)
					{
						flat_avail[idx] = 1;
					}
					else
					{
						flat_avail[idx] = 0;
					}

					if(retrieval_status_st[x][y][t] == RetrievalStatus::Success)
					{
						flat_status[idx] = 0;
					}
					else if(retrieval_status_st[x][y][t] == RetrievalStatus::NoObservation)
					{
						flat_status[idx] = 1;
					}
					else if(retrieval_status_st[x][y][t] == RetrievalStatus::ValueBelowLowerBound)
					{
						flat_status[idx] = 2;
					}
					else if(retrieval_status_st[x][y][t] == RetrievalStatus::ValueAboveUpperBound)
					{
						flat_status[idx] = 3;
					}
					else if(retrieval_status_st[x][y][t] == RetrievalStatus::ConvergenceFailure)
					{
						flat_status[idx] = 4;
					}
					else if(retrieval_status_st[x][y][t] == RetrievalStatus::OutOfGeometry)
					{
						flat_status[idx] = 5;
					}
				}
			}
		}

		// 変数の定義
		netCDF::NcVar var_lon = outputFile.addVar("longitude", netCDF::ncDouble, dim_nx);
		var_lon.putAtt("long_name", "east longitude");
		var_lon.putAtt("units", "degree");
		netCDF::NcVar var_lat = outputFile.addVar("latitude", netCDF::ncDouble, dim_ny);
		var_lat.putAtt("long_name", "latitude");
		var_lat.putAtt("units", "degree");
		netCDF::NcVar var_lt = outputFile.addVar("local_time", netCDF::ncDouble, dim_nx);
		var_lt.putAtt("long_name", "local time");
		var_lt.putAtt("units", "hour");
		netCDF::NcVar var_ni_ratio = outputFile.addVar("ni_ratio", netCDF::ncDouble, dim_nt);
		var_ni_ratio.putAtt("long_name", "ni(365 nm) / ni(283 nm)");

		netCDF::NcVar var_inang = outputFile.addVar("incidence_zenith_angle", netCDF::ncDouble, {dim_nx, dim_ny});
		var_inang.putAtt("long_name", "incidence zenith angle");
		var_inang.putAtt("units", "degree");
		netCDF::NcVar var_emang = outputFile.addVar("emission_zenith_angle", netCDF::ncDouble, {dim_nx, dim_ny});
		var_emang.putAtt("long_name", "emission zenith angle");
		var_emang.putAtt("units", "degree");
		netCDF::NcVar var_phi = outputFile.addVar("emission_azimuth_angle", netCDF::ncDouble, {dim_nx, dim_ny});
		var_phi.putAtt("long_name", "emission azimuth angle");
		var_phi.putAtt("units", "degree");
		netCDF::NcVar var_phang = outputFile.addVar("phase_angle", netCDF::ncDouble, {dim_nx, dim_ny});
		var_phang.putAtt("long_name", "phase angle");
		var_phang.putAtt("units", "degree");

		netCDF::NcVar var_rad_283 = outputFile.addVar("radiance_283", netCDF::ncDouble, {dim_nx, dim_ny});
		var_rad_283.putAtt("long_name", "radiance (283 nm)");
		var_rad_283.putAtt("units", "W/m2/sr/m");
		netCDF::NcVar var_ref_283 = outputFile.addVar("reflectance_283", netCDF::ncDouble, {dim_nx, dim_ny});
		var_ref_283.putAtt("long_name", "reflectance (283 nm)");
		netCDF::NcVar var_coref_283 = outputFile.addVar("corrected_reflectance_283", netCDF::ncDouble, {dim_nx, dim_ny});
		var_coref_283.putAtt("long_name", "photometrical corrected reflectance (283 nm)");
		netCDF::NcVar var_df_283 = outputFile.addVar("disk_function_283", netCDF::ncDouble, {dim_nx, dim_ny});
		var_df_283.putAtt("long_name", "lambert and lommel-seeliger low disk function (283 nm)");

		netCDF::NcVar var_rad_365 = outputFile.addVar("radiance_365", netCDF::ncDouble, {dim_nx, dim_ny});
		var_rad_365.putAtt("long_name", "radiance (365 nm)");
		var_rad_365.putAtt("units", "W/m2/sr/m");
		netCDF::NcVar var_ref_365 = outputFile.addVar("reflectance_365", netCDF::ncDouble, {dim_nx, dim_ny});
		var_ref_365.putAtt("long_name", "reflectance (365 nm)");
		netCDF::NcVar var_coref_365 = outputFile.addVar("corrected_reflectance_365", netCDF::ncDouble, {dim_nx, dim_ny});
		var_coref_365.putAtt("long_name", "photometrical corrected reflectance (365 nm)");
		netCDF::NcVar var_df_365 = outputFile.addVar("disk_function_365", netCDF::ncDouble, {dim_nx, dim_ny});
		var_df_365.putAtt("long_name", "lambert and lommel-seeliger low disk function (365 nm)");

		netCDF::NcVar var_avail = outputFile.addVar("availability", netCDF::ncInt, {dim_nx, dim_ny, dim_nt});
		var_avail.putAtt("long_name", "pixel availability");
		netCDF::NcVar var_status = outputFile.addVar("retrieval_status", netCDF::ncInt, {dim_nx, dim_ny, dim_nt});
		var_status.putAtt("long_name", "status of the retrieval");
		var_status.putAtt("description", "0: Success, 1: NoObservation, 2: ValueBelowLowerBound, 3: ValueAboveUpperBound, 4: ConvergenceFailure, 5: OutOfGeometry");

		netCDF::NcVar var_so2 = outputFile.addVar("so2", netCDF::ncDouble, {dim_nx, dim_ny, dim_nt});
		var_so2.putAtt("long_name", "Mixing ratio of sulfur dioxide (SO2) at 70 km");
		var_so2.putAtt("units", "ppb");

		netCDF::NcVar var_ni = outputFile.addVar("ni", netCDF::ncDouble, {dim_nx, dim_ny, dim_nt});
		var_ni.putAtt("long_name", "The imaginary part of refractive index of cloud mode 1 and 2 particles");

		netCDF::NcVar var_date = outputFile.addVar("observation_date", netCDF::ncString);
		var_date.putAtt("long_name", "observation date");
		var_date.putAtt("format", "YYYY-MM-DD HH:mm:SS");
		netCDF::NcVar var_time = outputFile.addVar("hours_since_2000", netCDF::ncDouble);
		var_time.putAtt("long_name", "hours since Jan 1, 2000 00:00:00");
		var_time.putAtt("units", "hour");

		netCDF::NcVar var_dv = outputFile.addVar("dv", netCDF::ncDouble);
		var_dv.putAtt("long_name", "distance between the Sun and Venus");
		var_dv.putAtt("units", "AU");
		netCDF::NcVar var_sslon = outputFile.addVar("subsolar_longitude", netCDF::ncDouble);
		var_sslon.putAtt("long_name", "subsolar east longitude");
		var_sslon.putAtt("units", "degree");
		netCDF::NcVar var_sslat = outputFile.addVar("subsolar_latitude", netCDF::ncDouble);
		var_sslat.putAtt("long_name", "subsolar latitude");
		var_sslat.putAtt("units", "degree");
		netCDF::NcVar var_ssclon = outputFile.addVar("subsc_longitude", netCDF::ncDouble);
		var_ssclon.putAtt("long_name", "nadir east longitude");
		var_ssclon.putAtt("units", "degree");
		netCDF::NcVar var_ssclat = outputFile.addVar("subsc_latitude", netCDF::ncDouble);
		var_ssclat.putAtt("long_name", "nadir latitude");
		var_ssclat.putAtt("units", "degree");
		netCDF::NcVar var_sscpha = outputFile.addVar("subsc_phangle", netCDF::ncDouble);
		var_sscpha.putAtt("long_name", "sun-venus-akatsuki phase angle");
		var_sscpha.putAtt("units", "degree");
		netCDF::NcVar var_meanphang = outputFile.addVar("mean_solar_phangle", netCDF::ncDouble);
		var_meanphang.putAtt("long_name", "disk-mean solar phase angle");
		var_meanphang.putAtt("units", "degree");

		// グローバル属性の追加
		outputFile.putAtt("description", "");

		// データの書き込み
		var_lon.putVar(longitude.data());
		var_lat.putVar(latitude.data());
		var_lt.putVar(local_time.data());
		var_ni_ratio.putVar(ni_ratio_st.data());
		//std::string str_time = std::format("{:%Y-%m-%d %H:%M:%S}", time);
		const char* c_str_time = time_str.c_str();
		var_date.putVar(&c_str_time);
		var_time.putVar(&hours_since_2000);
		var_sslon.putVar(&subsolar_longitude);
		var_sslat.putVar(&subsolar_latitude);
		var_ssclon.putVar(&subsc_longitude);
		var_ssclat.putVar(&subsc_latitude);
		var_sscpha.putVar(&subsc_phangle);
		var_meanphang.putVar(&mean_solar_phase_angle);
		var_dv.putVar(&dv);

		var_inang.putVar(flat_inang.data());
		var_emang.putVar(flat_emang.data());
		var_phi.putVar(flat_phi.data());
		var_phang.putVar(flat_phang.data());
		var_avail.putVar(flat_avail.data());
		var_status.putVar(flat_status.data());
		var_rad_283.putVar(flat_rad_283.data());
		var_ref_283.putVar(flat_ref_283.data());
		var_coref_283.putVar(flat_coref_283.data());
		var_df_283.putVar(flat_df_283.data());
		var_rad_365.putVar(flat_rad_365.data());
		var_ref_365.putVar(flat_ref_365.data());
		var_coref_365.putVar(flat_coref_365.data());
		var_df_365.putVar(flat_df_365.data());
		var_so2.putVar(flat_so2.data());
		var_ni.putVar(flat_ni.data());
	}
	
	return;
}

inline void AkatsukiUVIL3bRetrievedData::importRetrievedDataNetCDF(std::string filename)
{
	netCDF::NcFile inputFile(filename, netCDF::NcFile::read);

	// 次元の読み込み
	netCDF::NcDim dim_nx = inputFile.getDim("num_x");
	netCDF::NcDim dim_ny = inputFile.getDim("num_y");
	netCDF::NcDim dim_nt = inputFile.getDim("num_ni_ratio");

	num_x = dim_nx.getSize();
	num_y = dim_ny.getSize();

	int num_t = dim_nt.getSize();

	if(num_t == 1)
	{
		is_sensitivity_test = false;
	}
	else if(num_t > 1)
	{
		is_sensitivity_test = true;
		ni_ratio_st.resize(num_t);
	}

	_resizeVector();

	// 次元データの読み込み
	netCDF::NcVar var_lon = inputFile.getVar("longitude");
	var_lon.getVar(longitude.data());
	netCDF::NcVar var_lat = inputFile.getVar("latitude");
	var_lat.getVar(latitude.data());
	netCDF::NcVar var_lt = inputFile.getVar("local_time");
	var_lt.getVar(local_time.data());
	if(is_sensitivity_test)
	{
		netCDF::NcVar var_ni_ratio = inputFile.getVar("ni_ratio");
		var_ni_ratio.getVar(ni_ratio_st.data());
	}
	else
	{
		netCDF::NcVar var_ni_ratio = inputFile.getVar("ni_ratio");
		var_ni_ratio.getVar(&ni_ratio);
	}

	// 時刻や属性データの読み込み
	netCDF::NcVar var_date = inputFile.getVar("observation_date");
	char* cStr;
	var_date.getVar(&cStr);
	time_str = std::string(cStr);

	inputFile.getVar("hours_since_2000").getVar(&hours_since_2000);
	inputFile.getVar("subsolar_longitude").getVar(&subsolar_longitude);
	inputFile.getVar("subsolar_latitude").getVar(&subsolar_latitude);
	inputFile.getVar("subsc_longitude").getVar(&subsc_longitude);
	inputFile.getVar("subsc_latitude").getVar(&subsc_latitude);
	inputFile.getVar("subsc_phangle").getVar(&subsc_phangle);
	inputFile.getVar("mean_solar_phangle").getVar(&mean_solar_phase_angle);
	inputFile.getVar("dv").getVar(&dv);

	free(cStr);

	std::vector<double> flat_inang(num_y * num_x);
	std::vector<double> flat_emang(num_y * num_x);
	std::vector<double> flat_phang(num_y * num_x);
	std::vector<double> flat_phi(num_y * num_x);

	std::vector<double> flat_rad_283(num_y * num_x);
	std::vector<double> flat_ref_283(num_y * num_x);
	std::vector<double> flat_coref_283(num_y * num_x);
	std::vector<double> flat_df_283(num_y * num_x);
	std::vector<double> flat_rad_365(num_y * num_x);
	std::vector<double> flat_ref_365(num_y * num_x);
	std::vector<double> flat_coref_365(num_y * num_x);
	std::vector<double> flat_df_365(num_y * num_x);

	inputFile.getVar("incidence_zenith_angle").getVar(flat_inang.data());
	inputFile.getVar("emission_zenith_angle").getVar(flat_emang.data());
	inputFile.getVar("emission_azimuth_angle").getVar(flat_phi.data());
	inputFile.getVar("phase_angle").getVar(flat_phang.data());
	
	inputFile.getVar("radiance_283").getVar(flat_rad_283.data());
	inputFile.getVar("reflectance_283").getVar(flat_ref_283.data());
	inputFile.getVar("corrected_reflectance_283").getVar(flat_coref_283.data());
	inputFile.getVar("disk_function_283").getVar(flat_df_283.data());
	inputFile.getVar("radiance_365").getVar(flat_rad_365.data());
	inputFile.getVar("reflectance_365").getVar(flat_ref_365.data());
	inputFile.getVar("corrected_reflectance_365").getVar(flat_coref_365.data());
	inputFile.getVar("disk_function_365").getVar(flat_df_365.data());

	std::vector<int> flat_avail(num_t * num_y * num_x);
	std::vector<int> flat_status(num_t * num_y * num_x);
	std::vector<double> flat_so2(num_t * num_y * num_x);
	std::vector<double> flat_ni(num_t * num_y * num_x);
	
	inputFile.getVar("availability").getVar(flat_avail.data());
	inputFile.getVar("retrieval_status").getVar(flat_status.data());
	inputFile.getVar("so2").getVar(flat_so2.data());
	inputFile.getVar("ni").getVar(flat_ni.data());

	//#pragma omp parallel for
	for(int y = 0; y < num_y; y ++)
	{
		for(int x = 0; x < num_x; x ++)
		{
			int idx = x * num_y + y;
			incidence_zenith_angle[x][y] = flat_inang[idx];
			emission_zenith_angle[x][y] = flat_emang[idx];
			emission_azimuth_angle[x][y] = flat_phi[idx];
			phase_angle[x][y] = flat_phang[idx];
			radiance_283[x][y] = flat_rad_283[idx];
			reflectance_283[x][y] = flat_ref_283[idx];
			corrected_reflectance_283[x][y] = flat_coref_283[idx];
			disk_function_283[x][y] = flat_df_283[idx];
			radiance_365[x][y] = flat_rad_365[idx];
			reflectance_365[x][y] = flat_ref_365[idx];
			corrected_reflectance_365[x][y] = flat_coref_365[idx];
			disk_function_365[x][y] = flat_df_365[idx];
		}
	}

	for(int y = 0; y < num_y; y ++)
	{
		for(int x = 0; x < num_x; x ++)
		{
			if(is_sensitivity_test)
			{
				for(int t = 0; t < num_t; t ++)
				{
					int idx = x * num_y * num_t + y * num_t + t;

					so2_st[x][y][t] = flat_so2[idx];
					ni_st[x][y][t] = flat_ni[idx];

					if(flat_avail[idx] > 0.5)
					{
						availability_st[x][y][t] = true;
					}
					else
					{
						availability_st[x][y][t] = false;
					}
					
					// Success,                // ピクセルでリトリーバル成功
					// NoObservation,          // 観測がない
					// ValueBelowLowerBound,   // 観測値がシミュレーションの下限より下
					// ValueAboveUpperBound,   // 観測値がシミュレーションの上限より上
					// ConvergenceFailure,     // シミュレーションが収束しなかった
					// OutOfGeometry 
					if(flat_status[idx] == 0)
					{
						retrieval_status_st[x][y][t] = RetrievalStatus::Success;
					}
					if(flat_status[idx] == 1)
					{
						retrieval_status_st[x][y][t] = RetrievalStatus::NoObservation;
					}
					if(flat_status[idx] == 2)
					{
						retrieval_status_st[x][y][t] = RetrievalStatus::ValueBelowLowerBound;
					}
					if(flat_status[idx] == 3)
					{
						retrieval_status_st[x][y][t] = RetrievalStatus::ValueAboveUpperBound;
					}
					if(flat_status[idx] == 4)
					{
						retrieval_status_st[x][y][t] = RetrievalStatus::ConvergenceFailure;
					}
					if(flat_status[idx] == 5)
					{
						retrieval_status_st[x][y][t] = RetrievalStatus::OutOfGeometry;
					}
				}
			}
			else
			{
				int idx = x * num_y + y;

				so2[x][y] = flat_so2[idx];
				ni[x][y] = flat_ni[idx];

				if(flat_avail[idx] > 0.5)
				{
					availability[x][y] = true;
				}
				else
				{
					availability[x][y] = false;
				}
				
				// Success,                // ピクセルでリトリーバル成功
				// NoObservation,          // 観測がない
				// ValueBelowLowerBound,   // 観測値がシミュレーションの下限より下
				// ValueAboveUpperBound,   // 観測値がシミュレーションの上限より上
				// ConvergenceFailure,     // シミュレーションが収束しなかった
				// OutOfGeometry 
				if(flat_status[idx] == 0)
				{
					retrieval_status[x][y] = RetrievalStatus::Success;
				}
				if(flat_status[idx] == 1)
				{
					retrieval_status[x][y] = RetrievalStatus::NoObservation;
				}
				if(flat_status[idx] == 2)
				{
					retrieval_status[x][y] = RetrievalStatus::ValueBelowLowerBound;
				}
				if(flat_status[idx] == 3)
				{
					retrieval_status[x][y] = RetrievalStatus::ValueAboveUpperBound;
				}
				if(flat_status[idx] == 4)
				{
					retrieval_status[x][y] = RetrievalStatus::ConvergenceFailure;
				}
				if(flat_status[idx] == 5)
				{
					retrieval_status[x][y] = RetrievalStatus::OutOfGeometry;
				}
			}
		}
	}

	return;
}

inline std::vector<std::string> splitString(std::string str, char del)
{
	int first = 0;
	int last = str.find_first_of(del);

	std::vector<std::string> result;

	while (first < str.size())
	{
		std::string subStr(str, first, last - first);

		result.push_back(subStr);

		first = last + 1;
		last = str.find_first_of(del, first);

		if (last == std::string::npos)
		{
			last = str.size();
		}
	}

	return result;
}

inline std::vector<std::vector<std::vector<std::vector<double>>>> importReflectanceModel(spherical_grid::IcosahedralGrid sphere, std::string directory_name)
{
	//const int N_model = 11;

	std::vector<std::vector<int>> model_number;
	std::vector<std::string> filelist;

	int s_max = -1;
	int u_max = -1;

	if(directory_name[directory_name.size() - 1] != '/')
	{
		directory_name = directory_name + "/";
	}

	for (const auto & file : std::filesystem::directory_iterator(directory_name))
	{
		std::string name = file.path();
		name = name.substr(directory_name.size());
		//std::cout << name << std::endl;
		if(name[0] != '.')
		{
			if(name[0] == 'r' && name[1] == 'e' && name[2] == 's')
			{
				//std::cout << name << std::endl;
				name = name.substr(8);	//result_R0_11.dat -> 0_11.dat
				//std::cout << name << std::endl;
				name = name.substr(0, name.size() - 4);	//0_11.dat -> 0_11

				auto name2 = splitString(name, '_');
				//std::cout << name2[0] << ", " << name2[1] << std::endl;
				std::vector<int> num = {std::stoi(name2[0]), std::stoi(name2[1])};
				
				if(s_max < num[0])
				{
					s_max = num[0];
				}
				if(u_max < num[1])
				{
					u_max = num[1];
				}

				model_number.push_back(num);
			}
		}
	}

	//std::cout << s_max << ", " << u_max << std::endl;

	std::vector<std::vector<std::vector<std::vector<double>>>> R_model = std::vector<std::vector<std::vector<std::vector<double>>>>(s_max + 1, std::vector<std::vector<std::vector<double>>>(u_max + 1, std::vector<std::vector<double>>(sphere.num_face, std::vector<double>(sphere.num_face))));

	//std::cout << "Loading Radiance Models." << std::endl;
	//#pragma omp parallel for
	for(int s = 0; s <= s_max; s ++)
	{
		#pragma omp parallel for
		for(int u = 0; u <= u_max; u ++)
		{
			std::string filename = directory_name + "result_R" + std::to_string(s) + "_" + std::to_string(u) + ".dat";
			//std::cout << filename << "\n" << std::flush;
			std::ifstream input_model(filename);
			std::string str;

			while(std::getline(input_model, str))
			{
				//std::cout << str << std::endl;

				if(str[0] != '#' && str.size() > 0)
				{
					auto data = splitString(str, ',');

					int i = std::stoi(data[0]);
					int j = std::stoi(data[1]);

					//std::cout << i << ", " << j << ", " << data[6] << std::endl;
					
					R_model[s][u][i][j] = std::stod(data[6]);
				}
			}
		}
	}

	return R_model;
}

inline void AkatsukiUVIL3bRetrievedData::importOldRetrievedDataNetCDF(std::string filename)
{
	netCDF::NcFile inputFile(filename, netCDF::NcFile::read);

	// 次元の読み込み
	netCDF::NcDim dim_nx = inputFile.getDim("num_x");
	netCDF::NcDim dim_ny = inputFile.getDim("num_y");

	num_x = dim_nx.getSize();
	num_y = dim_ny.getSize();

	_resizeVector();

	// 次元データの読み込み
	netCDF::NcVar var_lon = inputFile.getVar("longitude");
	var_lon.getVar(longitude.data());
	netCDF::NcVar var_lat = inputFile.getVar("latitude");
	var_lat.getVar(latitude.data());
	netCDF::NcVar var_lt = inputFile.getVar("local_time");
	var_lt.getVar(local_time.data());

	// 時刻や属性データの読み込み
	netCDF::NcVar var_date = inputFile.getVar("observation_date");
	char* cStr;
	var_date.getVar(&cStr);
	time_str = std::string(cStr);

	inputFile.getVar("hours_since_2000").getVar(&hours_since_2000);
	inputFile.getVar("subsolar_longitude").getVar(&subsolar_longitude);
	inputFile.getVar("subsolar_latitude").getVar(&subsolar_latitude);
	inputFile.getVar("subsc_longitude").getVar(&subsc_longitude);
	inputFile.getVar("subsc_latitude").getVar(&subsc_latitude);
	inputFile.getVar("subsc_phangle").getVar(&subsc_phangle);
	inputFile.getVar("mean_solar_phangle").getVar(&mean_solar_phase_angle);
	inputFile.getVar("dv").getVar(&dv);

	inputFile.getVar("ni_ratio").getVar(&ni_ratio);

	free(cStr);

	std::vector<double> flat_inang(num_y * num_x);
	std::vector<double> flat_emang(num_y * num_x);
	std::vector<double> flat_phang(num_y * num_x);
	std::vector<int> flat_avail(num_y * num_x);

	std::vector<double> flat_rad_283(num_y * num_x);
	std::vector<double> flat_ref_283(num_y * num_x);
	std::vector<double> flat_coref_283(num_y * num_x);
	std::vector<double> flat_df_283(num_y * num_x);
	std::vector<double> flat_rad_365(num_y * num_x);
	std::vector<double> flat_ref_365(num_y * num_x);
	std::vector<double> flat_coref_365(num_y * num_x);
	std::vector<double> flat_df_365(num_y * num_x);

	std::vector<double> flat_so2(num_y * num_x);
	std::vector<double> flat_ni(num_y * num_x);

	inputFile.getVar("inangle").getVar(flat_inang.data());
	inputFile.getVar("emangle").getVar(flat_emang.data());
	inputFile.getVar("phangle").getVar(flat_phang.data());
	inputFile.getVar("availability").getVar(flat_avail.data());
	inputFile.getVar("radiance_283").getVar(flat_rad_283.data());
	inputFile.getVar("reflectance_283").getVar(flat_ref_283.data());
	inputFile.getVar("corrected_reflectance_283").getVar(flat_coref_283.data());
	inputFile.getVar("disk_function_283").getVar(flat_df_283.data());
	inputFile.getVar("radiance_365").getVar(flat_rad_365.data());
	inputFile.getVar("reflectance_365").getVar(flat_ref_365.data());
	inputFile.getVar("corrected_reflectance_365").getVar(flat_coref_365.data());
	inputFile.getVar("disk_function_365").getVar(flat_df_365.data());
	inputFile.getVar("so2").getVar(flat_so2.data());
	inputFile.getVar("ni").getVar(flat_ni.data());

	//#pragma omp parallel for
	for(int y = 0; y < num_y; y ++)
	{
		for(int x = 0; x < num_x; x ++)
		{
			int idx = x * num_y + y;
			incidence_zenith_angle[x][y] = flat_inang[idx];
			emission_zenith_angle[x][y] = flat_emang[idx];
			phase_angle[x][y] = flat_phang[idx];
			radiance_283[x][y] = flat_rad_283[idx];
			reflectance_283[x][y] = flat_ref_283[idx];
			corrected_reflectance_283[x][y] = flat_coref_283[idx];
			disk_function_283[x][y] = flat_df_283[idx];
			radiance_365[x][y] = flat_rad_365[idx];
			reflectance_365[x][y] = flat_ref_365[idx];
			corrected_reflectance_365[x][y] = flat_coref_365[idx];
			disk_function_365[x][y] = flat_df_365[idx];

			so2[x][y] = flat_so2[idx];
			ni[x][y] = flat_ni[idx];

			if(so2[x][y] > 0.0 && ni[x][y] > 0.0)
			{
				availability[x][y] = true;
			}
			else
			{
				availability[x][y] = false;
			}
		}
	}

	return;
}

inline void AkatsukiUVIL3bRetrievedData::makeQuickLook(std::string filename_image, int nt = 0)
{
	std::ofstream output_data("temp_data.dat");
	for(int x = 0; x < num_x; x ++)
	{
		for(int y = 0; y < num_y; y ++)
		{
			if(is_sensitivity_test)
			{
				output_data << x << ", " << y << ", " << longitude[x] << ", " << latitude[y] << ", " << local_time[x] << ", " << availability_st[x][y][nt] << ", " << std::flush;
				if(retrieval_status_st[x][y][nt] == RetrievalStatus::Success)
				{
					output_data << 0 << std::flush;
				}
				else if(retrieval_status_st[x][y][nt] == RetrievalStatus::NoObservation)
				{
					output_data << 1 << std::flush;
				}
				else if(retrieval_status_st[x][y][nt] == RetrievalStatus::ValueBelowLowerBound)
				{
					output_data << 2 << std::flush;
				}
				else if(retrieval_status_st[x][y][nt] == RetrievalStatus::ValueAboveUpperBound)
				{
					output_data << 3 << std::flush;
				}
				else if(retrieval_status_st[x][y][nt] == RetrievalStatus::ConvergenceFailure)
				{
					output_data << 4 << std::flush;
				}
				else if(retrieval_status_st[x][y][nt] == RetrievalStatus::OutOfGeometry)
				{
					output_data << 5 << std::flush;
				}
			}
			else
			{
				output_data << x << ", " << y << ", " << longitude[x] << ", " << latitude[y] << ", " << local_time[x] << ", " << availability[x][y] << ", " << std::flush;
				if(retrieval_status[x][y] == RetrievalStatus::Success)
				{
					output_data << 0 << std::flush;
				}
				else if(retrieval_status[x][y] == RetrievalStatus::NoObservation)
				{
					output_data << 1 << std::flush;
				}
				else if(retrieval_status[x][y] == RetrievalStatus::ValueBelowLowerBound)
				{
					output_data << 2 << std::flush;
				}
				else if(retrieval_status[x][y] == RetrievalStatus::ValueAboveUpperBound)
				{
					output_data << 3 << std::flush;
				}
				else if(retrieval_status[x][y] == RetrievalStatus::ConvergenceFailure)
				{
					output_data << 4 << std::flush;
				}
				else if(retrieval_status[x][y] == RetrievalStatus::OutOfGeometry)
				{
					output_data << 5 << std::flush;
				}
			}

			if(is_sensitivity_test)
			{
				if(availability_st[x][y][nt] == true)
				{
					output_data << ", " << incidence_zenith_angle[x][y] << std::flush;
					output_data << ", " << emission_zenith_angle[x][y] << std::flush;
					output_data << ", " << emission_azimuth_angle[x][y] << std::flush;
					output_data << ", " << phase_angle[x][y] << std::flush;
					output_data << ", " << so2_st[x][y][nt] << std::flush;
					output_data << ", " << ni_st[x][y][nt] << std::flush;
					output_data << ", " << reflectance_283[x][y] << ", " << reflectance_365[x][y] << std::endl << std::flush;
				}
				else
				{
					output_data << ", " << -99.0 << ", " << -99.0 << ", " << -99.0 << ", " << -99.0 << ", " << -99.0 << ", " << -99.0 << ", " << -99.0 << ", " << -99.0 << std::endl << std::flush;
				}
			}
			else
			{
				if(availability[x][y] == true)
				{
					output_data << ", " << incidence_zenith_angle[x][y] << std::flush;
					output_data << ", " << emission_zenith_angle[x][y] << std::flush;
					output_data << ", " << emission_azimuth_angle[x][y] << std::flush;
					output_data << ", " << phase_angle[x][y] << std::flush;
					output_data << ", " << so2[x][y] << std::flush;
					output_data << ", " << ni[x][y] << std::flush;
					output_data << ", " << reflectance_283[x][y] << ", " << reflectance_365[x][y] << std::endl << std::flush;
				}
				else
				{
					output_data << ", " << -99.0 << ", " << -99.0 << ", " << -99.0 << ", " << -99.0 << ", " << -99.0 << ", " << -99.0 << ", " << -99.0 << ", " << -99.0 << std::endl << std::flush;
				}
			}
		}
		output_data << std::endl;
	}

	std::ofstream output("temp_plot.plt");

	//retrieval status
	//local time
	//inangle
	//emangle
	//emission azimuth angle
	//phangle	
	//r283
	//r365
	//so2
	//ni

	output << "reset" << std::endl;
	output << "set terminal pngcairo size 1600, 2000 font \"Open Sans, 15\"" << std::endl;

	output << "set output \"" << filename_image << "\"" << std::endl;

	output << "set multiplot layout 4, 2 title \"" << time_str << "\" font \"Open Sans, 25\" offset 0, -2.5" << std::endl;

	output << "set xrange [0:360]" << std::endl;
	output << "set xtics 30" << std::endl;
	output << "set yrange [-90:90]" << std::endl;
	output << "set ytics 30" << std::endl;
	output << "set grid" << std::endl;
	output << "set size ratio -1" << std::endl;

	output << "unset key" << std::endl;

	output << "in = \"temp_data.dat\"" << std::endl;


	output << "set palette defined (0 \"green\",1 \"gray50\", 2 \"blue\", 3 \"red\", 4 \"orange\", 5 \"gray\")" << std::endl;
	output << "set cbrange[0:6]" << std::endl;
	output << "set palette maxcolors 6" << std::endl;
	output << "set lmargin at screen 0.1" << std::endl;
	output << "set rmargin at screen 0.4" << std::endl;
	output << "set tmargin at screen 0.925" << std::endl;
	output << "set bmargin at screen 0.775" << std::endl;
	output << "unset xlabel" << std::endl;
	output << "set ylabel \"Latitude (degree)\"" << std::endl;
	//output << "set cblabel \"Retrieval Status\" offset 0.2, 0" << std::endl;
	output << "set cbtics (\"Suc\" 0.5, \"NoObs\" 1.5, \"Under\" 2.5, \"Over\" 3.5, \"NoConv\" 4.5, \"OutGeo\" 5.5) font \"Open Sans, 15\"" << std::endl;
	//set cbtics ("Suc" 0, "NoObs" 1, "Under" 2, "Over" 3, "NoConv" 4, "OutGeo" 5)
	output << "set cbtics scale 0" << std::endl;
	output << "set title \"Retrieval Status\" offset 0,-0.6" << std::endl;
	output << "plot in using 3:4:7 with image" << std::endl;

	output << "set palette defined(0\"#00008b\",1\"#2ca9e1\",2\"#38b48b\",3.5\"#ffff00\",5\"#eb6101\",5.3\"#c9171e\")" << std::endl;
	output << "set palette maxcolors 1024" << std::endl;
	output << "unset cbtics" << std::endl;
	output << "unset cbrange" << std::endl;
	output << "set cbtics auto" << std::endl;

	// output << "set lmargin at screen 0.1" << std::endl;
	// output << "set rmargin at screen 0.4" << std::endl;
	// output << "set tmargin at screen 0.9" << std::endl;
	// output << "set bmargin at screen 0.75" << std::endl;
	// output << "unset xlabel" << std::endl;
	// output << "set ylabel \"Latitude (degree)\"" << std::endl;
	// output << "set cblabel \"Local time (hour)\" offset 0.2, 0" << std::endl;
	// output << "set title \"Local time\" offset 0,-0.6" << std::endl;
	// output << "plot in using 3:4:($6>0?$5:1/0) with image" << std::endl;

	output << "set lmargin at screen 0.55" << std::endl;
	output << "set rmargin at screen 0.85" << std::endl;
	output << "set tmargin at screen 0.925" << std::endl;
	output << "set bmargin at screen 0.775" << std::endl;
	output << "unset xlabel" << std::endl;
	output << "unset ylabel" << std::endl;
	output << "set cblabel \"Local time (hour)\"" << std::endl;
	output << "set title \"Local time\"" << std::endl;
	output << "plot in using 3:4:($6>0?$5:1/0) with image" << std::endl;



	output << "set lmargin at screen 0.1" << std::endl;
	output << "set rmargin at screen 0.4" << std::endl;
	output << "set tmargin at screen 0.75" << std::endl;
	output << "set bmargin at screen 0.6" << std::endl;
	output << "unset xlabel" << std::endl;
	output << "set ylabel \"Latitude (degree)\"" << std::endl;
	output << "set cblabel \"Incidence zenith angle (degree)\"" << std::endl;
	output << "set title \"Incidence zenith angle\"" << std::endl;
	output << "plot in using 3:4:($6>0?$8:1/0) with image" << std::endl;



	output << "set lmargin at screen 0.55" << std::endl;
	output << "set rmargin at screen 0.85" << std::endl;
	output << "set tmargin at screen 0.75" << std::endl;
	output << "set bmargin at screen 0.6" << std::endl;
	output << "unset xlabel" << std::endl;
	output << "unset ylabel" << std::endl;
	output << "set cblabel \"Emission zenith angle (degree)\"" << std::endl;
	output << "set title \"Emission zenith angle\"" << std::endl;
	output << "plot in using 3:4:($6>0?$9:1/0) with image" << std::endl;

	

	output << "set lmargin at screen 0.1" << std::endl;
	output << "set rmargin at screen 0.4" << std::endl;
	output << "set tmargin at screen 0.575" << std::endl;
	output << "set bmargin at screen 0.425" << std::endl;
	output << "unset xlabel" << std::endl;
	output << "set ylabel \"Latitude (degree)\"" << std::endl;
	output << "set cblabel \"Emission azimuth angle (degree)\"" << std::endl;
	output << "set title \"Emission azimuth angle\"" << std::endl;
	output << "plot in using 3:4:($6>0?$10:1/0) with image" << std::endl;



	output << "set lmargin at screen 0.55" << std::endl;
	output << "set rmargin at screen 0.85" << std::endl;
	output << "set tmargin at screen 0.575" << std::endl;
	output << "set bmargin at screen 0.425" << std::endl;
	output << "unset xlabel" << std::endl;
	output << "unset ylabel" << std::endl;
	output << "set cblabel \"Phase angle (degree)\"" << std::endl;
	output << "set title \"Phase angle\"" << std::endl;
	output << "plot in using 3:4:($6>0?$11:1/0) with image" << std::endl;



	output << "set lmargin at screen 0.1" << std::endl;
	output << "set rmargin at screen 0.4" << std::endl;
	output << "set tmargin at screen 0.4" << std::endl;
	output << "set bmargin at screen 0.25" << std::endl;
	output << "unset xlabel" << std::endl;
	output << "set ylabel \"Latitude (degree)\"" << std::endl;
	output << "set cbrange[0:300]" << std::endl;
	output << "set cblabel \"SO_2 vmr (ppb)\"" << std::endl;
	output << "set title \"SO_2\"" << std::endl;
	output << "plot in using 3:4:($6>0?$12:1/0) with image" << std::endl;



	output << "set lmargin at screen 0.55" << std::endl;
	output << "set rmargin at screen 0.85" << std::endl;
	output << "set tmargin at screen 0.4" << std::endl;
	output << "set bmargin at screen 0.25" << std::endl;
	output << "unset xlabel" << std::endl;
	output << "unset ylabel" << std::endl;
	output << "set cbrange[0:0.003]" << std::endl;
	output << "set cblabel \"n_i\"" << std::endl;
	output << "set title \"n_i (365 nm)\"" << std::endl;
	output << "plot in using 3:4:($6>0?$13:1/0) with image" << std::endl;



	output << "set lmargin at screen 0.1" << std::endl;
	output << "set rmargin at screen 0.4" << std::endl;
	output << "set tmargin at screen 0.225" << std::endl;
	output << "set bmargin at screen 0.075" << std::endl;
	output << "unset cbrange" << std::endl;
	output << "set ylabel \"Latitude (degree)\"" << std::endl;
	output << "set xlabel \"Longitude (degree)\"" << std::endl;
	output << "set cblabel \"Reflectance\"" << std::endl;
	output << "set title \"Reflectance (283 nm)\"" << std::endl;
	output << "plot in using 3:4:($6>0?$14:1/0) with image" << std::endl;



	output << "set lmargin at screen 0.55" << std::endl;
	output << "set rmargin at screen 0.85" << std::endl;
	output << "set tmargin at screen 0.225" << std::endl;
	output << "set bmargin at screen 0.075" << std::endl;
	output << "set xlabel \"Longitude (degree)\"" << std::endl;
	output << "unset ylabel" << std::endl;
	output << "set cblabel \"Reflectance\"" << std::endl;
	output << "set title \"Reflectance (365 nm)\"" << std::endl;
	output << "plot in using 3:4:($6>0?$15:1/0) with image" << std::endl;

	output << "unset multiplot" << std::endl;

	std::string command = "gnuplot temp_plot.plt";
	int sc = std::system(command.data());
	command = "rm temp_plot.plt temp_data.dat";
	sc = std::system(command.data());

	return;
}

// elapsedHours: 2000/01/01 00:00:00からの経過時間（時間単位、少数可）
inline std::string convertElapsedTime(double elapsedHours)
{
	// 基準日時 2000/01/01 00:00:00 を表す std::tm 構造体を作成
	std::tm baseTm = {};
	baseTm.tm_year = 2000 - 1900; // 年は1900年からのオフセット
	baseTm.tm_mon  = 0;          // 月は0から（0＝1月）
	baseTm.tm_mday = 1;          // 日
	baseTm.tm_hour = 0;
	baseTm.tm_min  = 0;
	baseTm.tm_sec  = 0;
	baseTm.tm_isdst = 0;        // 夏時間の判定は自動

	// 基準日時を time_t 型に変換
	time_t baseTime = std::mktime(&baseTm);
	if (baseTime == -1)
	{
		return "";
	}

	// 経過時間を秒に変換（double→秒、四捨五入）
	time_t offsetSeconds = static_cast<time_t>(std::round(elapsedHours * 3600.0));

	// 基準時刻に offsetSeconds を加算
	time_t targetTime = baseTime + offsetSeconds;

	// time_t を std::tm に変換（ローカルタイムとして）
	std::tm* targetTm = std::localtime(&targetTime);
	if (!targetTm)
	{
		return "";
	}

	// std::ostringstream と std::put_time を使ってフォーマット
	std::ostringstream oss;
	oss << std::put_time(targetTm, "%Y-%m-%d %H:%M:%S");
	return oss.str();
}

// 逆変換: "YYYY-MM-DD HH:MM:SS" → 経過時間[hour]
inline double convertToElapsedHours(const std::string &dateTimeStr)
{
	// 1. 文字列 → std::tm
	std::tm targetTm = {};
	std::istringstream iss(dateTimeStr);
	iss >> std::get_time(&targetTm, "%Y-%m-%d %H:%M:%S");

	if (iss.fail())
	{
		// パース失敗
		return std::numeric_limits<double>::quiet_NaN();
	}

	targetTm.tm_isdst = 0;		// 夏時間判定はライブラリに任せる

	// 2. std::tm → time_t（ローカル時刻として解釈）
	std::time_t targetTime = std::mktime(&targetTm);
	if (targetTime == -1)
	{
		return std::numeric_limits<double>::quiet_NaN();
	}

	// 3. 基準時刻 (2000/01/01 00:00:00) を time_t に
	std::tm baseTm = {};
	baseTm.tm_year = 2000 - 1900;
	baseTm.tm_mon  = 0;
	baseTm.tm_mday = 1;
	baseTm.tm_isdst = -1;

	std::time_t baseTime = std::mktime(&baseTm);
	if (baseTime == -1)
	{
		return std::numeric_limits<double>::quiet_NaN();
	}

	// 4. 差分を秒 → 時間(double) に
	double elapsedSeconds = std::difftime(targetTime, baseTime);	// double 秒
	return elapsedSeconds / 3600.0;								// 時間に換算
}

class CloudTrackedWindSet
{
	private:

	public:

		int num_x, num_y, num_time;

		std::vector<std::vector<double>> longitude;
		std::vector<double> local_time;
		std::vector<double> latitude;

		std::vector<std::vector<std::vector<bool>>> availability;
		std::vector<double> hours_since_2000;
		std::vector<double> subsolar_longitude;
		std::vector<double> subsolar_latitude;
		std::vector<double> subsc_longitude;
		std::vector<double> subsc_latitude;

		std::vector<std::vector<std::vector<std::vector<double>>>> velocity;

		void importNetCDF(std::string);
};

inline void CloudTrackedWindSet::importNetCDF(std::string filename)
{
	netCDF::NcFile input(filename, netCDF::NcFile::read);

	int time_dimension = input.getDim("time").getSize();
	int longitude_dimension = input.getDim("LT").getSize();
	int latitude_dimension = input.getDim("latitude").getSize();

	num_x = longitude_dimension;
	num_y = latitude_dimension;
	num_time = time_dimension;

	subsolar_longitude.resize(num_time);
	subsolar_latitude.resize(num_time);
	subsc_longitude.resize(num_time);
	subsc_latitude.resize(num_time);
	hours_since_2000.resize(num_time);

	longitude.resize(num_time, std::vector<double>(num_x));
	latitude.resize(num_y);

	local_time.resize(num_x);
	// availability.resize(NT);
	// velocity.resize(NT);

	// local_time.resize(num_x, std::vector<double>(num_y));
	availability.resize(num_time, std::vector<std::vector<bool>>(num_x, std::vector<bool>(num_y)));
	velocity.resize(num_time, std::vector<std::vector<std::vector<double>>>(num_x, std::vector<std::vector<double>>(num_y, std::vector<double>(2))));

	double* t = new double[num_time];

	float* sslon = new float[num_time];
	float* sslat = new float[num_time];
	float* sclon = new float[num_time];
	float* sclat = new float[num_time];

	float* lon = new float[num_time * num_x];
	double* lt = new double[num_x];
	float* lat = new float[num_y];

	float* u = new float[num_time * num_y * num_x];
	float* v = new float[num_time * num_y * num_x];

	netCDF::NcVar time0 = input.getVar("time");
	time0.getVar(t);
	
	netCDF::NcVar sslon0 = input.getVar("S_SOLLON");
	sslon0.getVar(sslon);

	netCDF::NcVar sslat0 = input.getVar("S_SOLLAT");
	sslat0.getVar(sslat);

	netCDF::NcVar sclon0 = input.getVar("S_SSCLON");
	sclon0.getVar(sclon);

	netCDF::NcVar sclat0 = input.getVar("S_SSCLAT");
	sclat0.getVar(sclat);

	netCDF::NcVar longitude0 = input.getVar("longitude");
	longitude0.getVar(lon);

	netCDF::NcVar lt0 = input.getVar("LT");
	lt0.getVar(lt);

	netCDF::NcVar latitude0 = input.getVar("latitude");
	latitude0.getVar(lat);

	netCDF::NcVar u0 = input.getVar("U");
	u0.getVar(u);
	
	netCDF::NcVar v0 = input.getVar("V");
	v0.getVar(v);

	#pragma omp parallel for
	for(int i = 0; i < num_time; i ++)
	{
		subsolar_longitude[i] = sslon[i];
		subsolar_latitude[i] = sslat[i];
		subsc_longitude[i] = sclon[i];
		subsc_latitude[i] = sclat[i];
		hours_since_2000[i] = t[i];
		
		for(int j = 0; j < num_x; j ++)
		{
			longitude[i][j] = lon[i * num_x + j];
		}
	}

	#pragma omp parallel for
	for(int i = 0; i < num_y; i ++)
	{
		latitude[i] = lat[i];
	}

	#pragma omp parallel for
	for(int i = 0; i < num_y; i ++)
	{
		latitude[i] = lat[i];
	}

	

	#pragma omp parallel for
	for(int i = 0; i < num_time; i ++)
	{
		for(int j = 0; j < num_x; j ++)
		{
			for(int k = 0; k < num_y; k ++)
			{
				velocity[i][j][k] = {u[i * num_x + k * num_x + j], v[i * num_x * num_y + k * num_x + j]};
				
				if(velocity[i][j][k][0] > -1.0E4)
				{
					availability[i][j][k] = true;
				}
				else
				{
					availability[i][j][k] = false;
				}
			}
		}
	}

	delete[] u;
	delete[] v;
	delete[] t;
	delete[] sslon;
	delete[] sslat;
	delete[] sclon;
	delete[] sclat;
	delete[] lon;
	delete[] lt;
	delete[] lat;

	return;
}

}
#endif