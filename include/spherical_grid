#ifndef __SPHERICAL_INTEGRATION_H__
#define __SPHERICAL_INTEGRATION_H__

#include<iostream>
#include<cmath>
#include<vector>
#include<string>
#include<algorithm>

namespace spherical_grid
{

class IcosahedralGrid
{
	public:
		class Face;

	private:
		std::vector<int> _up;
		std::vector<int> _down;
		std::vector<std::vector<double>> _point;

		void _normalizeVector(std::vector<double>&);
		std::vector<double> _calculateNormalVector(std::vector<double>, std::vector<double>, std::vector<double>);
		std::vector<double> _calculatePositionVector(Face);
		std::vector<double> _calculatePositionPolarVector(Face);
		std::vector<double> _calculatePositionPolarVector(std::vector<double>);
		std::vector<Face> _divideFace(Face);
		double _calculateSolidAngle(Face);
		double _calculateVectorAngle(std::vector<double>, std::vector<double>);
		double _calculateFaceAngle(Face, Face);
		void _sortVortex(int, std::vector<int>&);
		int _findFaceNumber(double, double);
		bool _isPointOnFace(Face, double, double, double);

	public:		
		int num_face;
		int divide;

		std::vector<Face> face;
		std::vector<Face> face_uh;
		std::vector<Face> face_lh;
		std::vector<double> solid_angle;

		IcosahedralGrid(int);
		IcosahedralGrid(void);
		void initializeGrid(void);
};

class IcosahedralGrid::Face
{
	public:
		std::vector<std::vector<double>> vortex;
		std::vector<double> position;
		std::vector<double> position_polar;
		std::vector<std::vector<double>> polygon;
		double solid_angle;
		double mu;
		std::vector<int> neighbour;
		bool vortex_flg;
		bool up_flg;
		bool down_flg;

		Face(void);
};

class SphericalGrid
{
	private:
		std::vector<std::vector<double>> _point;
		std::vector<int> _up;
		std::vector<int> _down;

	public:
		class Face;
		
		int num_face;

		int Ntheta;
		std::vector<int> Nphi;

		std::vector<int> Nphi0;

		std::vector<Face> face;
		std::vector<Face> face_uh;
		std::vector<Face> face_lh;

		// std::vector<std::vector<double>> weight_column_uh_ptr;
		// std::vector<std::vector<double>> weight_row_uh_ptr;
		// std::vector<std::vector<double>> mu_weight_column_uh_ptr;
		// std::vector<std::vector<double>> mu_weight_row_uh_ptr;
		// std::vector<std::vector<double>> weight_uh_ptr;
		// std::vector<std::vector<double>> mu_weight_uh_ptr;

		// std::vector<std::vector<double>> weight_column_lh_ptr;
		// std::vector<std::vector<double>> weight_row_lh_ptr;
		// std::vector<std::vector<double>> mu_weight_column_lh_ptr;
		// std::vector<std::vector<double>> mu_weight_row_lh_ptr;
		// std::vector<std::vector<double>> weight_lh_ptr;
		// std::vector<std::vector<double>> mu_weight_lh_ptr;

		double* weight_column_uh_ptr;
		double* weight_row_uh_ptr;
		double* mu_weight_column_uh_ptr;
		double* mu_weight_row_uh_ptr;
		double* weight_uh_ptr;
		double* mu_weight_uh_ptr;

		double* weight_column_lh_ptr;
		double* weight_row_lh_ptr;
		double* mu_weight_column_lh_ptr;
		double* mu_weight_row_lh_ptr;
		double* weight_lh_ptr;
		double* mu_weight_lh_ptr;

		void initializeGrid(void);

		SphericalGrid(void) : weight_column_uh_ptr(nullptr), weight_row_uh_ptr(nullptr), mu_weight_column_uh_ptr(nullptr), mu_weight_row_uh_ptr(nullptr), weight_column_lh_ptr(nullptr), weight_row_lh_ptr(nullptr), mu_weight_column_lh_ptr(nullptr), mu_weight_row_lh_ptr(nullptr), weight_uh_ptr(nullptr), mu_weight_uh_ptr(nullptr), weight_lh_ptr(nullptr), mu_weight_lh_ptr(nullptr), Ntheta(15)
		{
			//
		}

		SphericalGrid(int ntheta) : weight_column_uh_ptr(nullptr), weight_row_uh_ptr(nullptr), mu_weight_column_uh_ptr(nullptr), mu_weight_row_uh_ptr(nullptr), weight_column_lh_ptr(nullptr), weight_row_lh_ptr(nullptr), mu_weight_column_lh_ptr(nullptr), mu_weight_row_lh_ptr(nullptr), weight_uh_ptr(nullptr), mu_weight_uh_ptr(nullptr), weight_lh_ptr(nullptr), mu_weight_lh_ptr(nullptr)
		{
			Ntheta = ntheta;

			initializeGrid();
		}

		SphericalGrid(const SphericalGrid& sphere)
		{
			num_face = sphere.num_face;

			Ntheta = sphere.Ntheta;
			Nphi = sphere.Nphi;

			face = sphere.face;
			face_uh = sphere.face_uh;
			face_lh = sphere.face_lh;
			_point = sphere._point;

			_up = sphere._up;
			_down = sphere._down;

			weight_column_uh_ptr = new double[num_face];
			weight_row_uh_ptr = new double[num_face];
			mu_weight_column_uh_ptr = new double[num_face];
			mu_weight_row_uh_ptr = new double[num_face];
			weight_column_lh_ptr = new double[num_face];
			weight_row_lh_ptr = new double[num_face];
			mu_weight_column_lh_ptr = new double[num_face];
			mu_weight_row_lh_ptr = new double[num_face];
			weight_uh_ptr = new double[num_face * num_face];
			mu_weight_uh_ptr = new double[num_face * num_face];
			weight_lh_ptr = new double[num_face * num_face];
			mu_weight_lh_ptr = new double[num_face * num_face];

			#pragma omp parallel for
			for (int i = 0; i < num_face; i ++)
			{
				weight_column_uh_ptr[i] = sphere.weight_column_uh_ptr[i];
				weight_row_uh_ptr[i] = sphere.weight_row_uh_ptr[i];
				mu_weight_column_uh_ptr[i] = sphere.mu_weight_column_uh_ptr[i];
				mu_weight_row_uh_ptr[i] = sphere.mu_weight_row_uh_ptr[i];
				weight_column_lh_ptr[i] = sphere.weight_column_lh_ptr[i];
				weight_row_lh_ptr[i] = sphere.weight_row_lh_ptr[i];
				mu_weight_column_lh_ptr[i] = sphere.mu_weight_column_lh_ptr[i];
				mu_weight_row_lh_ptr[i] = sphere.mu_weight_row_lh_ptr[i];
			}
			#pragma omp parallel for
			for(int i = 0; i < num_face * num_face; i ++)
			{
				weight_uh_ptr[i] = sphere.weight_uh_ptr[i];
				mu_weight_uh_ptr[i] = sphere.mu_weight_uh_ptr[i];
				weight_lh_ptr[i] = sphere.weight_lh_ptr[i];
				mu_weight_lh_ptr[i] = sphere.mu_weight_lh_ptr[i];
			}
		}
		
		SphericalGrid& operator=(const SphericalGrid& sphere)
		{
			//std::cout << "Layer copy assignment operator called" << std::endl;

			if (this == &sphere)
			{
				return *this;
			}

			delete[] weight_column_uh_ptr;
			delete[] weight_row_uh_ptr;
			delete[] mu_weight_column_uh_ptr;
			delete[] mu_weight_row_uh_ptr;
			delete[] weight_uh_ptr;
			delete[] mu_weight_uh_ptr;

			delete[] weight_column_lh_ptr;
			delete[] weight_row_lh_ptr;
			delete[] mu_weight_column_lh_ptr;
			delete[] mu_weight_row_lh_ptr;
			delete[] weight_lh_ptr;
			delete[] mu_weight_lh_ptr;

			num_face = sphere.num_face;

			Ntheta = sphere.Ntheta;
			Nphi = sphere.Nphi;

			face = sphere.face;
			face_uh = sphere.face_uh;
			face_lh = sphere.face_lh;
			_point = sphere._point;

			_up = sphere._up;
			_down = sphere._down;

			weight_column_uh_ptr = new double[num_face];
			weight_row_uh_ptr = new double[num_face];
			mu_weight_column_uh_ptr = new double[num_face];
			mu_weight_row_uh_ptr = new double[num_face];
			weight_column_lh_ptr = new double[num_face];
			weight_row_lh_ptr = new double[num_face];
			mu_weight_column_lh_ptr = new double[num_face];
			mu_weight_row_lh_ptr = new double[num_face];
			weight_uh_ptr = new double[num_face * num_face];
			mu_weight_uh_ptr = new double[num_face * num_face];
			weight_lh_ptr = new double[num_face * num_face];
			mu_weight_lh_ptr = new double[num_face * num_face];

			#pragma omp parallel for
			for (int i = 0; i < num_face; i ++)
			{
				weight_column_uh_ptr[i] = sphere.weight_column_uh_ptr[i];
				weight_row_uh_ptr[i] = sphere.weight_row_uh_ptr[i];
				mu_weight_column_uh_ptr[i] = sphere.mu_weight_column_uh_ptr[i];
				mu_weight_row_uh_ptr[i] = sphere.mu_weight_row_uh_ptr[i];
				weight_column_lh_ptr[i] = sphere.weight_column_lh_ptr[i];
				weight_row_lh_ptr[i] = sphere.weight_row_lh_ptr[i];
				mu_weight_column_lh_ptr[i] = sphere.mu_weight_column_lh_ptr[i];
				mu_weight_row_lh_ptr[i] = sphere.mu_weight_row_lh_ptr[i];
			}
			#pragma omp parallel for
			for(int i = 0; i < num_face * num_face; i ++)
			{
				weight_uh_ptr[i] = sphere.weight_uh_ptr[i];
				mu_weight_uh_ptr[i] = sphere.mu_weight_uh_ptr[i];
				weight_lh_ptr[i] = sphere.weight_lh_ptr[i];
				mu_weight_lh_ptr[i] = sphere.mu_weight_lh_ptr[i];
			}
			return *this;
		}

		~SphericalGrid()
		{
			delete[] weight_column_uh_ptr;
			delete[] weight_row_uh_ptr;
			delete[] mu_weight_column_uh_ptr;
			delete[] mu_weight_row_uh_ptr;
			delete[] weight_uh_ptr;
			delete[] mu_weight_uh_ptr;

			delete[] weight_column_lh_ptr;
			delete[] weight_row_lh_ptr;
			delete[] mu_weight_column_lh_ptr;
			delete[] mu_weight_row_lh_ptr;
			delete[] weight_lh_ptr;
			delete[] mu_weight_lh_ptr;
		}
};

class SphericalGrid::Face
{
	public:
		std::vector<double> position;
		std::vector<double> position_polar;
		std::vector<std::vector<double>> polygon;
		double mu;
		double weight;
		// bool vortex_flg;
		// bool up_flg;
		// bool down_flg;
		Face(void);
};

inline IcosahedralGrid::Face::Face()
{
	vortex.resize(3);
	for(int i = 0; i < 3; i ++)
	{
		vortex[i].resize(3);
	}
	position.resize(3);
	position_polar.resize(2);

	vortex_flg = false;
	up_flg = false;
	down_flg = false;
}

inline IcosahedralGrid::IcosahedralGrid(int n)
{
	divide = n;
	initializeGrid();
}

inline IcosahedralGrid::IcosahedralGrid(void)
{
	divide = 2;
	//Initialization();
}

inline void IcosahedralGrid::initializeGrid(void)
{
	//regular icosahedron
	//(±1,±G,0)
	//(0,±1,±G)
	//(±G,0,±1)

	IcosahedralGrid::_up = {5, 6, 7, 8, 9};	//1 up face to be left
	IcosahedralGrid::_down = {10, 11, 12, 13, 14};	//1 up face and 2 down faces to be left

	std::vector<std::vector<double>> vortex(12, std::vector<double>(3));
	
	double g = (1.0 + std::sqrt(5.0)) / 2.0;
	double h = std::sqrt((5.0 + std::sqrt(5.0)) / 2.0);
	double a = std::sqrt((5.0 - std::sqrt(5.0)) / 10.0);
	double b = std::sqrt((5.0 + std::sqrt(5.0)) / 10.0);
	double c = std::sqrt((5.0 + 2.0 * std::sqrt(5.0)) / 5.0);
	
	vortex[0] = {0.0, 0.0, h};		//A1
	vortex[1] = {0.0, 0.0, -h};		//A2

	vortex[2] = {c, 1.0, b};		//B1
	vortex[3] = {-a, g, b};			//B2
	vortex[4] = {-2.0 * b, 0.0, b};	//B3
	vortex[5] = {-a, -g, b};		//B4
	vortex[6] = {c, -1.0, b};		//B5

	vortex[7] = {2.0 * b, 0.0, -b};	//C1
	vortex[8] = {a, g, -b};			//C2
	vortex[9] = {-c, 1.0, -b};		//C3
	vortex[10] = {-c, -1.0, -b};	//C4
	vortex[11] = {a, -g, -b};		//C5

	Face f[20];
	//(0, 0, h) (top)を1つの頂点とする面たち
	f[0].vortex = {vortex[0], vortex[2], vortex[3]};
	f[1].vortex = {vortex[0], vortex[3], vortex[4]};
	f[2].vortex = {vortex[0], vortex[4], vortex[5]};
	f[3].vortex = {vortex[0], vortex[5], vortex[6]};
	f[4].vortex = {vortex[0], vortex[6], vortex[2]};
	//低緯度の10面のうち上向きの面たち
	f[5].vortex = {vortex[2], vortex[7], vortex[8]};
	f[6].vortex = {vortex[3], vortex[8], vortex[9]};
	f[7].vortex = {vortex[4], vortex[9], vortex[10]};
	f[8].vortex = {vortex[5], vortex[10], vortex[11]};
	f[9].vortex = {vortex[6], vortex[11], vortex[7]};
	//低緯度の10面のうち下向きの面たち
	f[10].vortex = {vortex[7], vortex[6], vortex[2]};
	f[11].vortex = {vortex[8], vortex[2], vortex[3]};
	f[12].vortex = {vortex[9], vortex[3], vortex[4]};
	f[13].vortex = {vortex[10], vortex[4], vortex[5]};
	f[14].vortex = {vortex[11], vortex[5], vortex[6]};
	//(0, 0, -h) (bottom)を1つの頂点とする面たち
	f[15].vortex = {vortex[1], vortex[7], vortex[8]};
	f[16].vortex = {vortex[1], vortex[8], vortex[9]};
	f[17].vortex = {vortex[1], vortex[9], vortex[10]};
	f[18].vortex = {vortex[1], vortex[10], vortex[11]};
	f[19].vortex = {vortex[1], vortex[11], vortex[7]};
	
	for(int i = 0; i < 20; i ++)
	{
		for(int j = 0; j < 3; j ++)
		{
			_normalizeVector(f[i].vortex[j]);
		}

		//f[i].normal = NormalVector(f[i].vortex[0], f[i].vortex[1], f[i].vortex[2]);
		f[i].position = _calculatePositionVector(f[i]);
		f[i].position_polar = _calculatePositionPolarVector(f[i]);
		f[i].solid_angle = _calculateSolidAngle(f[i]);
		//Polygon(f[i]);
		face.push_back(f[i]);
	}
	
	//dividing
	for(int i = 0; i < divide; i ++)
	{
		std::vector<Face> newFace;

		std::vector<int> up_buf;
		std::vector<int> down_buf;

		for(int j = 0; j < face.size(); j ++)
		{
			std::vector<Face> buf = _divideFace(face[j]);
			bool flg = false;

			for(int k = 0; k < _up.size(); k ++)
			{
				if(j == _up[k])
				{
					flg = true;
					break;
				}
			}

			if(flg == true)
			{
				if(i == 0)
				{
					for(int k = 0; k < buf.size(); k ++)
					{
						if(buf[k].position[2] > 0.0)
						{
							up_buf.push_back(j * 4 + k);
						}
					}
				}
				else
				{
					double max0 = -1.0E10, max1 = -1.0E11;
					int d0 = -99, d1 = -99;
					for(int k = 0; k < buf.size(); k ++)
					{
						if(buf[k].position[2] > max1)
						{
							if(buf[k].position[2] > max0)
							{
								max1 = max0;
								d1 = d0;
								max0 = buf[k].position[2];
								d0 = k;
							}
							else
							{
								max1 = buf[k].position[2];
								d1 = k;
							}
						}
					}
					for(int k = 0; k < buf.size(); k ++)
					{
						if(k != d0 && k != d1)
						{
							up_buf.push_back(j * 4 + k);
						}
						else if(k == d1)
						{
							down_buf.push_back(j * 4 + k);
						}
					}
				}
			}

			flg = false;

			for(int k = 0; k < _down.size(); k ++)
			{
				if(j == _down[k])
				{
					flg = true;
					break;
				}
			}

			if(flg == true)
			{
				if(i == 0)
				{
					double min = 1.0E10;
					int d = -99;
					for(int k = 0; k < buf.size(); k ++)
					{
						if(buf[k].position[2] > 0.0)
						{
							if(buf[k].position[2] < min)
							{
								min = buf[k].position[2];
								d = k;
							}
						}
					}
					for(int k = 0; k < buf.size(); k ++)
					{
						if(buf[k].position[2] > 0.0)
						{
							if(k == d)
							{
								up_buf.push_back(j * 4 + d);
							}
							else
							{
								down_buf.push_back(j * 4 + k);
							}
						}
					}
				}
				else
				{
					double min = 1.0E10;
					int d = -99;
					for(int k = 0; k < buf.size(); k ++)
					{
						if(buf[k].position[2] > 0.0 && buf[k].position[2] < min)
						{
							min = buf[k].position[2];
							d = k;
						}
					}
					down_buf.push_back(j * 4 + d);
				}
				
			}

			for(int k = 0; k < 4; k ++)
			{
				newFace.push_back(buf[k]);
			}
		}

		_up = up_buf;
		_down = down_buf;

		face = newFace;
	}

	for(int i = 0; i < face.size(); i ++)
	{
		_point.push_back(face[i].position);
		solid_angle.push_back(face[i].solid_angle * 6.0 / 9.0);

		for(int j = 0; j < _up.size(); j ++)
		{
			if(i == _up[j])
			{
				solid_angle[solid_angle.size() - 1] = face[i].solid_angle * 8.0 / 9.0;
			}
		}
		for(int j = 0; j < _down.size(); j ++)
		{
			if(i == _down[j])
			{
				solid_angle[solid_angle.size() - 1] = face[i].solid_angle * 7.0 / 9.0;
			}
		}
	}

	std::vector<std::vector<double>> vor;

	for(int i = 0; i < face.size(); i ++)
	{
		bool flg = true;
		for(int j = 0; j < vor.size(); j ++)
		{
			if(_calculateVectorAngle(vor[j], face[i].vortex[0]) < 1.0E-5)
			{
				flg = false;
			}
		}
		if(flg == true)
		{
			vor.push_back(face[i].vortex[0]);
			_point.push_back(face[i].vortex[0]);
		}

		flg = true;
		for(int j = 0; j < vor.size(); j ++)
		{
			if(_calculateVectorAngle(vor[j], face[i].vortex[1]) < 1.0E-5)
			{
				flg = false;
			}
		}
		if(flg == true)
		{
			vor.push_back(face[i].vortex[1]);
			_point.push_back(face[i].vortex[1]);
		}

		flg = true;
		for(int j = 0; j < vor.size(); j ++)
		{
			if(_calculateVectorAngle(vor[j], face[i].vortex[2]) < 1.0E-5)
			{
				flg = false;
			}
		}
		if(flg == true)
		{
			vor.push_back(face[i].vortex[2]);
			_point.push_back(face[i].vortex[2]);
		}
	}

	for(int i = 0; i < _point.size(); i ++)
	{
		_normalizeVector(_point[i]);
	}

	std::vector<std::vector<int>> S6 = std::vector<std::vector<int>>(vor.size(), std::vector<int>(6));
	std::vector<int> nvor;

	for(int i = 0; i < vor.size(); i ++)
	{
		std::vector<double> min = {1.0E10, 2.0E10, 3.0E10, 4.0E10, 5.0E10, 6.0E10};
		std::vector<int> fn = {-99, -99, -99, -99, -99, -99};

		for(int j = 0; j < face.size(); j ++)
		{
			double theta = _calculateVectorAngle(vor[i], face[j].position);

			if(theta < min[5])
			{
				if(theta < min[4])
				{
					if(theta < min[3])
					{
						if(theta < min[2])
						{
							if(theta < min[1])
							{
								if(theta < min[0])
								{
									for(int k = 0; k < 5; k ++)
									{
										min[5 - k] = min[4 - k];
										fn[5 - k] = fn[4 - k];
									}
									min[0] = theta;
									fn[0] = j;
								}
								else
								{
									for(int k = 0; k < 4; k ++)
									{
										min[5 - k] = min[4 - k];
										fn[5 - k] = fn[4 - k];
									}
									min[1] = theta;
									fn[1] = j;
								}
							}
							else
							{
								for(int k = 0; k < 3; k ++)
								{
									min[5 - k] = min[4 - k];
									fn[5 - k] = fn[4 - k];
								}
								min[2] = theta;
								fn[2] = j;
							}
						}
						else
						{
							for(int k = 0; k < 2; k ++)
							{
								min[5 - k] = min[4 - k];
								fn[5 - k] = fn[4 - k];
							}
							min[3] = theta;
							fn[3] = j;
						}
					}
					else
					{
						for(int k = 0; k < 1; k ++)
						{
							min[5 - k] = min[4 - k];
							fn[5 - k] = fn[4 - k];
						}
						min[4] = theta;
						fn[4] = j;
					}
				}
				else
				{
					min[5] = theta;
					fn[5] = j;
					
				}
			}
		}

		S6[i] = fn;

		double sa0 = 0.0;
		bool flg = false;
		for(int j = 0; j < vortex.size(); j ++)
		{
			if(_calculateVectorAngle(vor[i], vortex[j]) < 1.0E-5)
			{
				flg = true;
			}
		}
		if(flg == true)
		{
			nvor.push_back(solid_angle.size());
			//std::cout << sa.size() << std::endl;
			for(int k = 0; k < 5; k ++)
			{
				sa0 += face[fn[k]].solid_angle / 9.0;
			}
		}
		else
		{
			for(int k = 0; k < 6; k ++)
			{
				sa0 += face[fn[k]].solid_angle / 9.0;
			}
		}

		solid_angle.push_back(sa0);
	}

	face.resize(0);

	for(int i = 0; i < _point.size(); i ++)
	{
		Face buf;
		buf.position = _point[i];
		buf.position_polar = _calculatePositionPolarVector(_point[i]);
		buf.solid_angle = solid_angle[i];
		//bool vflg = false, uflg = false, dflg = false;
		for(int j = 0; j < nvor.size(); j ++)
		{
			if(i == nvor[j])
			{
				buf.vortex_flg = true;
			}
		}
		for(int j = 0; j < _up.size(); j ++)
		{
			if(i == _up[j])
			{
				buf.up_flg = true;
			}
		}
		for(int j = 0; j < _down.size(); j ++)
		{
			if(i == _down[j])
			{
				buf.down_flg = true;
			}
		}
		face.push_back(buf);
	}

	for(int i = 0; i < face.size(); i ++)
	{
		if(face[i].position[2] <= 1.0E-5)
		{
			face.erase(face.begin() + i);
			i --;
		}
	}

	num_face = face.size();

	for(int i = 0; i < face.size(); i ++)
	{
		if(face[i].vortex_flg == true)
		{
			face[i].neighbour.resize(5);
			std::vector<double> min = {1.0E10, 2.0E10, 3.0E10, 4.0E10, 5.0E10};
			std::vector<int> fn = {-99, -99, -99, -99, -99};

			for(int j = 0; j < face.size(); j ++)
			{
				if(i != j)
				{
					double theta = _calculateFaceAngle(face[i], face[j]);

					if(theta < min[4])
					{
						if(theta < min[3])
						{
							if(theta < min[2])
							{
								if(theta < min[1])
								{
									if(theta < min[0])
									{
										for(int k = 0; k < 4; k ++)
										{
											min[4 - k] = min[3 - k];
											fn[4 - k] = fn[3 - k];
										}
										min[0] = theta;
										fn[0] = j;
									}
									else
									{
										for(int k = 0; k < 3; k ++)
										{
											min[4 - k] = min[3 - k];
											fn[4 - k] = fn[3 - k];
										}
										min[1] = theta;
										fn[1] = j;
									}
								}
								else
								{
									for(int k = 0; k < 2; k ++)
									{
										min[4 - k] = min[3 - k];
										fn[4 - k] = fn[3 - k];
									}
									min[2] = theta;
									fn[2] = j;
								}
							}
							else
							{
								for(int k = 0; k < 1; k ++)
								{
									min[4 - k] = min[3 - k];
									fn[4 - k] = fn[3 - k];
								}
								min[3] = theta;
								fn[3] = j;
							}
						}
						else
						{
							min[4] = theta;
							fn[4] = j;
						}
					}
				}
			}

			face[i].neighbour = fn;
			_sortVortex(i, face[i].neighbour);
		}
		else if(face[i].up_flg == true)
		{
			face[i].neighbour.resize(5);
			std::vector<double> min_u = {1.0E10, 2.0E10};
			std::vector<int> fn_u = {-99, -99};
			std::vector<double> min_d = {1.0E10, 2.0E10};
			std::vector<int> fn_d = {-99, -99};
			double min_g = 1.0E10;
			int fn_g = -99;;
			std::vector<int> fn = {-99, -99, -99, -99, -99};

			for(int j = 0; j < face.size(); j ++)
			{
				if(i != j)
				{
					double theta = _calculateFaceAngle(face[i], face[j]);

					if(face[j].up_flg == true)
					{
						if(theta < min_u[1])
						{
							if(theta < min_u[0])
							{
								min_u[1] = min_u[0];
								fn_u[1] = fn_u[0];
								min_u[0] = theta;
								fn_u[0] = j;
							}
							else
							{
								min_u[1] = theta;
								fn_u[1] = j;
							}
						}
					}
					else if(face[j].down_flg == true)
					{
						if(theta < min_d[1])
						{
							if(theta < min_d[0])
							{
								min_d[1] = min_d[0];
								fn_d[1] = fn_d[0];
								min_d[0] = theta;
								fn_d[0] = j;
							}
							else
							{
								min_d[1] = theta;
								fn_d[1] = j;
							}
						}
					}
					else
					{
						if(theta < min_g)
						{
							min_g = theta;
							fn_g = j;
						}
					}
				}
			}

			face[i].neighbour[0] = fn_u[0];
			face[i].neighbour[1] = fn_u[1];
			face[i].neighbour[2] = fn_d[0];
			face[i].neighbour[3] = fn_d[1];
			face[i].neighbour[4] = fn_g;
			_sortVortex(i, face[i].neighbour);
		}
		else if(face[i].down_flg == true)
		{
			face[i].neighbour.resize(5);
			std::vector<double> min = {1.0E10, 2.0E10, 3.0E10, 4.0E10, 5.0E10};
			std::vector<int> fn = {-99, -99, -99, -99, -99};

			for(int j = 0; j < face.size(); j ++)
			{
				if(i != j)
				{
					double theta = _calculateFaceAngle(face[i], face[j]);

					if(theta < min[4])
					{
						if(theta < min[3])
						{
							if(theta < min[2])
							{
								if(theta < min[1])
								{
									if(theta < min[0])
									{
										for(int k = 0; k < 4; k ++)
										{
											min[4 - k] = min[3 - k];
											fn[4 - k] = fn[3 - k];
										}
										min[0] = theta;
										fn[0] = j;
									}
									else
									{
										for(int k = 0; k < 3; k ++)
										{
											min[4 - k] = min[3 - k];
											fn[4 - k] = fn[3 - k];
										}
										min[1] = theta;
										fn[1] = j;
									}
								}
								else
								{
									for(int k = 0; k < 2; k ++)
									{
										min[4 - k] = min[3 - k];
										fn[4 - k] = fn[3 - k];
									}
									min[2] = theta;
									fn[2] = j;
								}
							}
							else
							{
								for(int k = 0; k < 1; k ++)
								{
									min[4 - k] = min[3 - k];
									fn[4 - k] = fn[3 - k];
								}
								min[3] = theta;
								fn[3] = j;
							}
						}
						else
						{
							min[4] = theta;
							fn[4] = j;
						}
					}
				}
			}

			face[i].neighbour = fn;
			_sortVortex(i, face[i].neighbour);
		}
		else
		{
			face[i].neighbour.resize(6);
			std::vector<double> min = {1.0E10, 2.0E10, 3.0E10, 4.0E10, 5.0E10, 6.0E10};
			std::vector<int> fn = {-99, -99, -99, -99, -99, -99};

			for(int j = 0; j < face.size(); j ++)
			{
				if(i != j)
				{
					double theta = _calculateFaceAngle(face[i], face[j]);

					if(theta < min[5])
					{
						if(theta < min[4])
						{
							if(theta < min[3])
							{
								if(theta < min[2])
								{
									if(theta < min[1])
									{
										if(theta < min[0])
										{
											for(int k = 0; k < 5; k ++)
											{
												min[5 - k] = min[4 - k];
												fn[5 - k] = fn[4 - k];
											}
											min[0] = theta;
											fn[0] = j;
										}
										else
										{
											for(int k = 0; k < 4; k ++)
											{
												min[5 - k] = min[4 - k];
												fn[5 - k] = fn[4 - k];
											}
											min[1] = theta;
											fn[1] = j;
										}
									}
									else
									{
										for(int k = 0; k < 3; k ++)
										{
											min[5 - k] = min[4 - k];
											fn[5 - k] = fn[4 - k];
										}
										min[2] = theta;
										fn[2] = j;
									}
								}
								else
								{
									for(int k = 0; k < 2; k ++)
									{
										min[5 - k] = min[4 - k];
										fn[5 - k] = fn[4 - k];
									}
									min[3] = theta;
									fn[3] = j;
								}
							}
							else
							{
								for(int k = 0; k < 1; k ++)
								{
									min[5 - k] = min[4 - k];
									fn[5 - k] = fn[4 - k];
								}
								min[4] = theta;
								fn[4] = j;
							}
						}
						else
						{
							min[5] = theta;
							fn[5] = j;
							
						}
					}
				}
			}

			face[i].neighbour = fn;
			_sortVortex(i, face[i].neighbour);
		}

		if(face[i].up_flg == false && face[i].down_flg == false)
		{
			for(int j = 0; j < face[i].neighbour.size() - 1; j ++)
			{
				double x = (face[i].position[0] + face[face[i].neighbour[j]].position[0] + face[face[i].neighbour[j + 1]].position[0]) / 3.0;
				double y = (face[i].position[1] + face[face[i].neighbour[j]].position[1] + face[face[i].neighbour[j + 1]].position[1]) / 3.0;
				double z = (face[i].position[2] + face[face[i].neighbour[j]].position[2] + face[face[i].neighbour[j + 1]].position[2]) / 3.0;

				std::vector<double> pol = {x, y, z};
				face[i].polygon.push_back(pol);
			}

			double x = (face[i].position[0] + face[face[i].neighbour[face[i].neighbour.size() - 1]].position[0] + face[face[i].neighbour[0]].position[0]) / 3.0;
			double y = (face[i].position[1] + face[face[i].neighbour[face[i].neighbour.size() - 1]].position[1] + face[face[i].neighbour[0]].position[1]) / 3.0;
			double z = (face[i].position[2] + face[face[i].neighbour[face[i].neighbour.size() - 1]].position[2] + face[face[i].neighbour[0]].position[2]) / 3.0;
			face[i].polygon.push_back(face[i].polygon[0]);
		}
		else if(face[i].down_flg == true)
		{
			for(int j = 0; j < face[i].neighbour.size() - 1; j ++)
			{
				double x = (face[i].position[0] + face[face[i].neighbour[j]].position[0] + face[face[i].neighbour[j + 1]].position[0]) / 3.0;
				double y = (face[i].position[1] + face[face[i].neighbour[j]].position[1] + face[face[i].neighbour[j + 1]].position[1]) / 3.0;
				double z = (face[i].position[2] + face[face[i].neighbour[j]].position[2] + face[face[i].neighbour[j + 1]].position[2]) / 3.0;

				std::vector<double> pol = {x, y, z};
				face[i].polygon.push_back(pol);
			}

			double x = (face[i].position[0] + face[face[i].neighbour[face[i].neighbour.size() - 1]].position[0] + face[face[i].neighbour[0]].position[0]) / 3.0;
			double y = (face[i].position[1] + face[face[i].neighbour[face[i].neighbour.size() - 1]].position[1] + face[face[i].neighbour[0]].position[1]) / 3.0;
			double z = (face[i].position[2] + face[face[i].neighbour[face[i].neighbour.size() - 1]].position[2] + face[face[i].neighbour[0]].position[2]) / 3.0;
			
			double min = 1.0E10;
			int b = -99;
			for(int j = 0; j < face[i].polygon.size(); j ++)
			{
				if(face[i].polygon[j][2] < min)
				{
					min = face[i].polygon[j][2];
					b = j;
				}
			}
			face[i].polygon[b][2] = 0.0;
			_normalizeVector(face[i].polygon[b]);
			
			face[i].polygon.push_back(face[i].polygon[0]);
		}
		else if(face[i].up_flg == true)
		{
			for(int j = 0; j < face[i].neighbour.size() - 1; j ++)
			{
				double x = (face[i].position[0] + face[face[i].neighbour[j]].position[0] + face[face[i].neighbour[j + 1]].position[0]) / 3.0;
				double y = (face[i].position[1] + face[face[i].neighbour[j]].position[1] + face[face[i].neighbour[j + 1]].position[1]) / 3.0;
				double z = (face[i].position[2] + face[face[i].neighbour[j]].position[2] + face[face[i].neighbour[j + 1]].position[2]) / 3.0;

				std::vector<double> pol = {x, y, z};
				face[i].polygon.push_back(pol);
			}

			double x = (face[i].position[0] + face[face[i].neighbour[face[i].neighbour.size() - 1]].position[0] + face[face[i].neighbour[0]].position[0]) / 3.0;
			double y = (face[i].position[1] + face[face[i].neighbour[face[i].neighbour.size() - 1]].position[1] + face[face[i].neighbour[0]].position[1]) / 3.0;
			double z = (face[i].position[2] + face[face[i].neighbour[face[i].neighbour.size() - 1]].position[2] + face[face[i].neighbour[0]].position[2]) / 3.0;
			
			double min0 = 1.0E10, min1 = 2.0E10, min2 = 3.0E10;
			int b0 = -99, b1 = -99, b2 = -99;
			for(int j = 0; j < face[i].polygon.size(); j ++)
			{
				if(face[i].polygon[j][2] < min2)
				{
					if(face[i].polygon[j][2] < min1)
					{
						if(face[i].polygon[j][2] < min0)
						{
							min2 = min1;
							b2 = b1;
							min1 = min0;
							b1 = b0;
							min0 = face[i].polygon[j][2];
							b0 = j;
						}
						else
						{
							min2 = min1;
							b2 = b1;
							min1 = face[i].polygon[j][2];
							b1 = j;
						}
					}
					else
					{
						min2 = face[i].polygon[j][2];
						b2 = j;
					}
				}
			}
			face[i].polygon[b1][2] = 0.0;
			face[i].polygon[b2][2] = 0.0;
			_normalizeVector(face[i].polygon[b1]);
			_normalizeVector(face[i].polygon[b2]);
			face[i].polygon.erase(face[i].polygon.begin() + b0);
			face[i].polygon.push_back(face[i].polygon[0]);
		}
	}

	for(int i = 0; i < face.size(); i ++)
	{
		face[i].mu = std::cos(face[i].position_polar[0]);
	}

	for(int i = 0; i < face.size(); i ++)
	{
		face_uh.push_back(face[i]);

		Face temp = face[i];

		temp.position[0] *= -1.0;	temp.position[1] *= -1.0;	temp.position[2] *= -1.0;
		temp.position_polar[0] = M_PI - temp.position_polar[0];	temp.position_polar[1] += M_PI;
		if(temp.position_polar[1] >= 2.0 * M_PI)
		{
			temp.position_polar[1] =- 2.0 * M_PI;
		}

		face_lh.push_back(temp);
	}

	return;
}

inline void IcosahedralGrid::_normalizeVector(std::vector<double>& p)
{
	double r = std::sqrt(p[0] * p[0] + p[1] * p[1] + p[2] * p[2]);
	
	for(int i = 0; i < 3; i ++)
	{
		p[i] = p[i] / r;
	}

	return;
}

inline std::vector<double> IcosahedralGrid::_calculateNormalVector(std::vector<double> p1, std::vector<double> p2, std::vector<double> p3)
{
	std::vector<double> result(3);

	std::vector<double> v1(3), v2(3);
	std::vector<double> g(3);

	for(int i = 0; i < 3; i ++)
	{
		v1[i] = p2[i] - p1[i];
		v2[i] = p3[i] - p1[i];
		g[i] = (p1[i] + p2[i] + p3[i]) / 3.0;
	}

	for(int i = 0; i < 3; i ++)
	{
		result[0] = v1[1] * v2[2] - v1[2] * v2[1];
		result[1] = v1[2] * v2[0] - v1[0] * v2[2];
		result[2] = v1[0] * v2[1] - v1[1] * v2[0];
	}

	_normalizeVector(result);

	double inner = 0.0;

	for(int i = 0; i < 3; i ++)
	{
		inner += result[i] * g[i];
	}

	if(inner < 0)
	{
		for(int i = 0; i < 3; i ++)
		{
			result[i] *= -1.0;
		}
	}

	return result;
}

inline std::vector<double> IcosahedralGrid::_calculatePositionVector(Face p)
{
	std::vector<double> result(3);

	for(int i = 0; i < 3; i ++)
	{
		result[i] = (p.vortex[0][i] + p.vortex[1][i] + p.vortex[2][i]) / 3.0;
	}

	return result;
}

inline std::vector<double> IcosahedralGrid::_calculatePositionPolarVector(Face p)
{
	std::vector<double> result(2);

	double x = p.position[0];
	double y = p.position[1];
	double z = p.position[2];

	double r = std::sqrt(x * x + y * y + z * z);

	result[0] = std::acos(z / r);
	result[1] = std::atan2(y, x);

	return result;
}

inline std::vector<double> IcosahedralGrid::_calculatePositionPolarVector(std::vector<double> p)
{
	std::vector<double> result(2);

	double x = p[0];
	double y = p[1];
	double z = p[2];

	double r = std::sqrt(x * x + y * y + z * z);

	result[0] = std::acos(z / r);
	result[1] = std::atan2(y, x);

	return result;
}

inline std::vector<IcosahedralGrid::Face> IcosahedralGrid::_divideFace(Face p)
{
	std::vector<Face> result(4);

	for(int i = 0; i < 3; i ++)
	{
		result[0].vortex[0][i] = (p.vortex[0][i] + p.vortex[1][i]) / 2.0;
		result[0].vortex[1][i] = (p.vortex[1][i] + p.vortex[2][i]) / 2.0;
		result[0].vortex[2][i] = (p.vortex[0][i] + p.vortex[2][i]) / 2.0;
	}

	_normalizeVector(result[0].vortex[0]);
	_normalizeVector(result[0].vortex[1]);
	_normalizeVector(result[0].vortex[2]);

	result[1].vortex[0] = p.vortex[0];
	result[1].vortex[1] = result[0].vortex[0];
	result[1].vortex[2] = result[0].vortex[2];
	result[2].vortex[0] = result[0].vortex[0];
	result[2].vortex[1] = p.vortex[1];
	result[2].vortex[2] = result[0].vortex[1];
	result[3].vortex[0] = result[0].vortex[2];
	result[3].vortex[1] = result[0].vortex[1];
	result[3].vortex[2] = p.vortex[2];

	for(int i = 0; i < 4; i ++)
	{
		//result[i].normal = NormalVector(result[i].vortex[0], result[i].vortex[1], result[i].vortex[2]);
		result[i].position = _calculatePositionVector(result[i]);
		result[i].position_polar = _calculatePositionPolarVector(result[i]);
		result[i].solid_angle = _calculateSolidAngle(result[i]);
		//Polygon(result[i]);
	}

	return result;
}

inline double IcosahedralGrid::_calculateSolidAngle(Face p)
{
	//S=R^2(A+B+C-pi)
	//cos a = cos b cos c + sin b sin c cos A
	std::vector<double> origin = {0.0, 0.0, 0.0};
	std::vector<double> n0 = _calculateNormalVector(origin, p.vortex[1], p.vortex[2]);
	std::vector<double> n1 = _calculateNormalVector(origin, p.vortex[2], p.vortex[0]);
	std::vector<double> n2 = _calculateNormalVector(origin, p.vortex[0], p.vortex[1]);

	double angle0 = _calculateVectorAngle(n0, n1);
	double angle1 = _calculateVectorAngle(n1, n2);
	double angle2 = _calculateVectorAngle(n2, n0);

	if(angle0 > M_PI / 2.0)	angle0 = M_PI - angle0;
	if(angle1 > M_PI / 2.0)	angle1 = M_PI - angle1;
	if(angle2 > M_PI / 2.0)	angle2 = M_PI - angle2;

	return angle0 + angle1 + angle2 - M_PI;
}

inline double IcosahedralGrid::_calculateVectorAngle(std::vector<double> v1, std::vector<double> v2)
{
	double inner = v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
	double r1 = std::sqrt(v1[0] * v1[0] + v1[1] * v1[1] + v1[2] * v1[2]);
	double r2 = std::sqrt(v2[0] * v2[0] + v2[1] * v2[1] + v2[2] * v2[2]);

	double mu = inner / (r1 * r2);
	if(mu > 1.0)	mu = 1.0;
	else if(mu < -1.0)	mu = -1.0;

	double result = std::acos(mu);

	return result;
}

inline double IcosahedralGrid::_calculateFaceAngle(Face v1, Face v2)
{
	double inner = v1.position[0] * v2.position[0] + v1.position[1] * v2.position[1] + v1.position[2] * v2.position[2];
	double r1 = std::sqrt(v1.position[0] * v1.position[0] + v1.position[1] * v1.position[1] + v1.position[2] * v1.position[2]);
	double r2 = std::sqrt(v2.position[0] * v2.position[0] + v2.position[1] * v2.position[1] + v2.position[2] * v2.position[2]);
	double theta;
	if(inner / r1 / r2 >= 1.0)
	{
		theta = 0.0;
	}
	else if(inner / r1 / r2 <= -1.0)
	{
		theta = M_PI;
	}
	else
	{
		theta = std::acos(inner / r1 / r2);
	}

	return theta;
}

inline void IcosahedralGrid::_sortVortex(int center, std::vector<int>& fn)
{
	class Buf
	{
		public:
			int number;
			double theta;
			
			Buf(int n, double t)
			{
				number = n;
				theta = t;
				return;
			}
			
			Buf()
			{
				return;
			}
	};

	int n = fn.size();

	std::vector<Buf> buf;

	buf.push_back(Buf(fn[0], 0.0));

	std::vector<double> p0 = {face[buf[0].number].position[0] - face[center].position[0], face[buf[0].number].position[1] - face[center].position[1], face[buf[0].number].position[2] - face[center].position[2]};

	for(int i = 1; i < n; i ++)
	{
		std::vector<double> p1 = {face[fn[i]].position[0] - face[center].position[0], face[fn[i]].position[1] - face[center].position[1], face[fn[i]].position[2] - face[center].position[2]};
		double inner = p0[0] * p1[0] + p0[1] * p1[1] + p0[2] * p1[2];
		double r1 = std::sqrt(p0[0] * p0[0] + p0[1] * p0[1] + p0[2] * p0[2]);
		double r2 = std::sqrt(p1[0] * p1[0] + p1[1] * p1[1] + p1[2] * p1[2]);
		double theta = std::acos(inner / r1 / r2);
		std::vector<double> cross = {p0[1] * p1[2] - p0[2] * p1[1], p0[2] * p1[0] - p0[0] * p1[2], p0[0] * p1[1] - p0[1] * p1[0]};
		if(cross[0] * face[center].position[0] + cross[1] * face[center].position[1] + cross[2] * face[center].position[2] < 0.0)
		{
			theta = 2.0 * M_PI - theta;
		}

		buf.push_back(Buf(fn[i], theta));
	}

	std::sort(buf.begin(), buf.end(), [](Buf v1, Buf v2){return v1.theta < v2.theta;});

	for(int i = 0; i < n; i ++)
	{
		fn[i] = buf[i].number;
	}

	fn.push_back(buf[0].number);

	return;
}

inline int IcosahedralGrid::_findFaceNumber(double theta, double phi)
{
	int result = -1;

	double x = std::sin(theta) * std::cos(phi);
	double y = std::sin(theta) * std::sin(phi);
	double z = std::cos(theta);

	for(int i = 0; i < face.size(); i ++)
	{
		if(_isPointOnFace(face[i], x, y, z))
		{
			result = i;
		}
	}

	return result;
}

inline bool IcosahedralGrid::_isPointOnFace(Face f, double x, double y, double z)
{
	std::vector<std::vector<double>> A = std::vector<std::vector<double>>(3, std::vector<double>(3));
	std::vector<std::vector<double>> A1 = std::vector<std::vector<double>>(3, std::vector<double>(3));
	std::vector<std::vector<double>> A2 = std::vector<std::vector<double>>(3, std::vector<double>(3));
	std::vector<std::vector<double>> A3 = std::vector<std::vector<double>>(3, std::vector<double>(3));

	for(int i = 0; i < 3; i ++)
	{
		for(int j = 0; j < 3; j ++)
		{
			A[i][j] = f.vortex[j][i];
			A1[i][j] = f.vortex[j][i];
			A2[i][j] = f.vortex[j][i];
			A3[i][j] = f.vortex[j][i];
		}
	}

	
	A1[0][0] = x;
	A1[1][0] = y;
	A1[2][0] = z;
	A2[0][1] = x;
	A2[1][1] = y;
	A2[2][1] = z;
	A3[0][2] = x;
	A3[1][2] = y;
	A3[2][2] = z;

	double k1, k2, k3;

	auto det = [](std::vector<std::vector<double>> X)
	{
		double x = 0.0;
		x += X[0][0] * X[1][1] * X[2][2];
		x += X[0][1] * X[1][2] * X[2][0];
		x += X[0][2] * X[1][0] * X[2][1];
		x -= X[0][2] * X[1][1] * X[2][0];
		x -= X[0][1] * X[1][0] * X[2][2];
		x -= X[0][0] * X[1][2] * X[2][1];
		return x;
	};

	double a = det(A);
	double a1 = det(A1);
	double a2 = det(A2);
	double a3 = det(A3);

	k1 = a1 / a;
	k2 = a2 / a;
	k3 = a3 / a;

	//std::cout << k1 << ", " << k2 << ", " << k3 << std::endl;

	if(k1 < 0.0 || k2 < 0.0 || k3 < 0.0)
	{
		return false;
	}
	else
	{
		return true;
	}
}

inline void SphericalGrid::initializeGrid()
{
	if(Ntheta % 2 == 0)
	{
		Ntheta ++;
	}

	Nphi.resize(Ntheta);

	std::vector<double> theta;
	double l = 0.5 * M_PI / double(Ntheta) * 0.01;
	double dtheta = (0.5 * M_PI - l) / double(Ntheta - 1);

	for(int i = 0; i < Ntheta; i ++)
	{
		theta.push_back(dtheta * double(i));
	}

	std::vector<std::vector<double>> phi(Ntheta);
	std::vector<double> dphi(Ntheta);
	phi[0] = {0.0};
	dphi[0] = 0.0;
	Nphi[0] = 1;
	for(int i = 1; i < Ntheta; i ++)
	{
		int n = std::round(2.0 * M_PI * std::sin(theta[i]) / dtheta);
		if(n % 2 != 0)
		{
			n ++;
		}

		Nphi[i] = n;

		double dph = 2.0 * M_PI / double(n);
		std::vector<double> temp;
		for(int j = 0; j < n; j ++)
		{
			temp.push_back(double(j) * dph);
			//std::cout << double(j) * dphi << std::endl;
		}
		phi[i] = temp;
		dphi[i] = dph;
	}
	
	double h = dtheta;
	double alpha = (h + l) * (h + l) * (h + l) + h * h * h;
	double beta = l * (l + 2.0 * h);
	double gamma = l + 2.0 * h;
	double A = alpha / (6.0 * h * h) - beta / (4.0 * h);
	double B = gamma - alpha / (3.0 * h * h);
	double C = -A + alpha / (3.0 * h * h);

	for(int i = 0; i < Ntheta; i ++)
	{
		for(int j = 0; j < Nphi[i]; j ++)
		{
			Face f;
			f.position_polar = {theta[i], phi[i][j]};
			f.position = {std::sin(theta[i]) * std::cos(phi[i][j]), std::sin(theta[i]) * std::sin(phi[i][j]), std::cos(theta[i])};
			f.mu = std::cos(theta[i]);

			if(i == 0)
			{
				for(int k = 0; k <= 12; k ++)
				{
					double phi = 2.0 * M_PI / 12.0 * double(k);
					double theta = dtheta / 2.0;

					std::vector<double> temp = {std::sin(theta) * std::cos(phi), std::sin(theta) * std::sin(phi), std::cos(theta)};

					f.polygon.push_back(temp);
				}
			}
			else if(i == Ntheta - 1)
			{
				std::vector<double> lt_polar = {f.position_polar[0] - dtheta / 2.0, f.position_polar[1] - dphi[i] / 2.0};
				std::vector<double> rt_polar = {f.position_polar[0] - dtheta / 2.0, f.position_polar[1] + dphi[i] / 2.0};
				std::vector<double> lb_polar = {0.5 * M_PI, f.position_polar[1] - dphi[i] / 2.0};
				std::vector<double> rb_polar = {0.5 * M_PI, f.position_polar[1] + dphi[i] / 2.0};

				std::vector<double> lt = {std::sin(lt_polar[0]) * std::cos(lt_polar[1]), std::sin(lt_polar[0]) * std::sin(lt_polar[1]), std::cos(lt_polar[0])};
				std::vector<double> rt = {std::sin(rt_polar[0]) * std::cos(rt_polar[1]), std::sin(rt_polar[0]) * std::sin(rt_polar[1]), std::cos(rt_polar[0])};
				std::vector<double> lb = {std::sin(lb_polar[0]) * std::cos(lb_polar[1]), std::sin(lb_polar[0]) * std::sin(lb_polar[1]), std::cos(lb_polar[0])};
				std::vector<double> rb = {std::sin(rb_polar[0]) * std::cos(rb_polar[1]), std::sin(rb_polar[0]) * std::sin(rb_polar[1]), std::cos(rb_polar[0])};

				for(int k = 0; k <= 4; k ++)
				{
					double x = lt[0] * (1.0 - double(k) / 4.0) + rt[0] * double(k) / 4.0;
					double y = lt[1] * (1.0 - double(k) / 4.0) + rt[1] * double(k) / 4.0;
					double z = lt[2] * (1.0 - double(k) / 4.0) + rt[2] * double(k) / 4.0;
					std::vector<double> temp = {x, y, z};
					f.polygon.push_back(temp);
				}
				for(int k = 1; k <= 4; k ++)
				{
					double x = rt[0] * (1.0 - double(k) / 4.0) + rb[0] * double(k) / 4.0;
					double y = rt[1] * (1.0 - double(k) / 4.0) + rb[1] * double(k) / 4.0;
					double z = rt[2] * (1.0 - double(k) / 4.0) + rb[2] * double(k) / 4.0;
					std::vector<double> temp = {x, y, z};
					f.polygon.push_back(temp);
				}
				for(int k = 1; k <= 4; k ++)
				{
					double x = rb[0] * (1.0 - double(k) / 4.0) + lb[0] * double(k) / 4.0;
					double y = rb[1] * (1.0 - double(k) / 4.0) + lb[1] * double(k) / 4.0;
					double z = rb[2] * (1.0 - double(k) / 4.0) + lb[2] * double(k) / 4.0;
					std::vector<double> temp = {x, y, z};
					f.polygon.push_back(temp);
				}
				for(int k = 1; k <= 4; k ++)
				{
					double x = lb[0] * (1.0 - double(k) / 4.0) + lt[0] * double(k) / 4.0;
					double y = lb[1] * (1.0 - double(k) / 4.0) + lt[1] * double(k) / 4.0;
					double z = lb[2] * (1.0 - double(k) / 4.0) + lt[2] * double(k) / 4.0;
					std::vector<double> temp = {x, y, z};
					f.polygon.push_back(temp);
				}
			}
			else
			{
				std::vector<double> lt_polar = {f.position_polar[0] - dtheta / 2.0, f.position_polar[1] - dphi[i] / 2.0};
				std::vector<double> rt_polar = {f.position_polar[0] - dtheta / 2.0, f.position_polar[1] + dphi[i] / 2.0};
				std::vector<double> lb_polar = {f.position_polar[0] + dtheta / 2.0, f.position_polar[1] - dphi[i] / 2.0};
				std::vector<double> rb_polar = {f.position_polar[0] + dtheta / 2.0, f.position_polar[1] + dphi[i] / 2.0};

				std::vector<double> lt = {std::sin(lt_polar[0]) * std::cos(lt_polar[1]), std::sin(lt_polar[0]) * std::sin(lt_polar[1]), std::cos(lt_polar[0])};
				std::vector<double> rt = {std::sin(rt_polar[0]) * std::cos(rt_polar[1]), std::sin(rt_polar[0]) * std::sin(rt_polar[1]), std::cos(rt_polar[0])};
				std::vector<double> lb = {std::sin(lb_polar[0]) * std::cos(lb_polar[1]), std::sin(lb_polar[0]) * std::sin(lb_polar[1]), std::cos(lb_polar[0])};
				std::vector<double> rb = {std::sin(rb_polar[0]) * std::cos(rb_polar[1]), std::sin(rb_polar[0]) * std::sin(rb_polar[1]), std::cos(rb_polar[0])};

				for(int k = 0; k <= 4; k ++)
				{
					double x = lt[0] * (1.0 - double(k) / 4.0) + rt[0] * double(k) / 4.0;
					double y = lt[1] * (1.0 - double(k) / 4.0) + rt[1] * double(k) / 4.0;
					double z = lt[2] * (1.0 - double(k) / 4.0) + rt[2] * double(k) / 4.0;
					std::vector<double> temp = {x, y, z};
					f.polygon.push_back(temp);
				}
				for(int k = 1; k <= 4; k ++)
				{
					double x = rt[0] * (1.0 - double(k) / 4.0) + rb[0] * double(k) / 4.0;
					double y = rt[1] * (1.0 - double(k) / 4.0) + rb[1] * double(k) / 4.0;
					double z = rt[2] * (1.0 - double(k) / 4.0) + rb[2] * double(k) / 4.0;
					std::vector<double> temp = {x, y, z};
					f.polygon.push_back(temp);
				}
				for(int k = 1; k <= 4; k ++)
				{
					double x = rb[0] * (1.0 - double(k) / 4.0) + lb[0] * double(k) / 4.0;
					double y = rb[1] * (1.0 - double(k) / 4.0) + lb[1] * double(k) / 4.0;
					double z = rb[2] * (1.0 - double(k) / 4.0) + lb[2] * double(k) / 4.0;
					std::vector<double> temp = {x, y, z};
					f.polygon.push_back(temp);
				}
				for(int k = 1; k <= 4; k ++)
				{
					double x = lb[0] * (1.0 - double(k) / 4.0) + lt[0] * double(k) / 4.0;
					double y = lb[1] * (1.0 - double(k) / 4.0) + lt[1] * double(k) / 4.0;
					double z = lb[2] * (1.0 - double(k) / 4.0) + lt[2] * double(k) / 4.0;
					std::vector<double> temp = {x, y, z};
					f.polygon.push_back(temp);
				}
			}

			double w;
			if(i == 0)
			{
				w = dtheta / 3.0 * std::sin(theta[i]);
			}
			else if(i == Ntheta - 3)
			{
				if(j % 2 == 0)
				{
					w = dtheta / 3.0 + A;
					w *= (2.0 * dphi[i] * std::sin(theta[i]) / 3.0);
				}
				else
				{
					w = w = dtheta / 3.0 + A;
					w *= (4.0 * dphi[i] * std::sin(theta[i]) / 3.0);
				}
			}
			else if(i == Ntheta - 2)
			{
				if(j % 2 == 0)
				{
					w = B * (2.0 * dphi[i] * std::sin(theta[i]) / 3.0);
				}
				else
				{
					w = B * (4.0 * dphi[i] * std::sin(theta[i]) / 3.0);
				}
			}
			else if(i == Ntheta - 1)
			{
				if(j % 2 == 0)
				{
					w = C * (2.0 * dphi[i] * std::sin(theta[i]) / 3.0);
				}
				else
				{
					w = C * (4.0 * dphi[i] * std::sin(theta[i]) / 3.0);
				}
			}
			else if(i % 2 == 0)
			{
				if(j % 2 == 0)
				{
					w = 4.0 / 9.0 * dtheta * dphi[i] * std::sin(theta[i]);
				}
				else
				{
					w = 8.0 / 9.0 * dtheta * dphi[i] * std::sin(theta[i]);
				}
			}
			else
			{
				if(j % 2 == 0)
				{
					w = 8.0 / 9.0 * dtheta * dphi[i] * std::sin(theta[i]);
				}
				else
				{
					w = 16.0 / 9.0 * dtheta * dphi[i] * std::sin(theta[i]);
				}
			}

			f.weight = w;
			
			face.push_back(f);
		}
	}

	num_face = face.size();

	for(int i = 0; i < num_face; i ++)
	{
		face_uh.push_back(face[i]);

		Face temp = face[i];

		temp.position[0] *= -1.0;	temp.position[1] *= -1.0;	temp.position[2] *= -1.0;
		temp.position_polar[0] = M_PI - temp.position_polar[0];	temp.position_polar[1] += M_PI;
		if(temp.position_polar[1] >= 2.0 * M_PI)
		{
			temp.position_polar[1] -= 2.0 * M_PI;
		}

		face_lh.push_back(temp);
	}

	// std::vector<std::vector<double>> w_column_uh_ptr = std::vector<std::vector<double>>(N, std::vector<double>(1));
	// std::vector<std::vector<double>> w_row_uh_ptr = std::vector<std::vector<double>>(1, std::vector<double>(N));
	// std::vector<std::vector<double>> muw_column_uh_ptr = std::vector<std::vector<double>>(N, std::vector<double>(1));
	// std::vector<std::vector<double>> muw_row_uh_ptr = std::vector<std::vector<double>>(1, std::vector<double>(N));
	// std::vector<std::vector<double>> w_uh_ptr = std::vector<std::vector<double>>(N, std::vector<double>(N));
	// std::vector<std::vector<double>> muw_uh_ptr = std::vector<std::vector<double>>(N, std::vector<double>(N));

	// std::vector<std::vector<double>> w_column_lh_ptr = std::vector<std::vector<double>>(N, std::vector<double>(1));
	// std::vector<std::vector<double>> w_row_lh_ptr = std::vector<std::vector<double>>(1, std::vector<double>(N));
	// std::vector<std::vector<double>> muw_column_lh_ptr = std::vector<std::vector<double>>(N, std::vector<double>(1));
	// std::vector<std::vector<double>> muw_row_lh_ptr = std::vector<std::vector<double>>(1, std::vector<double>(N));
	// std::vector<std::vector<double>> w_lh_ptr = std::vector<std::vector<double>>(N, std::vector<double>(N));
	// std::vector<std::vector<double>> muw_lh_ptr = std::vector<std::vector<double>>(N, std::vector<double>(N));

	// Eigen::MatrixXd w_column_uh_ptr = Eigen::MatrixXd::Zero(N, 1);
	// Eigen::MatrixXd w_row_uh_ptr = Eigen::MatrixXd::Zero(1, N);
	// Eigen::MatrixXd muw_column_uh_ptr = Eigen::MatrixXd::Zero(N, 1);
	// Eigen::MatrixXd muw_row_uh_ptr = Eigen::MatrixXd::Zero(1, N);
	// Eigen::MatrixXd w_uh_ptr = Eigen::MatrixXd::Zero(N, N);
	// Eigen::MatrixXd muw_uh_ptr = Eigen::MatrixXd::Zero(N, N);

	// Eigen::MatrixXd w_column_lh_ptr = Eigen::MatrixXd::Zero(N, 1);
	// Eigen::MatrixXd w_row_lh_ptr = Eigen::MatrixXd::Zero(1, N);
	// Eigen::MatrixXd muw_column_lh_ptr = Eigen::MatrixXd::Zero(N, 1);
	// Eigen::MatrixXd muw_row_lh_ptr = Eigen::MatrixXd::Zero(1, N);
	// Eigen::MatrixXd w_lh_ptr = Eigen::MatrixXd::Zero(N, N);
	// Eigen::MatrixXd muw_lh_ptr = Eigen::MatrixXd::Zero(N, N);

	weight_column_uh_ptr = new double[num_face];
	weight_row_uh_ptr = new double[num_face];
	mu_weight_column_uh_ptr = new double[num_face];
	mu_weight_row_uh_ptr = new double[num_face];
	weight_column_lh_ptr = new double[num_face];
	weight_row_lh_ptr = new double[num_face];
	mu_weight_column_lh_ptr = new double[num_face];
	mu_weight_row_lh_ptr = new double[num_face];
	weight_uh_ptr = new double[num_face * num_face];
	mu_weight_uh_ptr = new double[num_face * num_face];
	weight_lh_ptr = new double[num_face * num_face];
	mu_weight_lh_ptr = new double[num_face * num_face];

	#pragma omp parallel for
	for(int i = 0; i < num_face; i ++)
	{
		for(int j = 0; j < num_face; j ++)
		{
			int idx = i * num_face + j;
			weight_uh_ptr[idx] = 0.0;
			mu_weight_uh_ptr[idx] = 0.0;
			weight_lh_ptr[idx] = 0.0;
			mu_weight_lh_ptr[idx] = 0.0;
			// w_uh_ptr[i][j] = 0.0;
			// muw_uh_ptr[i][j] = 0.0;
			// w_lh_ptr[i][j] = 0.0;
			// muw_lh_ptr[i][j] = 0.0;
		}
	}

	#pragma omp parallel for
	for(int i = 0; i < num_face; i ++)
	{
		int idx = i * num_face + i;
		weight_column_uh_ptr[i] = face_uh[i].weight;
		weight_row_uh_ptr[i] = face_uh[i].weight;
		mu_weight_column_uh_ptr[i] = face_uh[i].mu * face_uh[i].weight;
		mu_weight_row_uh_ptr[i] = face_uh[i].mu * face_uh[i].weight;
		weight_uh_ptr[idx] = face_uh[i].weight;
		mu_weight_uh_ptr[idx] = face_uh[i].weight * face_uh[i].mu;

		weight_column_lh_ptr[i] = face_lh[i].weight;
		weight_row_lh_ptr[i] = face_lh[i].weight;
		mu_weight_column_lh_ptr[i] = face_lh[i].mu * face_lh[i].weight;
		mu_weight_row_lh_ptr[i] = face_lh[i].mu * face_lh[i].weight;
		weight_lh_ptr[idx] = face_lh[i].weight;
		mu_weight_lh_ptr[idx] = face_lh[i].weight * face_lh[i].mu;

		// w_column_uh_ptr(i, 0) = face_uh[i].weight;
		// w_row_uh_ptr(0, i) = face_uh[i].weight;
		// muw_column_uh_ptr(i, 0) = face_uh[i].mu * face_uh[i].weight;
		// muw_row_uh_ptr(0, i) = face_uh[i].mu * face_uh[i].weight;
		// w_uh_ptr(i, i) = face_uh[i].weight;
		// muw_uh_ptr(i, i) = face_uh[i].weight * face_uh[i].mu;

		// w_column_lh_ptr(i, 0) = face_lh[i].weight;
		// w_row_lh_ptr(0, i) = face_lh[i].weight;
		// muw_column_lh_ptr(i, 0) = face_lh[i].mu * face_lh[i].weight;
		// muw_row_lh_ptr(0, i) = face_lh[i].mu * face_lh[i].weight;
		// w_lh_ptr(i, i) = face_lh[i].weight;
		// muw_lh_ptr(i, i) = face_lh[i].weight * face_lh[i].mu;
	}

	Nphi0.push_back(0);
	int nphi0_counter = 0;
	for(int i = 0; i < Ntheta - 1; i ++)
	{
		nphi0_counter += Nphi[i];
		Nphi0.push_back(nphi0_counter);
	}

	// weight_column_uh_ptr = w_column_uh_ptr;
	// weight_row_uh_ptr = w_row_uh_ptr;
	// mu_weight_column_uh_ptr = muw_column_uh_ptr;
	// mu_weight_row_uh_ptr = muw_row_uh_ptr;
	// weight_uh_ptr = w_uh_ptr;
	// mu_weight_uh_ptr = muw_uh_ptr;

	// weight_column_lh_ptr = w_column_lh_ptr;
	// weight_row_lh_ptr = w_row_lh_ptr;
	// mu_weight_column_lh_ptr = muw_column_lh_ptr;
	// mu_weight_row_lh_ptr = muw_row_lh_ptr;
	// weight_lh_ptr = w_lh_ptr;
	// mu_weight_lh_ptr = muw_lh_ptr;

	return;
}

inline SphericalGrid::Face::Face()
{
	position.resize(3);
	position_polar.resize(2);
}

}

#endif